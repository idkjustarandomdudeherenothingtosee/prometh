// Auto-generated Lua modules bundle for Fengari
const LUA_MODULES = {
  "cli": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- cli.lua\n-- This script contains the Code for the Prometheus CLI\n\n-- Configure package.path for requiring Prometheus\nlocal function script_path()\n\tlocal str = debug.getinfo(2, \"S\").source:sub(2)\n\treturn str:match(\"(.*[/%\\\\])\")\nend\npackage.path = script_path() .. \"?.lua;\" .. package.path;\n---@diagnostic disable-next-line: different-requires\nlocal Prometheus = require(\"prometheus\");\nPrometheus.Logger.logLevel = Prometheus.Logger.LogLevel.Info;\n\n-- Check if the file exists\nlocal function file_exists(file)\n    local f = io.open(file, \"rb\")\n    if f then f:close() end\n    return f ~= nil\nend\n\nstring.split = function(str, sep)\n    local fields = {}\n    local pattern = string.format(\"([^%s]+)\", sep)\n    str:gsub(pattern, function(c) fields[#fields+1] = c end)\n    return fields\nend\n\n-- get all lines from a file, returns an empty\n-- list/table if the file does not exist\nlocal function lines_from(file)\n    if not file_exists(file) then return {} end\n    local lines = {}\n    for line in io.lines(file) do\n      lines[#lines + 1] = line\n    end\n    return lines\n  end\n\n-- CLI\nlocal config;\nlocal sourceFile;\nlocal outFile;\nlocal luaVersion;\nlocal prettyPrint;\n\nPrometheus.colors.enabled = true;\n\n-- Parse Arguments\nlocal i = 1;\nwhile i <= #arg do\n    local curr = arg[i];\n    if curr:sub(1, 2) == \"--\" then\n        if curr == \"--preset\" or curr == \"--p\" then\n            if config then\n                Prometheus.Logger:warn(\"The config was set multiple times\");\n            end\n\n            i = i + 1;\n            local preset = Prometheus.Presets[arg[i]];\n            if not preset then\n                Prometheus.Logger:error(string.format(\"A Preset with the name \\\"%s\\\" was not found!\", tostring(arg[i])));\n            end\n\n            config = preset;\n        elseif curr == \"--config\" or curr == \"--c\" then\n            i = i + 1;\n            local filename = tostring(arg[i]);\n            if not file_exists(filename) then\n                Prometheus.Logger:error(string.format(\"The config file \\\"%s\\\" was not found!\", filename));\n            end\n\n            local content = table.concat(lines_from(filename), \"\\n\");\n            -- Load Config from File\n            local func = loadstring(content);\n            -- Sandboxing\n            setfenv(func, {});\n            config = func();\n        elseif curr == \"--out\" or curr == \"--o\" then\n            i = i + 1;\n            if(outFile) then\n                Prometheus.Logger:warn(\"The output file was specified multiple times!\");\n            end\n            outFile = arg[i];\n        elseif curr == \"--nocolors\" then\n            Prometheus.colors.enabled = false;\n        elseif curr == \"--Lua51\" then\n            luaVersion = \"Lua51\";\n        elseif curr == \"--LuaU\" then\n            luaVersion = \"LuaU\";\n        elseif curr == \"--pretty\" then\n            prettyPrint = true;\n        elseif curr == \"--saveerrors\" then\n            -- Override error callback\n            Prometheus.Logger.errorCallback =  function(...)\n                print(Prometheus.colors(Prometheus.Config.NameUpper .. \": \" .. ..., \"red\"))\n                \n                local args = {...};\n                local message = table.concat(args, \" \");\n                \n                local fileName = sourceFile:sub(-4) == \".lua\" and sourceFile:sub(0, -5) .. \".error.txt\" or sourceFile .. \".error.txt\";\n                local handle = io.open(fileName, \"w\");\n                handle:write(message);\n                handle:close();\n\n                os.exit(1);\n            end;\n        else\n            Prometheus.Logger:warn(string.format(\"The option \\\"%s\\\" is not valid and therefore ignored\", curr));\n        end\n    else\n        if sourceFile then\n            Prometheus.Logger:error(string.format(\"Unexpected argument \\\"%s\\\"\", arg[i]));\n        end\n        sourceFile = tostring(arg[i]);\n    end\n    i = i + 1;\nend\n\nif not sourceFile then\n    Prometheus.Logger:error(\"No input file was specified!\")\nend\n\nif not config then\n    Prometheus.Logger:warn(\"No config was specified, falling back to Minify preset\");\n    config = Prometheus.Presets.Minify;\nend\n\n-- Add Option to override Lua Version\nconfig.LuaVersion = luaVersion or config.LuaVersion;\nconfig.PrettyPrint = prettyPrint ~= nil and prettyPrint or config.PrettyPrint;\n\nif not file_exists(sourceFile) then\n    Prometheus.Logger:error(string.format(\"The File \\\"%s\\\" was not found!\", sourceFile));\nend\n\nif not outFile then\n    if sourceFile:sub(-4) == \".lua\" then\n        outFile = sourceFile:sub(0, -5) .. \".obfuscated.lua\";\n    else\n        outFile = sourceFile .. \".obfuscated.lua\";\n    end\nend\n\nlocal source = table.concat(lines_from(sourceFile), \"\\n\");\nlocal pipeline = Prometheus.Pipeline:fromConfig(config);\nlocal out = pipeline:apply(source, sourceFile);\nPrometheus.Logger:info(string.format(\"Writing output to \\\"%s\\\"\", outFile));\n\n-- Write Output\nlocal handle = io.open(outFile, \"w\");\nhandle:write(out);\nhandle:close();\n",
  "colors": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n  \nlocal keys = {\n  reset =      0,\n  \n  bright     = 1,\n  dim        = 2,\n  underline  = 4,\n  blink      = 5,\n  reverse    = 7,\n  hidden     = 8,\n  \n  black     = 30,\n  pink      = 91,\n  red       = 31,\n  green     = 32,\n  yellow     = 33,\n  blue      = 34,\n  magenta   = 35,\n  cyan      = 36,\n  grey      = 37,\n  gray      = 37,\n  white     = 97,\n  \n  blackbg   = 40,\n  redbg     = 41,\n  greenbg   = 42,\n  yellowbg  = 43,\n  bluebg    = 44,\n  magentabg = 45,\n  cyanbg    = 46,\n  greybg    = 47,\n  graybg    = 47,\n  whitebg   = 107,\n}\n  \nlocal escapeString = string.char(27) .. '[%dm';\nlocal function escapeNumber(number)\n  return escapeString:format(number)\nend\n\n\nlocal settings = {\n  enabled = true,\n}\n\nlocal function colors(str, ...)\n  if not settings.enabled then\n    return str;\n  end\n  str = tostring(str or '')\n\n  local escapes = {};\n  for i, name in ipairs({...}) do\n      table.insert(escapes, escapeNumber(keys[name]))\n  end\n\n  return escapeNumber(keys.reset) .. table.concat(escapes) .. str .. escapeNumber(keys.reset);\nend\n  \nreturn setmetatable(settings, { __call = function(_, ...) return colors(...) end});",
  "config": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- config.lua\n--\n-- In this Script, some Global config Variables are defined\n\nlocal NAME    = \"Prometheus\";\nlocal REVISION = \"Alpha\";\nlocal VERSION = \"v0.2\";\nlocal BY      = \"levno-710\";\n\nfor _, currArg in pairs(arg) do\n\tif currArg == \"--CI\" then\n\t\tlocal releaseName = string.gsub(string.format(\"%s %s %s\", NAME, REVISION, VERSION), \"%s\", \"-\")\n\t\tprint(releaseName)\n\tend\n\t\n\tif currArg == \"--FullVersion\" then\n\t\tprint(VERSION)\n\tend\nend\n\n-- Config Starts here\nreturn {\n\tName = NAME,\n\tNameUpper = string.upper(NAME),\n\tNameAndVersion = string.format(\"%s %s\", NAME, VERSION),\n\tVersion = VERSION;\n\tRevision = REVISION;\n\t-- Config Starts Here\n\tIdentPrefix = \"__prometheus_\"; -- The Prefix used for Identifiers generated by PROMETHEUS. NOTE: There should be no identifiers in the script to be obfuscated starting with that prefix, because that can lead to weird bugs\n\t\n\tSPACE = \" \"; -- The Whitespace to be used by the unparser\n\tTAB   = \"\\t\"; -- The Tab Whitespace to be used by the unparser for pretty printing\n}",
  "highlightlua": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- This Script provides a simple Method for Syntax Highlighting of Lua code\n\nlocal Tokenizer = require(\"prometheus.tokenizer\");\nlocal colors    = require(\"colors\");\nlocal TokenKind = Tokenizer.TokenKind;\nlocal lookupify = require(\"prometheus.util\").lookupify;\n\nreturn function(code, luaVersion)\n    local out = \"\";\n    local tokenizer = Tokenizer:new({\n        LuaVersion = luaVersion,\n    });\n\n    tokenizer:append(code);\n    local tokens = tokenizer:scanAll();\n\n    local nonColorSymbols = lookupify{\n        \",\", \";\", \"(\", \")\", \"{\", \"}\", \".\", \":\", \"[\", \"]\"\n    }\n\n    local defaultGlobals = lookupify{\n        \"string\", \"table\", \"bit32\", \"bit\"\n    }\n\n    local currentPos = 1;\n    for _, token in ipairs(tokens) do\n        if token.startPos >= currentPos then\n            out = out .. string.sub(code, currentPos, token.startPos);\n        end\n        if token.kind == TokenKind.Ident then\n            if defaultGlobals[token.source] then\n                out = out .. colors(token.source, \"red\");\n            else\n                out = out .. token.source;\n            end\n        elseif token.kind == TokenKind.Keyword then\n            if token.source == \"nil\" then\n                out = out .. colors(token.source, \"yellow\");\n            else\n                out = out .. colors(token.source, \"yellow\");\n            end\n        elseif token.kind == TokenKind.Symbol then\n            if nonColorSymbols[token.source] then\n                out = out .. token.source;\n            else\n                out = out .. colors(token.source, \"yellow\");\n            end\n        elseif token.kind == TokenKind.String then\n            out = out .. colors(token.source, \"green\")\n        elseif token.kind == TokenKind.Number then\n            out = out .. colors(token.source, \"red\")\n        else\n            out = out .. token.source;\n        end\n\n        currentPos = token.endPos + 1;\n    end\n    return out;\nend",
  "logger": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- logger.lua\n\nlocal logger = {}\nlocal config = require(\"config\");\nlocal colors = require(\"colors\");\n\nlogger.LogLevel = {\n\tError = 0,\n\tWarn = 1,\n\tLog = 2,\n\tInfo = 2,\n\tDebug = 3,\n}\n\nlogger.logLevel = logger.LogLevel.Log;\n\nlogger.debugCallback = function(...)\n\tprint(colors(config.NameUpper .. \": \" ..  ..., \"grey\"));\nend;\nfunction logger:debug(...)\n\tif self.logLevel >= self.LogLevel.Debug then\n\t\tself.debugCallback(...);\n\tend\nend\n\nlogger.logCallback = function(...)\n\tprint(colors(config.NameUpper .. \": \", \"magenta\") .. ...);\nend;\nfunction logger:log(...)\n\tif self.logLevel >= self.LogLevel.Log then\n\t\tself.logCallback(...);\n\tend\nend\n\nfunction logger:info(...)\n\tif self.logLevel >= self.LogLevel.Log then\n\t\tself.logCallback(...);\n\tend\nend\n\nlogger.warnCallback = function(...)\n\tprint(colors(config.NameUpper .. \": \" .. ..., \"yellow\"));\nend;\nfunction logger:warn(...)\n\tif self.logLevel >= self.LogLevel.Warn then\n\t\tself.warnCallback(...);\n\tend\nend\n\nlogger.errorCallback = function(...)\n\tprint(colors(config.NameUpper .. \": \" .. ..., \"red\"))\n\terror(...);\nend;\nfunction logger:error(...)\n\tself.errorCallback(...);\n\terror(config.NameUpper .. \": logger.errorCallback did not throw an Error!\");\nend\n\n\nreturn logger;",
  "presets": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- pipeline.lua\n--\n-- This Script Provides some configuration presets\n\nreturn {\n    [\"Minify\"] = {\n        -- The default LuaVersion is Lua51\n        LuaVersion = \"Lua51\";\n        -- For minifying no VarNamePrefix is applied\n        VarNamePrefix = \"\";\n        -- Name Generator for Variables\n        NameGenerator = \"MangledShuffled\";\n        -- No pretty printing\n        PrettyPrint = false;\n        -- Seed is generated based on current time\n        Seed = 0;\n        -- No obfuscation steps\n        Steps = {\n\n        }\n    };\n    [\"Weak\"] = {\n        -- The default LuaVersion is Lua51\n        LuaVersion = \"Lua51\";\n        -- For minifying no VarNamePrefix is applied\n        VarNamePrefix = \"\";\n        -- Name Generator for Variables that look like this: IlI1lI1l\n        NameGenerator = \"MangledShuffled\";\n        -- No pretty printing\n        PrettyPrint = false;\n        -- Seed is generated based on current time\n        Seed = 0;\n        -- Obfuscation steps\n        Steps = {\n            {\n                Name = \"Vmify\";\n                Settings = {\n                    \n                };\n            },\n            {\n                Name = \"ConstantArray\";\n                Settings = {\n                    Treshold    = 1;\n                    StringsOnly = true;\n                }\n            },\n            {\n                Name = \"WrapInFunction\";\n                Settings = {\n\n                }\n            },\n        }\n    };\n    [\"Medium\"] = {\n        -- The default LuaVersion is Lua51\n        LuaVersion = \"Lua51\";\n        -- For minifying no VarNamePrefix is applied\n        VarNamePrefix = \"\";\n        -- Name Generator for Variables\n        NameGenerator = \"MangledShuffled\";\n        -- No pretty printing\n        PrettyPrint = false;\n        -- Seed is generated based on current time\n        Seed = 0;\n        -- Obfuscation steps\n        Steps = {\n            {\n                Name = \"EncryptStrings\";\n                Settings = {\n\n                };\n            },\n            {\n                Name = \"AntiTamper\";\n                Settings = {\n                    UseDebug = false;\n                };\n            },\n            {\n                Name = \"Vmify\";\n                Settings = {\n                    \n                };\n            },\n            {\n                Name = \"ConstantArray\";\n                Settings = {\n                    Treshold    = 1;\n                    StringsOnly = true;\n                    Shuffle     = true;\n                    Rotate      = true;\n                    LocalWrapperTreshold = 0;\n                }\n            },\n            {\n                Name = \"NumbersToExpressions\";\n                Settings = {\n\n                }\n            },\n            {\n                Name = \"WrapInFunction\";\n                Settings = {\n\n                }\n            },\n        }\n    };\n    [\"Strong\"] = {\n        -- The default LuaVersion is Lua51\n        LuaVersion = \"Lua51\";\n        -- For minifying no VarNamePrefix is applied\n        VarNamePrefix = \"\";\n        -- Name Generator for Variables that look like this: IlI1lI1l\n        NameGenerator = \"MangledShuffled\";\n        -- No pretty printing\n        PrettyPrint = false;\n        -- Seed is generated based on current time\n        Seed = 0;\n        -- Obfuscation steps\n        Steps = {\n            {\n                Name = \"Vmify\";\n                Settings = {\n                    \n                };\n            },\n            {\n                Name = \"EncryptStrings\";\n                Settings = {\n\n                };\n            },\n            {\n                Name = \"AntiTamper\";\n                Settings = {\n\n                };\n            },\n            {\n                Name = \"Vmify\";\n                Settings = {\n                    \n                };\n            },\n            {\n                Name = \"ConstantArray\";\n                Settings = {\n                    Treshold    = 1;\n                    StringsOnly = true;\n                    Shuffle     = true;\n                    Rotate      = true;\n                    LocalWrapperTreshold = 0;\n                }\n            },\n            {\n                Name = \"NumbersToExpressions\";\n                Settings = {\n\n                }\n            },\n            {\n                Name = \"WrapInFunction\";\n                Settings = {\n\n                }\n            },\n        }\n    },\n}\n",
  "prometheus": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- prometheus.lua\n-- This file is the entrypoint for Prometheus\n\n-- Configure package.path for require\nlocal function script_path()\n\tlocal str = debug.getinfo(2, \"S\").source:sub(2)\n\treturn str:match(\"(.*[/%\\\\])\")\nend\n\nlocal oldPkgPath = package.path;\npackage.path = script_path() .. \"?.lua;\" .. package.path;\n\n-- Math.random Fix for Lua5.1\n-- Check if fix is needed\nif not pcall(function()\n    return math.random(1, 2^40);\nend) then\n    local oldMathRandom = math.random;\n    math.random = function(a, b)\n        if not a and b then\n            return oldMathRandom();\n        end\n        if not b then\n            return math.random(1, a);\n        end\n        if a > b then\n            a, b = b, a;\n        end\n        local diff = b - a;\n        assert(diff >= 0);\n        if diff > 2 ^ 31 - 1 then\n            return math.floor(oldMathRandom() * diff + a);\n        else\n            return oldMathRandom(a, b);\n        end\n    end\nend\n\n-- newproxy polyfill\n_G.newproxy = _G.newproxy or function(arg)\n    if arg then\n        return setmetatable({}, {});\n    end\n    return {};\nend\n\n\n-- Require Prometheus Submodules\nlocal Pipeline  = require(\"prometheus.pipeline\");\nlocal highlight = require(\"highlightlua\");\nlocal colors    = require(\"colors\");\nlocal Logger    = require(\"logger\");\nlocal Presets   = require(\"presets\");\nlocal Config    = require(\"config\");\nlocal util      = require(\"prometheus.util\");\n\n-- Restore package.path\npackage.path = oldPkgPath;\n\n-- Export\nreturn {\n    Pipeline  = Pipeline;\n    colors    = colors;\n    Config    = util.readonly(Config); -- Readonly\n    Logger    = Logger;\n    highlight = highlight;\n    Presets   = Presets;\n}\n\n",
  "prometheus.ast": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- ast.lua\n\nlocal Ast = {}\n\nlocal AstKind = {\n\t-- Misc\n\tTopNode = \"TopNode\";\n\tBlock = \"Block\";\n\n\t-- Statements\n\tContinueStatement = \"ContinueStatement\";\n\tBreakStatement = \"BreakStatement\";\n\tDoStatement = \"DoStatement\";\n\tWhileStatement = \"WhileStatement\";\n\tReturnStatement = \"ReturnStatement\";\n\tRepeatStatement = \"RepeatStatement\";\n\tForInStatement = \"ForInStatement\";\n\tForStatement = \"ForStatement\";\n\tIfStatement = \"IfStatement\";\n\tFunctionDeclaration = \"FunctionDeclaration\";\n\tLocalFunctionDeclaration = \"LocalFunctionDeclaration\";\n\tLocalVariableDeclaration = \"LocalVariableDeclaration\";\n\tFunctionCallStatement = \"FunctionCallStatement\";\n\tPassSelfFunctionCallStatement = \"PassSelfFunctionCallStatement\";\n\tAssignmentStatement = \"AssignmentStatement\";\n\n\t-- LuaU Compound Statements\n\tCompoundAddStatement = \"CompoundAddStatement\";\n\tCompoundSubStatement = \"CompoundSubStatement\";\n\tCompoundMulStatement = \"CompoundMulStatement\";\n\tCompoundDivStatement = \"CompoundDivStatement\";\n\tCompoundModStatement = \"CompoundModStatement\";\n\tCompoundPowStatement = \"CompoundPowStatement\";\n\tCompoundConcatStatement = \"CompoundConcatStatement\";\n\n\t-- Assignment Index\n\tAssignmentIndexing = \"AssignmentIndexing\";\n\tAssignmentVariable = \"AssignmentVariable\";  \n\n\t-- Expression Nodes\n\tBooleanExpression = \"BooleanExpression\";\n\tNumberExpression = \"NumberExpression\";\n\tStringExpression = \"StringExpression\";\n\tNilExpression = \"NilExpression\";\n\tVarargExpression = \"VarargExpression\";\n\tOrExpression = \"OrExpression\";\n\tAndExpression = \"AndExpression\";\n\tLessThanExpression = \"LessThanExpression\";\n\tGreaterThanExpression = \"GreaterThanExpression\";\n\tLessThanOrEqualsExpression = \"LessThanOrEqualsExpression\";\n\tGreaterThanOrEqualsExpression = \"GreaterThanOrEqualsExpression\";\n\tNotEqualsExpression = \"NotEqualsExpression\";\n\tEqualsExpression = \"EqualsExpression\";\n\tStrCatExpression = \"StrCatExpression\";\n\tAddExpression = \"AddExpression\";\n\tSubExpression = \"SubExpression\";\n\tMulExpression = \"MulExpression\";\n\tDivExpression = \"DivExpression\";\n\tModExpression = \"ModExpression\";\n\tNotExpression = \"NotExpression\";\n\tLenExpression = \"LenExpression\";\n\tNegateExpression = \"NegateExpression\";\n\tPowExpression = \"PowExpression\";\n\tIndexExpression = \"IndexExpression\";\n\tFunctionCallExpression = \"FunctionCallExpression\";\n\tPassSelfFunctionCallExpression = \"PassSelfFunctionCallExpression\";\n\tVariableExpression = \"VariableExpression\";\n\tFunctionLiteralExpression = \"FunctionLiteralExpression\";\n\tTableConstructorExpression = \"TableConstructorExpression\";\n\n\t-- Table Entry\n\tTableEntry = \"TableEntry\";\n\tKeyedTableEntry = \"KeyedTableEntry\";\n\n\t-- Misc\n\tNopStatement = \"NopStatement\";\n\n\tIfElseExpression = \"IfElseExpression\";\n}\n\nlocal astKindExpressionLookup = {\n\t[AstKind.BooleanExpression] = 0;\n\t[AstKind.NumberExpression] = 0;\n\t[AstKind.StringExpression] = 0;\n\t[AstKind.NilExpression] = 0;\n\t[AstKind.VarargExpression] = 0;\n\t[AstKind.OrExpression] = 12;\n\t[AstKind.AndExpression] = 11;\n\t[AstKind.LessThanExpression] = 10;\n\t[AstKind.GreaterThanExpression] = 10;\n\t[AstKind.LessThanOrEqualsExpression] = 10;\n\t[AstKind.GreaterThanOrEqualsExpression] = 10;\n\t[AstKind.NotEqualsExpression] = 10;\n\t[AstKind.EqualsExpression] = 10;\n\t[AstKind.StrCatExpression] = 9;\n\t[AstKind.AddExpression] = 8;\n\t[AstKind.SubExpression] = 8;\n\t[AstKind.MulExpression] = 7;\n\t[AstKind.DivExpression] = 7;\n\t[AstKind.ModExpression] = 7;\n\t[AstKind.NotExpression] = 5;\n\t[AstKind.LenExpression] = 5;\n\t[AstKind.NegateExpression] = 5;\n\t[AstKind.PowExpression] = 4;\n\t[AstKind.IndexExpression] = 1;\n\t[AstKind.AssignmentIndexing] = 1;\n\t[AstKind.FunctionCallExpression] = 2;\n\t[AstKind.PassSelfFunctionCallExpression] = 2;\n\t[AstKind.VariableExpression] = 0;\n\t[AstKind.AssignmentVariable] = 0;\n\t[AstKind.FunctionLiteralExpression] = 3;\n\t[AstKind.TableConstructorExpression] = 3;\n}\n\nAst.AstKind = AstKind;\n\nfunction Ast.astKindExpressionToNumber(kind)\n\treturn astKindExpressionLookup[kind] or 100;\nend\n\nfunction Ast.ConstantNode(val)\n\tif type(val) == \"nil\" then\n\t\treturn Ast.NilExpression();\n\tend\n\n\tif type(val) == \"string\" then\n\t\treturn Ast.StringExpression(val);\n\tend\n\n\tif type(val) == \"number\" then\n\t\treturn Ast.NumberExpression(val);\n\tend\n\n\tif type(val) == \"boolean\" then\n\t\treturn Ast.BooleanExpression(val);\n\tend\nend\n\n\n\nfunction Ast.NopStatement()\n\treturn {\n\t\tkind = AstKind.NopStatement;\n\t}\nend\n\nfunction Ast.IfElseExpression(condition, true_value, false_value)\n\treturn {\n\t\tkind = AstKind.IfElseExpression,\n\t\tcondition = condition,\n\t\ttrue_value = true_value,\n\t\tfalse_value = false_value\n\t}\nend\n\n-- Create Ast Top Node\nfunction Ast.TopNode(body, globalScope)\n\treturn {\n\t\tkind = AstKind.TopNode,\n\t\tbody = body,\n\t\tglobalScope = globalScope,\n\n\t}\nend\n\nfunction Ast.TableEntry(value)\n\treturn {\n\t\tkind = AstKind.TableEntry,\n\t\tvalue = value,\n\n\t}\nend\n\nfunction Ast.KeyedTableEntry(key, value)\n\treturn {\n\t\tkind = AstKind.KeyedTableEntry,\n\t\tkey = key,\n\t\tvalue = value,\n\n\t}\nend\n\nfunction Ast.TableConstructorExpression(entries)\n\treturn {\n\t\tkind = AstKind.TableConstructorExpression,\n\t\tentries = entries,\n\t};\nend\n\n-- Create Statement Block\nfunction Ast.Block(statements, scope)\n\treturn {\n\t\tkind = AstKind.Block,\n\t\tstatements = statements,\n\t\tscope = scope,\n\t}\nend\n\n-- Create Break Statement\nfunction Ast.BreakStatement(loop, scope)\n\treturn {\n\t\tkind = AstKind.BreakStatement,\n\t\tloop = loop,\n\t\tscope = scope,\n\t}\nend\n\n-- Create Continue Statement\nfunction Ast.ContinueStatement(loop, scope)\n\treturn {\n\t\tkind = AstKind.ContinueStatement,\n\t\tloop = loop,\n\t\tscope = scope,\n\t}\nend\n\nfunction Ast.PassSelfFunctionCallStatement(base, passSelfFunctionName, args)\n\treturn {\n\t\tkind = AstKind.PassSelfFunctionCallStatement,\n\t\tbase = base,\n\t\tpassSelfFunctionName = passSelfFunctionName,\n\t\targs = args,\n\t}\nend\n\nfunction Ast.AssignmentStatement(lhs, rhs)\n\tif(#lhs < 1) then\n\t\tprint(debug.traceback());\n\t\terror(\"Something went wrong!\");\n\tend\n\treturn {\n\t\tkind = AstKind.AssignmentStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundAddStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundAddStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundSubStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundSubStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundMulStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundMulStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundDivStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundDivStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundPowStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundPowStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundModStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundModStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.CompoundConcatStatement(lhs, rhs)\n\treturn {\n\t\tkind = AstKind.CompoundConcatStatement,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t}\nend\n\nfunction Ast.FunctionCallStatement(base, args)\n\treturn {\n\t\tkind = AstKind.FunctionCallStatement,\n\t\tbase = base,\n\t\targs = args,\n\t}\nend\n\nfunction Ast.ReturnStatement(args)\n\treturn {\n\t\tkind = AstKind.ReturnStatement,\n\t\targs = args,\n\t}\nend\n\nfunction Ast.DoStatement(body)\n\treturn {\n\t\tkind = AstKind.DoStatement,\n\t\tbody = body,\n\t}\nend\n\nfunction Ast.WhileStatement(body, condition, parentScope)\n\treturn {\n\t\tkind = AstKind.WhileStatement,\n\t\tbody = body,\n\t\tcondition = condition,\n\t\tparentScope = parentScope,\n\t}\nend\n\nfunction Ast.ForInStatement(scope, vars, expressions, body, parentScope)\n\treturn {\n\t\tkind = AstKind.ForInStatement,\n\t\tscope = scope,\n\t\tids = vars,\n\t\tvars = vars,\n\t\texpressions = expressions,\n\t\tbody = body,\n\t\tparentScope = parentScope,\n\t}\nend\n\nfunction Ast.ForStatement(scope, id, initialValue, finalValue, incrementBy, body, parentScope)\n\treturn {\n\t\tkind = AstKind.ForStatement,\n\t\tscope = scope,\n\t\tid = id,\n\t\tinitialValue = initialValue,\n\t\tfinalValue = finalValue,\n\t\tincrementBy = incrementBy,\n\t\tbody = body,\n\t\tparentScope = parentScope,\n\t}\nend\n\nfunction Ast.RepeatStatement(condition, body, parentScope)\n\treturn {\n\t\tkind = AstKind.RepeatStatement,\n\t\tbody = body,\n\t\tcondition = condition,\n\t\tparentScope = parentScope,\n\t}\nend\n\nfunction Ast.IfStatement(condition, body, elseifs, elsebody)\n\treturn {\n\t\tkind = AstKind.IfStatement,\n\t\tcondition = condition,\n\t\tbody = body,\n\t\telseifs = elseifs,\n\t\telsebody = elsebody,\n\t}\nend\n\nfunction Ast.FunctionDeclaration(scope, id, indices, args, body)\n\treturn {\n\t\tkind = AstKind.FunctionDeclaration,\n\t\tscope = scope,\n\t\tbaseScope = scope,\n\t\tid = id,\n\t\tbaseId = id,\n\t\tindices = indices,\n\t\targs = args,\n\t\tbody = body,\n\t\tgetName = function(self)\n\t\t\treturn self.scope:getVariableName(self.id);\n\t\tend,\n\t}\nend\n\nfunction Ast.LocalFunctionDeclaration(scope, id, args, body)\n\treturn {\n\t\tkind = AstKind.LocalFunctionDeclaration,\n\t\tscope = scope,\n\t\tid = id,\n\t\targs = args,\n\t\tbody = body,\n\t\tgetName = function(self)\n\t\t\treturn self.scope:getVariableName(self.id);\n\t\tend,\n\t}\nend\n\nfunction Ast.LocalVariableDeclaration(scope, ids, expressions)\n\treturn {\n\t\tkind = AstKind.LocalVariableDeclaration,\n\t\tscope = scope,\n\t\tids = ids,\n\t\texpressions = expressions,\n\t}\nend\n\nfunction Ast.VarargExpression()\n\treturn {\n\t\tkind = AstKind.VarargExpression;\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.BooleanExpression(value)\n\treturn {\n\t\tkind = AstKind.BooleanExpression,\n\t\tisConstant = true,\n\t\tvalue = value,\n\t}\nend\n\nfunction Ast.NilExpression()\n\treturn {\n\t\tkind = AstKind.NilExpression,\n\t\tisConstant = true,\n\t\tvalue = nil,\n\t}\nend\n\nfunction Ast.NumberExpression(value)\n\treturn {\n\t\tkind = AstKind.NumberExpression,\n\t\tisConstant = true,\n\t\tvalue = value,\n\t}\nend\n\nfunction Ast.StringExpression(value)\n\treturn {\n\t\tkind = AstKind.StringExpression,\n\t\tisConstant = true,\n\t\tvalue = value,\n\t}\nend\n\nfunction Ast.OrExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value or rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.OrExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.AndExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value and rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.AndExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.LessThanExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value < rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.LessThanExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.GreaterThanExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value > rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.GreaterThanExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.LessThanOrEqualsExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value <= rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.LessThanOrEqualsExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.GreaterThanOrEqualsExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value >= rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.GreaterThanOrEqualsExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.NotEqualsExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value ~= rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.NotEqualsExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.EqualsExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value == rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.EqualsExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.StrCatExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value .. rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.StrCatExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.AddExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value + rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.AddExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.SubExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value - rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.SubExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.MulExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value * rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.MulExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.DivExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant and rhs.value ~= 0) then\n\t\tlocal success, val = pcall(function() return lhs.value / rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.DivExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.ModExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value % rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.ModExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.NotExpression(rhs, simplify)\n\tif(simplify and rhs.isConstant) then\n\t\tlocal success, val = pcall(function() return not rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.NotExpression,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.NegateExpression(rhs, simplify)\n\tif(simplify and rhs.isConstant) then\n\t\tlocal success, val = pcall(function() return -rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.NegateExpression,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.LenExpression(rhs, simplify)\n\tif(simplify and rhs.isConstant) then\n\t\tlocal success, val = pcall(function() return #rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.LenExpression,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.PowExpression(lhs, rhs, simplify)\n\tif(simplify and rhs.isConstant and lhs.isConstant) then\n\t\tlocal success, val = pcall(function() return lhs.value ^ rhs.value end);\n\t\tif success then\n\t\t\treturn Ast.ConstantNode(val);\n\t\tend\n\tend\n\n\treturn {\n\t\tkind = AstKind.PowExpression,\n\t\tlhs = lhs,\n\t\trhs = rhs,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.IndexExpression(base, index)\n\treturn {\n\t\tkind = AstKind.IndexExpression,\n\t\tbase = base,\n\t\tindex = index,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.AssignmentIndexing(base, index)\n\treturn {\n\t\tkind = AstKind.AssignmentIndexing,\n\t\tbase = base,\n\t\tindex = index,\n\t\tisConstant = false,\n\t}\nend\n\nfunction Ast.PassSelfFunctionCallExpression(base, passSelfFunctionName, args)\n\treturn {\n\t\tkind = AstKind.PassSelfFunctionCallExpression,\n\t\tbase = base,\n\t\tpassSelfFunctionName = passSelfFunctionName,\n\t\targs = args,\n\n\t}\nend\n\nfunction Ast.FunctionCallExpression(base, args)\n\treturn {\n\t\tkind = AstKind.FunctionCallExpression,\n\t\tbase = base,\n\t\targs = args,\n\t}\nend\n\nfunction Ast.VariableExpression(scope, id)\n\tscope:addReference(id);\n\treturn {\n\t\tkind = AstKind.VariableExpression, \n\t\tscope = scope,\n\t\tid = id,\n\t\tgetName = function(self)\n\t\t\treturn self.scope.getVariableName(self.id);\n\t\tend,\n\t}\nend\n\nfunction Ast.AssignmentVariable(scope, id)\n\tscope:addReference(id);\n\treturn {\n\t\tkind = AstKind.AssignmentVariable, \n\t\tscope = scope,\n\t\tid = id,\n\t\tgetName = function(self)\n\t\t\treturn self.scope.getVariableName(self.id);\n\t\tend,\n\t}\nend\n\nfunction Ast.FunctionLiteralExpression(args, body)\n\treturn {\n\t\tkind = AstKind.FunctionLiteralExpression,\n\t\targs = args,\n\t\tbody = body,\n\t}\nend\n\n\n\nreturn Ast;\n",
  "prometheus.bit": "-- This Module was NOT written by Levno_710\n-- Credit: https://github.com/davidm/lua-bit-numberlua\n\n--[[\nLUA MODULE\n  bit.numberlua - Bitwise operations implemented in pure Lua as numbers,\n    with Lua 5.2 'bit32' and (LuaJIT) LuaBitOp 'bit' compatibility interfaces.\nSYNOPSIS\n  local bit = require 'bit.numberlua'\n  print(bit.band(0xff00ff00, 0x00ff00ff)) --> 0xffffffff\n  \n  -- Interface providing strong Lua 5.2 'bit32' compatibility\n  local bit32 = require 'bit.numberlua'.bit32\n  assert(bit32.band(-1) == 0xffffffff)\n  \n  -- Interface providing strong (LuaJIT) LuaBitOp 'bit' compatibility\n  local bit = require 'bit.numberlua'.bit\n  assert(bit.tobit(0xffffffff) == -1)\n  \nDESCRIPTION\n  \n  This library implements bitwise operations entirely in Lua.\n  This module is typically intended if for some reasons you don't want\n  to or cannot  install a popular C based bit library like BitOp 'bit' [1]\n  (which comes pre-installed with LuaJIT) or 'bit32' (which comes\n  pre-installed with Lua 5.2) but want a similar interface.\n  \n  This modules represents bit arrays as non-negative Lua numbers. [1]\n  It can represent 32-bit bit arrays when Lua is compiled\n  with lua_Number as double-precision IEEE 754 floating point.\n  The module is nearly the most efficient it can be but may be a few times\n  slower than the C based bit libraries and is orders or magnitude\n  slower than LuaJIT bit operations, which compile to native code.  Therefore,\n  this library is inferior in performane to the other modules.\n  The `xor` function in this module is based partly on Roberto Ierusalimschy's\n  post in http://lua-users.org/lists/lua-l/2002-09/msg00134.html .\n  \n  The included BIT.bit32 and BIT.bit sublibraries aims to provide 100%\n  compatibility with the Lua 5.2 \"bit32\" and (LuaJIT) LuaBitOp \"bit\" library.\n  This compatbility is at the cost of some efficiency since inputted\n  numbers are normalized and more general forms (e.g. multi-argument\n  bitwise operators) are supported.\n  \nSTATUS\n  WARNING: Not all corner cases have been tested and documented.\n  Some attempt was made to make these similar to the Lua 5.2 [2]\n  and LuaJit BitOp [3] libraries, but this is not fully tested and there\n  are currently some differences.  Addressing these differences may\n  be improved in the future but it is not yet fully determined how to\n  resolve these differences.\n  \n  The BIT.bit32 library passes the Lua 5.2 test suite (bitwise.lua)\n  http://www.lua.org/tests/5.2/ .  The BIT.bit library passes the LuaBitOp\n  test suite (bittest.lua).  However, these have not been tested on\n  platforms with Lua compiled with 32-bit integer numbers.\nAPI\n  BIT.tobit(x) --> z\n  \n    Similar to function in BitOp.\n    \n  BIT.tohex(x, n)\n  \n    Similar to function in BitOp.\n  \n  BIT.band(x, y) --> z\n  \n    Similar to function in Lua 5.2 and BitOp but requires two arguments.\n  \n  BIT.bor(x, y) --> z\n  \n    Similar to function in Lua 5.2 and BitOp but requires two arguments.\n  BIT.bxor(x, y) --> z\n  \n    Similar to function in Lua 5.2 and BitOp but requires two arguments.\n  \n  BIT.bnot(x) --> z\n  \n    Similar to function in Lua 5.2 and BitOp.\n  BIT.lshift(x, disp) --> z\n  \n    Similar to function in Lua 5.2 (warning: BitOp uses unsigned lower 5 bits of shift),\n  \n  BIT.rshift(x, disp) --> z\n  \n    Similar to function in Lua 5.2 (warning: BitOp uses unsigned lower 5 bits of shift),\n  BIT.extract(x, field [, width]) --> z\n  \n    Similar to function in Lua 5.2.\n  \n  BIT.replace(x, v, field, width) --> z\n  \n    Similar to function in Lua 5.2.\n  \n  BIT.bswap(x) --> z\n  \n    Similar to function in Lua 5.2.\n  BIT.rrotate(x, disp) --> z\n  BIT.ror(x, disp) --> z\n  \n    Similar to function in Lua 5.2 and BitOp.\n  BIT.lrotate(x, disp) --> z\n  BIT.rol(x, disp) --> z\n    Similar to function in Lua 5.2 and BitOp.\n  \n  BIT.arshift\n  \n    Similar to function in Lua 5.2 and BitOp.\n    \n  BIT.btest\n  \n    Similar to function in Lua 5.2 with requires two arguments.\n  BIT.bit32\n  \n    This table contains functions that aim to provide 100% compatibility\n    with the Lua 5.2 \"bit32\" library.\n    \n    bit32.arshift (x, disp) --> z\n    bit32.band (...) --> z\n    bit32.bnot (x) --> z\n    bit32.bor (...) --> z\n    bit32.btest (...) --> true | false\n    bit32.bxor (...) --> z\n    bit32.extract (x, field [, width]) --> z\n    bit32.replace (x, v, field [, width]) --> z\n    bit32.lrotate (x, disp) --> z\n    bit32.lshift (x, disp) --> z\n    bit32.rrotate (x, disp) --> z\n    bit32.rshift (x, disp) --> z\n  BIT.bit\n  \n    This table contains functions that aim to provide 100% compatibility\n    with the LuaBitOp \"bit\" library (from LuaJIT).\n    \n    bit.tobit(x) --> y\n    bit.tohex(x [,n]) --> y\n    bit.bnot(x) --> y\n    bit.bor(x1 [,x2...]) --> y\n    bit.band(x1 [,x2...]) --> y\n    bit.bxor(x1 [,x2...]) --> y\n    bit.lshift(x, n) --> y\n    bit.rshift(x, n) --> y\n    bit.arshift(x, n) --> y\n    bit.rol(x, n) --> y\n    bit.ror(x, n) --> y\n    bit.bswap(x) --> y\n    \nDEPENDENCIES\n  None (other than Lua 5.1 or 5.2).\n    \nDOWNLOAD/INSTALLATION\n  If using LuaRocks:\n    luarocks install lua-bit-numberlua\n  Otherwise, download <https://github.com/davidm/lua-bit-numberlua/zipball/master>.\n  Alternately, if using git:\n    git clone git://github.com/davidm/lua-bit-numberlua.git\n    cd lua-bit-numberlua\n  Optionally unpack:\n    ./util.mk\n  or unpack and install in LuaRocks:\n    ./util.mk install \nREFERENCES\n  [1] http://lua-users.org/wiki/FloatingPoint\n  [2] http://www.lua.org/manual/5.2/\n  [3] http://bitop.luajit.org/\n  \nLICENSE\n  (c) 2008-2011 David Manura.  Licensed under the same terms as Lua (MIT).\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n  (end license)\n--]]\n\nlocal M = {_TYPE='module', _NAME='bit.numberlua', _VERSION='0.3.1.20120131'}\n\nlocal floor = math.floor\n\nlocal MOD = 2^32\nlocal MODM = MOD-1\n\nlocal function memoize(f)\n\tlocal mt = {}\n\tlocal t = setmetatable({}, mt)\n\tfunction mt:__index(k)\n\t\tlocal v = f(k); t[k] = v\n\t\treturn v\n\tend\n\treturn t\nend\n\nlocal function make_bitop_uncached(t, m)\n\tlocal function bitop(a, b)\n\t\tlocal res,p = 0,1\n\t\twhile a ~= 0 and b ~= 0 do\n\t\t\tlocal am, bm = a%m, b%m\n\t\t\tres = res + t[am][bm]*p\n\t\t\ta = (a - am) / m\n\t\t\tb = (b - bm) / m\n\t\t\tp = p*m\n\t\tend\n\t\tres = res + (a+b)*p\n\t\treturn res\n\tend\n\treturn bitop\nend\n\nlocal function make_bitop(t)\n\tlocal op1 = make_bitop_uncached(t,2^1)\n\tlocal op2 = memoize(function(a)\n\t\treturn memoize(function(b)\n\t\t\treturn op1(a, b)\n\t\tend)\n\tend)\n\treturn make_bitop_uncached(op2, 2^(t.n or 1))\nend\n\n-- ok?  probably not if running on a 32-bit int Lua number type platform\nfunction M.tobit(x)\n\treturn x % 2^32\nend\n\nM.bxor = make_bitop {[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0}, n=4}\nlocal bxor = M.bxor\n\nfunction M.bnot(a)   return MODM - a end\nlocal bnot = M.bnot\n\nfunction M.band(a,b) return ((a+b) - bxor(a,b))/2 end\nlocal band = M.band\n\nfunction M.bor(a,b)  return MODM - band(MODM - a, MODM - b) end\nlocal bor = M.bor\n\nlocal lshift, rshift -- forward declare\n\nfunction M.rshift(a,disp) -- Lua5.2 insipred\n\tif disp < 0 then return lshift(a,-disp) end\n\treturn floor(a % 2^32 / 2^disp)\nend\nrshift = M.rshift\n\nfunction M.lshift(a,disp) -- Lua5.2 inspired\n\tif disp < 0 then return rshift(a,-disp) end \n\treturn (a * 2^disp) % 2^32\nend\nlshift = M.lshift\n\nfunction M.tohex(x, n) -- BitOp style\n\tn = n or 8\n\tlocal up\n\tif n <= 0 then\n\t\tif n == 0 then return '' end\n\t\tup = true\n\t\tn = - n\n\tend\n\tx = band(x, 16^n-1)\n\treturn ('%0'..n..(up and 'X' or 'x')):format(x)\nend\nlocal tohex = M.tohex\n\nfunction M.extract(n, field, width) -- Lua5.2 inspired\n\twidth = width or 1\n\treturn band(rshift(n, field), 2^width-1)\nend\nlocal extract = M.extract\n\nfunction M.replace(n, v, field, width) -- Lua5.2 inspired\n\twidth = width or 1\n\tlocal mask1 = 2^width-1\n\tv = band(v, mask1) -- required by spec?\n\tlocal mask = bnot(lshift(mask1, field))\n\treturn band(n, mask) + lshift(v, field)\nend\nlocal replace = M.replace\n\nfunction M.bswap(x)  -- BitOp style\n\tlocal a = band(x, 0xff); x = rshift(x, 8)\n\tlocal b = band(x, 0xff); x = rshift(x, 8)\n\tlocal c = band(x, 0xff); x = rshift(x, 8)\n\tlocal d = band(x, 0xff)\n\treturn lshift(lshift(lshift(a, 8) + b, 8) + c, 8) + d\nend\nlocal bswap = M.bswap\n\nfunction M.rrotate(x, disp)  -- Lua5.2 inspired\n\tdisp = disp % 32\n\tlocal low = band(x, 2^disp-1)\n\treturn rshift(x, disp) + lshift(low, 32-disp)\nend\nlocal rrotate = M.rrotate\n\nfunction M.lrotate(x, disp)  -- Lua5.2 inspired\n\treturn rrotate(x, -disp)\nend\nlocal lrotate = M.lrotate\n\nM.rol = M.lrotate  -- LuaOp inspired\nM.ror = M.rrotate  -- LuaOp insipred\n\n\nfunction M.arshift(x, disp) -- Lua5.2 inspired\n\tlocal z = rshift(x, disp)\n\tif x >= 0x80000000 then z = z + lshift(2^disp-1, 32-disp) end\n\treturn z\nend\nlocal arshift = M.arshift\n\nfunction M.btest(x, y) -- Lua5.2 inspired\n\treturn band(x, y) ~= 0\nend\n\n--\n-- Start Lua 5.2 \"bit32\" compat section.\n--\n\nM.bit32 = {} -- Lua 5.2 'bit32' compatibility\n\n\nlocal function bit32_bnot(x)\n\treturn (-1 - x) % MOD\nend\nM.bit32.bnot = bit32_bnot\n\nlocal function bit32_bxor(a, b, c, ...)\n\tlocal z\n\tif b then\n\t\ta = a % MOD\n\t\tb = b % MOD\n\t\tz = bxor(a, b)\n\t\tif c then\n\t\t\tz = bit32_bxor(z, c, ...)\n\t\tend\n\t\treturn z\n\telseif a then\n\t\treturn a % MOD\n\telse\n\t\treturn 0\n\tend\nend\nM.bit32.bxor = bit32_bxor\n\nlocal function bit32_band(a, b, c, ...)\n\tlocal z\n\tif b then\n\t\ta = a % MOD\n\t\tb = b % MOD\n\t\tz = ((a+b) - bxor(a,b)) / 2\n\t\tif c then\n\t\t\tz = bit32_band(z, c, ...)\n\t\tend\n\t\treturn z\n\telseif a then\n\t\treturn a % MOD\n\telse\n\t\treturn MODM\n\tend\nend\nM.bit32.band = bit32_band\n\nlocal function bit32_bor(a, b, c, ...)\n\tlocal z\n\tif b then\n\t\ta = a % MOD\n\t\tb = b % MOD\n\t\tz = MODM - band(MODM - a, MODM - b)\n\t\tif c then\n\t\t\tz = bit32_bor(z, c, ...)\n\t\tend\n\t\treturn z\n\telseif a then\n\t\treturn a % MOD\n\telse\n\t\treturn 0\n\tend\nend\nM.bit32.bor = bit32_bor\n\nfunction M.bit32.btest(...)\n\treturn bit32_band(...) ~= 0\nend\n\nfunction M.bit32.lrotate(x, disp)\n\treturn lrotate(x % MOD, disp)\nend\n\nfunction M.bit32.rrotate(x, disp)\n\treturn rrotate(x % MOD, disp)\nend\n\nfunction M.bit32.lshift(x,disp)\n\tif disp > 31 or disp < -31 then return 0 end\n\treturn lshift(x % MOD, disp)\nend\n\nfunction M.bit32.rshift(x,disp)\n\tif disp > 31 or disp < -31 then return 0 end\n\treturn rshift(x % MOD, disp)\nend\n\nfunction M.bit32.arshift(x,disp)\n\tx = x % MOD\n\tif disp >= 0 then\n\t\tif disp > 31 then\n\t\t\treturn (x >= 0x80000000) and MODM or 0\n\t\telse\n\t\t\tlocal z = rshift(x, disp)\n\t\t\tif x >= 0x80000000 then z = z + lshift(2^disp-1, 32-disp) end\n\t\t\treturn z\n\t\tend\n\telse\n\t\treturn lshift(x, -disp)\n\tend\nend\n\nfunction M.bit32.extract(x, field, ...)\n\tlocal width = ... or 1\n\tif field < 0 or field > 31 or width < 0 or field+width > 32 then error 'out of range' end\n\tx = x % MOD\n\treturn extract(x, field, ...)\nend\n\nfunction M.bit32.replace(x, v, field, ...)\n\tlocal width = ... or 1\n\tif field < 0 or field > 31 or width < 0 or field+width > 32 then error 'out of range' end\n\tx = x % MOD\n\tv = v % MOD\n\treturn replace(x, v, field, ...)\nend\n\n\n--\n-- Start LuaBitOp \"bit\" compat section.\n--\n\nM.bit = {} -- LuaBitOp \"bit\" compatibility\n\nfunction M.bit.tobit(x)\n\tx = x % MOD\n\tif x >= 0x80000000 then x = x - MOD end\n\treturn x\nend\nlocal bit_tobit = M.bit.tobit\n\nfunction M.bit.tohex(x, ...)\n\treturn tohex(x % MOD, ...)\nend\n\nfunction M.bit.bnot(x)\n\treturn bit_tobit(bnot(x % MOD))\nend\n\nlocal function bit_bor(a, b, c, ...)\n\tif c then\n\t\treturn bit_bor(bit_bor(a, b), c, ...)\n\telseif b then\n\t\treturn bit_tobit(bor(a % MOD, b % MOD))\n\telse\n\t\treturn bit_tobit(a)\n\tend\nend\nM.bit.bor = bit_bor\n\nlocal function bit_band(a, b, c, ...)\n\tif c then\n\t\treturn bit_band(bit_band(a, b), c, ...)\n\telseif b then\n\t\treturn bit_tobit(band(a % MOD, b % MOD))\n\telse\n\t\treturn bit_tobit(a)\n\tend\nend\nM.bit.band = bit_band\n\nlocal function bit_bxor(a, b, c, ...)\n\tif c then\n\t\treturn bit_bxor(bit_bxor(a, b), c, ...)\n\telseif b then\n\t\treturn bit_tobit(bxor(a % MOD, b % MOD))\n\telse\n\t\treturn bit_tobit(a)\n\tend\nend\nM.bit.bxor = bit_bxor\n\nfunction M.bit.lshift(x, n)\n\treturn bit_tobit(lshift(x % MOD, n % 32))\nend\n\nfunction M.bit.rshift(x, n)\n\treturn bit_tobit(rshift(x % MOD, n % 32))\nend\n\nfunction M.bit.arshift(x, n)\n\treturn bit_tobit(arshift(x % MOD, n % 32))\nend\n\nfunction M.bit.rol(x, n)\n\treturn bit_tobit(lrotate(x % MOD, n % 32))\nend\n\nfunction M.bit.ror(x, n)\n\treturn bit_tobit(rrotate(x % MOD, n % 32))\nend\n\nfunction M.bit.bswap(x)\n\treturn bit_tobit(bswap(x % MOD))\nend\n\nreturn M",
  "prometheus.enums": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- enums.lua\n-- This file Provides some enums used by the Obfuscator\n\nlocal Enums = {};\n\nlocal chararray = require(\"prometheus.util\").chararray;\n\nEnums.LuaVersion = {\n\tLuaU  = \"LuaU\" ,\n\tLua51 = \"Lua51\",\n}\n\nEnums.Conventions = {\n\t[Enums.LuaVersion.Lua51] = {\n\t\tKeywords = {\n\t\t\t\"and\",    \"break\",  \"do\",    \"else\",     \"elseif\", \n\t\t\t\"end\",    \"false\",  \"for\",   \"function\", \"if\",   \n\t\t\t\"in\",     \"local\",  \"nil\",   \"not\",      \"or\",\n\t\t\t\"repeat\", \"return\", \"then\",  \"true\",     \"until\",    \"while\"\n\t\t},\n\t\t\n\t\tSymbolChars = chararray(\"+-*/%^#=~<>(){}[];:,.\"),\n\t\tMaxSymbolLength = 3,\n\t\tSymbols = {\n\t\t\t\"+\",  \"-\",  \"*\",  \"/\",  \"%\",  \"^\",  \"#\",\n\t\t\t\"==\", \"~=\", \"<=\", \">=\", \"<\",  \">\",  \"=\",\n\t\t\t\"(\",  \")\",  \"{\",  \"}\",  \"[\",  \"]\",\n\t\t\t\";\",  \":\",  \",\",  \".\",  \"..\", \"...\",\n\t\t},\n\n\t\tIdentChars          = chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789\"),\n\t\tNumberChars         = chararray(\"0123456789\"),\n\t\tHexNumberChars      = chararray(\"0123456789abcdefABCDEF\"),\n\t\tBinaryNumberChars   = {\"0\", \"1\"},\n\t\tDecimalExponent     = {\"e\", \"E\"},\n\t\tHexadecimalNums     = {\"x\", \"X\"},\n\t\tBinaryNums          = {\"b\", \"B\"},\n\t\tDecimalSeperators   = false,\n\t\t\n\t\tEscapeSequences     = {\n\t\t\t[\"a\"] = \"\\a\";\n\t\t\t[\"b\"] = \"\\b\";\n\t\t\t[\"f\"] = \"\\f\";\n\t\t\t[\"n\"] = \"\\n\";\n\t\t\t[\"r\"] = \"\\r\";\n\t\t\t[\"t\"] = \"\\t\";\n\t\t\t[\"v\"] = \"\\v\";\n\t\t\t[\"\\\\\"] = \"\\\\\";\n\t\t\t[\"\\\"\"] = \"\\\"\";\n\t\t\t[\"\\'\"] = \"\\'\";\n\t\t},\n\t\tNumericalEscapes = true,\n\t\tEscapeZIgnoreNextWhitespace = true,\n\t\tHexEscapes = true,\n\t\tUnicodeEscapes = true,\n\t},\n\t[Enums.LuaVersion.LuaU] = {\n\t\tKeywords = {\n\t\t\t\"and\",    \"break\",  \"do\",    \"else\",     \"elseif\", \"continue\",\n\t\t\t\"end\",    \"false\",  \"for\",   \"function\", \"if\",   \n\t\t\t\"in\",     \"local\",  \"nil\",   \"not\",      \"or\",\n\t\t\t\"repeat\", \"return\", \"then\",  \"true\",     \"until\",    \"while\"\n\t\t},\n\t\t\n\t\tSymbolChars = chararray(\"+-*/%^#=~<>(){}[];:,.\"),\n\t\tMaxSymbolLength = 3,\n\t\tSymbols = {\n\t\t\t\"+\",  \"-\",  \"*\",  \"/\",  \"%\",  \"^\",  \"#\",\n\t\t\t\"==\", \"~=\", \"<=\", \">=\", \"<\",  \">\",  \"=\",\n\t\t\t\"+=\", \"-=\", \"/=\", \"%=\", \"^=\", \"..=\", \"*=\",\n\t\t\t\"(\",  \")\",  \"{\",  \"}\",  \"[\",  \"]\",\n\t\t\t\";\",  \":\",  \",\",  \".\",  \"..\", \"...\",\n\t\t\t\"::\", \"->\", \"?\",  \"|\",  \"&\", \n\t\t},\n\n\t\tIdentChars          = chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789\"),\n\t\tNumberChars         = chararray(\"0123456789\"),\n\t\tHexNumberChars      = chararray(\"0123456789abcdefABCDEF\"),\n\t\tBinaryNumberChars   = {\"0\", \"1\"},\n\t\tDecimalExponent     = {\"e\", \"E\"},\n\t\tHexadecimalNums     = {\"x\", \"X\"},\n\t\tBinaryNums          = {\"b\", \"B\"},\n\t\tDecimalSeperators   = {\"_\"},\n\t\t\n\t\tEscapeSequences     = {\n\t\t\t[\"a\"] = \"\\a\";\n\t\t\t[\"b\"] = \"\\b\";\n\t\t\t[\"f\"] = \"\\f\";\n\t\t\t[\"n\"] = \"\\n\";\n\t\t\t[\"r\"] = \"\\r\";\n\t\t\t[\"t\"] = \"\\t\";\n\t\t\t[\"v\"] = \"\\v\";\n\t\t\t[\"\\\\\"] = \"\\\\\";\n\t\t\t[\"\\\"\"] = \"\\\"\";\n\t\t\t[\"\\'\"] = \"\\'\";\n\t\t},\n\t\tNumericalEscapes = true,\n\t\tEscapeZIgnoreNextWhitespace = true,\n\t\tHexEscapes = true,\n\t\tUnicodeEscapes = true,\n\t},\n}\n\nreturn Enums;\n",
  "prometheus.namegenerators": "return {\n\tMangled = require(\"prometheus.namegenerators.mangled\");\n\tMangledShuffled = require(\"prometheus.namegenerators.mangled_shuffled\");\n\tIl = require(\"prometheus.namegenerators.Il\");\n\tNumber = require(\"prometheus.namegenerators.number\");\n\tConfuse = require(\"prometheus.namegenerators.confuse\");\n}",
  "prometheus.parser": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- parser.lua\n-- Overview:\n-- This Script provides a class for parsing of lua code.\n-- This Parser is Capable of parsing LuaU and Lua5.1\n-- \n-- Note that when parsing LuaU \"continue\" is treated as a Keyword, so no variable may be named \"continue\" even though this would be valid in LuaU\n--\n-- Settings Object:\n-- luaVersion : The LuaVersion of the Script - Currently Supported : Lua51 and LuaU\n-- \n\nlocal Tokenizer = require(\"prometheus.tokenizer\");\nlocal Enums = require(\"prometheus.enums\");\nlocal util = require(\"prometheus.util\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal logger = require(\"logger\");\n\nlocal AstKind = Ast.AstKind;\n\nlocal LuaVersion = Enums.LuaVersion;\nlocal lookupify = util.lookupify;\nlocal unlookupify = util.unlookupify;\nlocal escape = util.escape;\nlocal chararray = util.chararray;\nlocal keys = util.keys;\n\nlocal TokenKind = Tokenizer.TokenKind;\n\nlocal Parser = {};\n\nlocal ASSIGNMENT_NO_WARN_LOOKUP = lookupify{\n\tAstKind.NilExpression,\n\tAstKind.FunctionCallExpression,\n\tAstKind.PassSelfFunctionCallExpression,\n\tAstKind.VarargExpression\n};\n\nlocal function generateError(self, message)\n\tlocal token;\n\tif(self.index > self.length) then\n\t\ttoken = self.tokens[self.length];\n\telseif(self.index < 1) then\n\t\treturn \"Parsing Error at Position 0:0, \" .. message;\n\telse\n\t\ttoken = self.tokens[self.index];\n\tend\n\t\n\treturn \"Parsing Error at Position \" .. tostring(token.line) .. \":\" .. tostring(token.linePos) .. \", \" .. message;\nend\n\nlocal function generateWarning(token, message)\n\treturn \"Warning at Position \" .. tostring(token.line) .. \":\" .. tostring(token.linePos) .. \", \" .. message;\nend\n\nfunction Parser:new(settings)\n\tlocal luaVersion = (settings and (settings.luaVersion or settings.LuaVersion)) or LuaVersion.LuaU;\n\tlocal parser = {\n\t\tluaVersion = luaVersion,\n\t\ttokenizer = Tokenizer:new({\n\t\t\tluaVersion = luaVersion\n\t\t}),\n\t\ttokens = {};\n\t\tlength = 0;\n\t\tindex = 0;\n\t};\n\t\n\tsetmetatable(parser, self);\n\tself.__index = self;\n\t\n\treturn parser;\nend\n\n-- Function to peek the n'th token\nlocal function peek(self, n)\n\tn = n or 0;\n\tlocal i = self.index + n + 1;\n\tif i > self.length then\n\t\treturn Tokenizer.EOF_TOKEN;\n\tend\n\treturn self.tokens[i];\nend\n\n-- Function to get the next Token\nlocal function get(self)\n\tlocal i = self.index + 1;\n\tif i > self.length then\n\t\terror(generateError(self, \"Unexpected end of Input\"));\n\tend\n\tself.index = self.index + 1;\n\tlocal tk = self.tokens[i];\n\t\n\treturn tk;\nend\n\nlocal function is(self, kind, sourceOrN, n)\n\tlocal token = peek(self, n);\n\t\n\tlocal source = nil;\n\tif(type(sourceOrN) == \"string\") then\n\t\tsource = sourceOrN;\n\telse\n\t\tn = sourceOrN;\n\tend\n\tn = n or 0;\n\t\n\tif(token.kind == kind) then\n\t\tif(source == nil or token.source == source) then\n\t\t\treturn true;\n\t\tend\n\tend\n\t\n\treturn false;\nend\n\nlocal function consume(self, kind, source)\n\tif(is(self, kind, source)) then\n\t\tself.index = self.index + 1;\n\t\treturn true;\n\tend\n\treturn false;\nend\n\nlocal function expect(self, kind, source)\n\tif(is(self, kind, source, 0)) then\n\t\treturn get(self);\n\tend\n\t\n\tlocal token = peek(self);\n\tif self.disableLog then error() end\n\tif(source) then\n\t\tlogger:error(generateError(self, string.format(\"unexpected token <%s> \\\"%s\\\", expected <%s> \\\"%s\\\"\", token.kind, token.source, kind, source)));\n\telse\n\t\tlogger:error(generateError(self, string.format(\"unexpected token <%s> \\\"%s\\\", expected <%s>\", token.kind, token.source, kind)));\n\tend\nend\n\n-- Parse the given code to an Abstract Syntax Tree\nfunction Parser:parse(code)\n\tself.tokenizer:append(code);\n\tself.tokens = self.tokenizer:scanAll();\n\tself.length = #self.tokens;\n\t\n\t-- Create Global Variable Scope\n\tlocal globalScope = Scope:newGlobal();\n\t\n\tlocal ast = Ast.TopNode(self:block(globalScope, false), globalScope);\n\t-- File Must be Over when Top Node is Fully Parsed\n\texpect(self, TokenKind.Eof);\n\n\tlogger:debug(\"Cleaning up Parser for next Use ...\")\n\t-- Clean Up\n\tself.tokenizer:reset();\n\tself.tokens = {};\n\tself.index = 0;\n\tself.length = 0;\n\t\n\tlogger:debug(\"Cleanup Done\")\n\t\n\treturn ast;\nend\n\n-- Parse a Code Block\nfunction Parser:block(parentScope, currentLoop, scope)\n\tscope = scope or Scope:new(parentScope);\n\tlocal statements = {};\n\t\n\trepeat\n\t\tlocal statement, isTerminatingStatement = self:statement(scope, currentLoop);\n\t\ttable.insert(statements, statement);\n\tuntil isTerminatingStatement or not statement\n\t\n\t-- Consume Eventual Semicolon after terminating return, break or continue\n\tconsume(self, TokenKind.Symbol, \";\");\n\t\n\treturn Ast.Block(statements, scope);\nend\n\nfunction Parser:statement(scope, currentLoop)\n\t-- Skip all semicolons before next real statement\n\t-- NOP statements are therefore ignored\n\twhile(consume(self, TokenKind.Symbol, \";\")) do\n\t\t\n\tend\n\t\n\t-- Break Statement - only valid inside of Loops\n\tif(consume(self, TokenKind.Keyword, \"break\")) then\n\t\tif(not currentLoop) then\n\t\t\tif self.disableLog then error() end;\n\t\t\tlogger:error(generateError(self, \"the break Statement is only valid inside of loops\"));\n\t\tend\n\t\t-- Return true as Second value because break must be the last Statement in a block\n\t\treturn Ast.BreakStatement(currentLoop, scope), true;\n\tend\n\t\n\t-- Continue Statement - only valid inside of Loops - only valid in LuaU\n\tif(self.luaVersion == LuaVersion.LuaU and consume(self, TokenKind.Keyword, \"continue\")) then\n\t\tif(not currentLoop) then\n\t\t\tif self.disableLog then error() end;\n\t\t\tlogger:error(generateError(self, \"the continue Statement is only valid inside of loops\"));\n\t\tend\n\t\t-- Return true as Second value because continue must be the last Statement in a block\n\t\treturn Ast.ContinueStatement(currentLoop, scope), true;\n\tend\n\t\n\t-- do ... end Statement\n\tif(consume(self, TokenKind.Keyword, \"do\")) then\n\t\tlocal body = self:block(scope, currentLoop);\n\t\texpect(self, TokenKind.Keyword, \"end\");\n\t\treturn Ast.DoStatement(body);\n\tend\n\t\n\t-- While Statement\n\tif(consume(self, TokenKind.Keyword, \"while\")) then\n\t\tlocal condition = self:expression(scope);\n\t\texpect(self, TokenKind.Keyword, \"do\");\n\t\tlocal stat = Ast.WhileStatement(nil, condition, scope);\n\t\tstat.body = self:block(scope, stat);\n\t\texpect(self, TokenKind.Keyword, \"end\");\n\t\treturn stat;\n\tend\n\t\n\t-- Repeat Statement\n\tif(consume(self, TokenKind.Keyword, \"repeat\")) then\n\t\tlocal repeatScope = Scope:new(scope);\n\t\tlocal stat = Ast.RepeatStatement(nil, nil, scope);\n\t\tstat.body = self:block(nil, stat, repeatScope);\n\t\texpect(self, TokenKind.Keyword, \"until\");\n\t\tstat.condition = self:expression(repeatScope);\n\t\treturn stat;\n\tend\n\t\n\t-- Return Statement\n\tif(consume(self, TokenKind.Keyword, \"return\")) then\n\t\tlocal args = {};\n\t\tif(not is(self, TokenKind.Keyword, \"end\") and not is(self, TokenKind.Keyword, \"elseif\") and not is(self, TokenKind.Keyword, \"else\") and not is(self, TokenKind.Symbol, \";\") and not is(self, TokenKind.Eof)) then\n\t\t\targs = self:exprList(scope);\n\t\tend\n\t\t-- Return true as Second value because return must be the last Statement in a block\n\t\treturn Ast.ReturnStatement(args), true;\n\tend\n\t\n\t-- If Statement\n\tif(consume(self, TokenKind.Keyword, \"if\")) then\n\t\tlocal condition = self:expression(scope);\n\t\texpect(self, TokenKind.Keyword, \"then\");\n\t\tlocal body = self:block(scope, currentLoop);\n\t\t\n\t\tlocal elseifs = {};\n\t\t-- Elseifs\n\t\twhile(consume(self, TokenKind.Keyword, \"elseif\")) do\n\t\t\tlocal condition = self:expression(scope);\n\t\t\texpect(self, TokenKind.Keyword, \"then\");\n\t\t\tlocal body = self:block(scope, currentLoop);\n\t\t\t\n\t\t\ttable.insert(elseifs, {\n\t\t\t\tcondition = condition,\n\t\t\t\tbody = body,\n\t\t\t});\n\t\tend\n\t\t\n\t\tlocal elsebody = nil;\n\t\t-- Else\n\t\tif(consume(self, TokenKind.Keyword, \"else\")) then\n\t\t\telsebody = self:block(scope, currentLoop);\n\t\tend\n\t\t\n\t\texpect(self, TokenKind.Keyword, \"end\");\n\t\t\n\t\treturn Ast.IfStatement(condition, body, elseifs, elsebody);\n\tend\n\t\n\t-- Function Declaration\n\tif(consume(self, TokenKind.Keyword, \"function\")) then\n\t\t-- TODO: Parse Function Declaration Name\n\t\tlocal obj = self:funcName(scope);\n\t\tlocal baseScope = obj.scope;\n\t\tlocal baseId = obj.id;\n\t\tlocal indices = obj.indices;\n\t\t\n\t\tlocal funcScope = Scope:new(scope);\n\t\t\n\t\texpect(self, TokenKind.Symbol, \"(\");\n\t\tlocal args = self:functionArgList(funcScope);\n\t\texpect(self, TokenKind.Symbol, \")\");\n\t\t\n\t\tif(obj.passSelf) then\n\t\t\tlocal id = funcScope:addVariable(\"self\", obj.token);\n\t\t\ttable.insert(args, 1, Ast.VariableExpression(funcScope, id));\n\t\tend\n\n\t\tlocal body = self:block(nil, false, funcScope);\n\t\texpect(self, TokenKind.Keyword, \"end\");\n\t\t\n\t\treturn Ast.FunctionDeclaration(baseScope, baseId, indices, args, body);\n\tend\n\t\n\t-- Local Function or Variable Declaration\n\tif(consume(self, TokenKind.Keyword, \"local\")) then\n\t\t-- Local Function Declaration\n\t\tif(consume(self, TokenKind.Keyword, \"function\")) then\n\t\t\tlocal ident = expect(self, TokenKind.Ident);\n\t\t\tlocal name = ident.value;\n\t\t\t\n\t\t\tlocal id = scope:addVariable(name, ident);\n\t\t\tlocal funcScope = Scope:new(scope);\n\t\t\t\n\t\t\texpect(self, TokenKind.Symbol, \"(\");\n\t\t\tlocal args = self:functionArgList(funcScope);\n\t\t\texpect(self, TokenKind.Symbol, \")\");\n\n\t\t\tlocal body = self:block(nil, false, funcScope);\n\t\t\texpect(self, TokenKind.Keyword, \"end\");\n\n\t\t\treturn Ast.LocalFunctionDeclaration(scope, id, args, body);\n\t\tend\n\t\t\n\t\t-- Local Variable Declaration\n\t\tlocal ids = self:nameList(scope);\n\t\tlocal expressions = {};\n\t\tif(consume(self, TokenKind.Symbol, \"=\")) then\n\t\t\texpressions = self:exprList(scope);\n\t\tend\n\n\t\t-- Variables can only be reffered to in the next statement, so the id's are enabled after the expressions have been parsed\n\t\tself:enableNameList(scope, ids);\n\t\t\n\t\tif(#expressions > #ids) then\n\t\t\tlogger:warn(generateWarning(peek(self, -1), string.format(\"assigning %d values to %d variable\" .. ((#ids > 1 and \"s\") or \"\"), #expressions, #ids)));\n\t\telseif(#ids > #expressions and #expressions > 0 and not ASSIGNMENT_NO_WARN_LOOKUP[expressions[#expressions].kind]) then\n\t\t\tlogger:warn(generateWarning(peek(self, -1), string.format(\"assigning %d value\" .. ((#expressions > 1 and \"s\") or \"\") .. \n\t\t\t\t\" to %d variables initializes extra variables with nil, add a nil value to silence\", #expressions, #ids)));\n\t\tend\t\t\n\t\treturn Ast.LocalVariableDeclaration(scope, ids, expressions);\n\tend\n\t\n\t-- For Statement\n\tif(consume(self, TokenKind.Keyword, \"for\")) then\n\t\t-- Normal for Statement\n\t\tif(is(self, TokenKind.Symbol, \"=\", 1)) then\n\t\t\tlocal forScope = Scope:new(scope);\n\t\t\t\n\t\t\tlocal ident = expect(self, TokenKind.Ident);\n\t\t\tlocal varId = forScope:addDisabledVariable(ident.value, ident);\n\t\t\t\n\t\t\texpect(self, TokenKind.Symbol, \"=\");\n\t\t\tlocal initialValue = self:expression(scope);\n\t\t\t\n\t\t\texpect(self, TokenKind.Symbol, \",\");\n\t\t\tlocal finalValue = self:expression(scope);\n\t\t\tlocal incrementBy = Ast.NumberExpression(1);\n\t\t\tif(consume(self, TokenKind.Symbol, \",\")) then\n\t\t\t\tincrementBy = self:expression(scope);\n\t\t\tend\n\t\t\t\n\t\t\tlocal stat = Ast.ForStatement(forScope, varId, initialValue, finalValue, incrementBy, nil, scope);\n\t\t\tforScope:enableVariable(varId);\n\t\t\texpect(self, TokenKind.Keyword, \"do\");\n\t\t\tstat.body = self:block(nil, stat, forScope);\n\t\t\texpect(self, TokenKind.Keyword, \"end\");\n\t\t\treturn stat;\n\t\tend\n\t\t\n\t\t-- For ... in ... statement\n\t\tlocal forScope = Scope:new(scope);\n\t\t\n\t\tlocal ids = self:nameList(forScope);\n\t\texpect(self, TokenKind.Keyword, \"in\");\n\t\tlocal expressions = self:exprList(scope);\n\t\t-- Enable Ids after Expression Parsing so that code like this works:\n\t\t--\tlocal z = {10,20}\n\t\t--\tfor y,z in ipairs(z) do\n\t\t--\t\tprint(y, z);\n\t\t-- \tend\n\t\tself:enableNameList(forScope, ids);\n\t\texpect(self, TokenKind.Keyword, \"do\");\n\t\tlocal stat = Ast.ForInStatement(forScope, ids, expressions, nil, scope);\n\t\tstat.body = self:block(nil, stat, forScope);\n\t\texpect(self, TokenKind.Keyword, \"end\");\n\t\t\n\t\treturn stat;\n\tend\n\t\n\tlocal expr = self:primaryExpression(scope);\n\t-- Variable Assignment or Function Call\n\tif expr then\n\t\t-- Function Call Statement\n\t\tif(expr.kind == AstKind.FunctionCallExpression) then\n\t\t\treturn Ast.FunctionCallStatement(expr.base, expr.args);\n\t\tend\n\t\t\n\t\t-- Function Call Statement passing self\n\t\tif(expr.kind == AstKind.PassSelfFunctionCallExpression) then\n\t\t\treturn Ast.PassSelfFunctionCallStatement(expr.base, expr.passSelfFunctionName, expr.args);\n\t\tend\n\t\t\n\t\t-- Variable Assignment\n\t\tif(expr.kind == AstKind.IndexExpression or expr.kind == AstKind.VariableExpression) then\n\t\t\tif(expr.kind == AstKind.IndexExpression) then\n\t\t\t\texpr.kind = AstKind.AssignmentIndexing\n\t\t\tend\n\t\t\tif(expr.kind == AstKind.VariableExpression) then\n\t\t\t\texpr.kind = AstKind.AssignmentVariable\n\t\t\tend\n\n\t\t\tif(self.luaVersion == LuaVersion.LuaU) then\n\t\t\t\t-- LuaU Compound Assignment\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"+=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundAddStatement(expr, rhs);\n\t\t\t\tend\n\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"-=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundSubStatement(expr, rhs);\n\t\t\t\tend\n\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"*=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundMulStatement(expr, rhs);\n\t\t\t\tend\n\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"/=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundDivStatement(expr, rhs);\n\t\t\t\tend\n\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"%=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundModStatement(expr, rhs);\n\t\t\t\tend\n\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"^=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundPowStatement(expr, rhs);\n\t\t\t\tend\n\n\t\t\t\tif(consume(self, TokenKind.Symbol, \"..=\")) then\n\t\t\t\t\tlocal rhs = self:expression(scope);\n\t\t\t\t\treturn Ast.CompoundConcatStatement(expr, rhs);\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal lhs = {\n\t\t\t\texpr\n\t\t\t}\n\t\t\t\n\t\t\twhile consume(self, TokenKind.Symbol, \",\") do\n\t\t\t\texpr = self:primaryExpression(scope);\n\t\t\t\t\n\t\t\t\tif(not expr) then\n\t\t\t\t\tif self.disableLog then error() end;\n\t\t\t\t\tlogger:error(generateError(self, string.format(\"expected a valid assignment statement lhs part but got nil\")));\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif(expr.kind == AstKind.IndexExpression or expr.kind == AstKind.VariableExpression) then\n\t\t\t\t\tif(expr.kind == AstKind.IndexExpression) then\n\t\t\t\t\t\texpr.kind = AstKind.AssignmentIndexing\n\t\t\t\t\tend\n\t\t\t\t\tif(expr.kind == AstKind.VariableExpression) then\n\t\t\t\t\t\texpr.kind = AstKind.AssignmentVariable\n\t\t\t\t\tend\n\t\t\t\t\ttable.insert(lhs, expr);\n\t\t\t\telse\n\t\t\t\t\tif self.disableLog then error() end;\n\t\t\t\t\tlogger:error(generateError(self, string.format(\"expected a valid assignment statement lhs part but got <%s>\", expr.kind)));\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\texpect(self, TokenKind.Symbol, \"=\");\n\t\t\t\n\t\t\tlocal rhs = self:exprList(scope);\n\t\t\t\n\t\t\treturn Ast.AssignmentStatement(lhs, rhs);\n\t\tend\n\t\t\n\t\tif self.disableLog then error() end;\n\t\tlogger:error(generateError(self, \"expressions are not valid statements!\"));\n\tend\n\t\n\treturn nil;\nend\n\nfunction Parser:primaryExpression(scope)\n\tlocal i = self.index;\n\tlocal s = self;\n\tself.disableLog = true;\n\tlocal status, val = pcall(self.expressionFunctionCall, self, scope);\n\tself.disableLog = false;\n\tif(status) then\n\t\treturn val;\n\telse\n\t\tself.index = i;\n\t\treturn nil;\n\tend\nend\n\n-- List of expressions Seperated by a comma\nfunction Parser:exprList(scope)\n\tlocal expressions = {\n\t\tself:expression(scope)\n\t};\n\twhile(consume(self, TokenKind.Symbol, \",\")) do\n\t\ttable.insert(expressions, self:expression(scope));\n\tend\n\treturn expressions;\nend\n\n-- list of local variable names\nfunction Parser:nameList(scope)\n\tlocal ids = {};\n\t\n\tlocal ident = expect(self, TokenKind.Ident);\n\tlocal id = scope:addDisabledVariable(ident.value, ident);\n\ttable.insert(ids, id);\n\t\n\twhile(consume(self, TokenKind.Symbol, \",\")) do\n\t\tident = expect(self, TokenKind.Ident);\n\t\tid = scope:addDisabledVariable(ident.value, ident);\n\t\ttable.insert(ids, id);\n\tend\n\t\n\treturn ids;\nend\n\nfunction Parser:enableNameList(scope, list)\n\tfor i, id in ipairs(list) do\n\t\tscope:enableVariable(id);\n\tend\nend\n\n\n-- function name\nfunction Parser:funcName(scope)\n\tlocal ident = expect(self, TokenKind.Ident);\n\tlocal baseName = ident.value;\n\t\n\tlocal baseScope, baseId = scope:resolve(baseName);\n\t\n\tlocal indices = {};\n\tlocal passSelf = false;\n\twhile(consume(self, TokenKind.Symbol, \".\")) do\n\t\ttable.insert(indices, expect(self, TokenKind.Ident).value);\n\tend\n\t\n\tif(consume(self, TokenKind.Symbol, \":\")) then\n\t\ttable.insert(indices, expect(self, TokenKind.Ident).value);\n\t\tpassSelf = true;\n\tend\n\t\n\treturn {\n\t\tscope = baseScope,\n\t\tid = baseId,\n\t\tindices = indices,\n\t\tpassSelf = passSelf,\n\t\ttoken = ident,\n\t};\nend\n\n-- Expression\nfunction Parser:expression(scope)\n\treturn self:expressionOr(scope);\nend\n\nfunction Parser:expressionOr(scope)\n\tlocal lhs = self:expressionAnd(scope);\n\t\n\tif(consume(self, TokenKind.Keyword, \"or\")) then\n\t\tlocal rhs = self:expressionOr(scope);\n\t\treturn Ast.OrExpression(lhs, rhs, true);\n\tend\n\t\n\treturn lhs;\nend\n\nfunction Parser:expressionAnd(scope)\n\tlocal lhs = self:expressionComparision(scope);\n\n\tif(consume(self, TokenKind.Keyword, \"and\")) then\n\t\tlocal rhs = self:expressionAnd(scope);\n\t\treturn Ast.AndExpression(lhs, rhs, true);\n\tend\n\n\treturn lhs;\nend\n\nfunction Parser:expressionComparision(scope)\n\tlocal curr = self:expressionStrCat(scope);\n\trepeat\n\t\tlocal found = false;\n\t\tif(consume(self, TokenKind.Symbol, \"<\")) then\n\t\t\tlocal rhs = self:expressionStrCat(scope);\n\t\t\tcurr = Ast.LessThanExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\t\n\t\tif(consume(self, TokenKind.Symbol, \">\")) then\n\t\t\tlocal rhs = self:expressionStrCat(scope);\n\t\t\tcurr = Ast.GreaterThanExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\t\n\t\tif(consume(self, TokenKind.Symbol, \"<=\")) then\n\t\t\tlocal rhs = self:expressionStrCat(scope);\n\t\t\tcurr = Ast.LessThanOrEqualsExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\n\t\tif(consume(self, TokenKind.Symbol, \">=\")) then\n\t\t\tlocal rhs = self:expressionStrCat(scope);\n\t\t\tcurr = Ast.GreaterThanOrEqualsExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\t\n\t\tif(consume(self, TokenKind.Symbol, \"~=\")) then\n\t\t\tlocal rhs = self:expressionStrCat(scope);\n\t\t\tcurr = Ast.NotEqualsExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\n\t\tif(consume(self, TokenKind.Symbol, \"==\")) then\n\t\t\tlocal rhs = self:expressionStrCat(scope);\n\t\t\tcurr = Ast.EqualsExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\tuntil not found;\n\n\treturn curr;\nend\n\nfunction Parser:expressionStrCat(scope)\n\tlocal lhs = self:expressionAddSub(scope);\n\n\tif(consume(self, TokenKind.Symbol, \"..\")) then\n\t\tlocal rhs = self:expressionStrCat(scope);\n\t\treturn Ast.StrCatExpression(lhs, rhs, true);\n\tend\n\n\treturn lhs;\nend\n\nfunction Parser:expressionAddSub(scope)\n\tlocal curr = self:expressionMulDivMod(scope);\n\n\trepeat\n\t\tlocal found = false;\n\t\tif(consume(self, TokenKind.Symbol, \"+\")) then\n\t\t\tlocal rhs = self:expressionMulDivMod(scope);\n\t\t\tcurr = Ast.AddExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\t\n\t\tif(consume(self, TokenKind.Symbol, \"-\")) then\n\t\t\tlocal rhs = self:expressionMulDivMod(scope);\n\t\t\tcurr = Ast.SubExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\tuntil not found;\n\t\n\n\treturn curr;\nend\n\nfunction Parser:expressionMulDivMod(scope)\n\tlocal curr = self:expressionUnary(scope);\n\n\trepeat\n\t\tlocal found = false;\n\t\tif(consume(self, TokenKind.Symbol, \"*\")) then\n\t\t\tlocal rhs = self:expressionUnary(scope);\n\t\t\tcurr = Ast.MulExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\t\n\t\tif(consume(self, TokenKind.Symbol, \"/\")) then\n\t\t\tlocal rhs = self:expressionUnary(scope);\n\t\t\tcurr = Ast.DivExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\n\t\tif(consume(self, TokenKind.Symbol, \"%\")) then\n\t\t\tlocal rhs = self:expressionUnary(scope);\n\t\t\tcurr = Ast.ModExpression(curr, rhs, true);\n\t\t\tfound = true;\n\t\tend\n\tuntil not found;\n\n\treturn curr;\nend\n\nfunction Parser:expressionUnary(scope)\n\tif(consume(self, TokenKind.Keyword, \"not\")) then\n\t\tlocal rhs = self:expressionUnary(scope);\n\t\treturn Ast.NotExpression(rhs, true);\n\tend\n\t\n\tif(consume(self, TokenKind.Symbol, \"#\")) then\n\t\tlocal rhs = self:expressionUnary(scope);\n\t\treturn Ast.LenExpression(rhs, true);\n\tend\n\t\n\tif(consume(self, TokenKind.Symbol, \"-\")) then\n\t\tlocal rhs = self:expressionUnary(scope);\n\t\treturn Ast.NegateExpression(rhs, true);\n\tend\n\n\treturn self:expressionPow(scope);\nend\n\nfunction Parser:expressionPow(scope)\n\tlocal lhs = self:tableOrFunctionLiteral(scope);\n\n\tif(consume(self, TokenKind.Symbol, \"^\")) then\n\t\tlocal rhs = self:expressionPow(scope);\n\t\treturn Ast.PowExpression(lhs, rhs, true);\n\tend\n\n\treturn lhs;\nend\n\n-- Table Literals and Function Literals cannot directly be called or indexed\nfunction Parser:tableOrFunctionLiteral(scope)\n\t\n\tif(is(self, TokenKind.Symbol, \"{\")) then\n\t\treturn self:tableConstructor(scope);\n\tend\n\t\n\tif(is(self, TokenKind.Keyword, \"function\")) then\n\t\treturn self:expressionFunctionLiteral(scope);\n\tend\n\t\n\treturn self:expressionFunctionCall(scope);\nend\n\nfunction Parser:expressionFunctionLiteral(parentScope)\n\tlocal scope = Scope:new(parentScope);\n\t\n\texpect(self, TokenKind.Keyword, \"function\");\n\t\n\texpect(self, TokenKind.Symbol, \"(\");\n\tlocal args = self:functionArgList(scope);\n\texpect(self, TokenKind.Symbol, \")\");\n\t\n\tlocal body = self:block(nil, false, scope);\n\texpect(self, TokenKind.Keyword, \"end\");\n\t\n\treturn Ast.FunctionLiteralExpression(args, body);\nend\n\nfunction Parser:functionArgList(scope)\n\tlocal args = {};\n\tif(consume(self, TokenKind.Symbol, \"...\")) then\n\t\ttable.insert(args, Ast.VarargExpression());\n\t\treturn args;\n\tend\n\t\n\tif(is(self, TokenKind.Ident)) then\n\t\tlocal ident = get(self);\n\t\tlocal name = ident.value;\n\t\t\n\t\tlocal id = scope:addVariable(name, ident);\n\t\ttable.insert(args, Ast.VariableExpression(scope, id));\n\t\t\n\t\twhile(consume(self, TokenKind.Symbol, \",\")) do\n\t\t\tif(consume(self, TokenKind.Symbol, \"...\")) then\n\t\t\t\ttable.insert(args, Ast.VarargExpression());\n\t\t\t\treturn args;\n\t\t\tend\n\t\t\t\n\t\t\tident = get(self);\n\t\t\tname = ident.value;\n\n\t\t\tid = scope:addVariable(name, ident);\n\t\t\ttable.insert(args, Ast.VariableExpression(scope, id));\n\t\tend\n\tend\n\t\n\treturn args;\nend\n\nfunction Parser:expressionFunctionCall(scope, base)\n\tbase = base or self:expressionIndex(scope);\n\t\n\t-- Normal Function Call\n\tlocal args = {};\n\tif(is(self, TokenKind.String)) then\n\t\targs = {\n\t\t\tAst.StringExpression(get(self).value),\n\t\t};\n\telseif(is(self, TokenKind.Symbol, \"{\")) then\n\t\targs = {\n\t\t\tself:tableConstructor(scope),\n\t\t};\n\telseif(consume(self, TokenKind.Symbol, \"(\")) then\n\t\tif(not is(self, TokenKind.Symbol, \")\")) then\n\t\t\targs = self:exprList(scope);\n\t\tend\n\t\texpect(self, TokenKind.Symbol, \")\");\n\telse\n\t\treturn base;\n\tend\n\t\n\tlocal node = Ast.FunctionCallExpression(base, args);\n\t\n\t-- the result of a function call can be indexed\n\tif(is(self, TokenKind.Symbol, \".\") or is(self, TokenKind.Symbol, \"[\") or is(self, TokenKind.Symbol, \":\")) then\n\t\treturn self:expressionIndex(scope, node);\n\tend\n\n\t-- The result of a function call can be a function that is again called\n\tif(is(self, TokenKind.Symbol, \"(\") or is(self, TokenKind.Symbol, \"{\") or is(self, TokenKind.String)) then\n\t\treturn self:expressionFunctionCall(scope, node);\n\tend\n\t\n\treturn node;\nend\n\nfunction Parser:expressionIndex(scope, base)\n\tbase = base or self:expressionLiteral(scope);\n\t\n\t-- Parse Indexing Expressions\n\twhile(consume(self, TokenKind.Symbol, \"[\")) do\n\t\tlocal expr = self:expression(scope);\n\t\texpect(self, TokenKind.Symbol, \"]\");\n\t\tbase = Ast.IndexExpression(base, expr);\n\tend\n\t\n\t-- Parse Indexing Expressions\n\twhile consume(self, TokenKind.Symbol, \".\") do\n\t\tlocal ident = expect(self, TokenKind.Ident);\n\t\tbase = Ast.IndexExpression(base, Ast.StringExpression(ident.value));\n\t\t\n\t\twhile(consume(self, TokenKind.Symbol, \"[\")) do\n\t\t\tlocal expr = self:expression(scope);\n\t\t\texpect(self, TokenKind.Symbol, \"]\");\n\t\t\tbase = Ast.IndexExpression(base, expr);\n\t\tend\n\tend\n\n\t-- Function Passing self\n\tif(consume(self, TokenKind.Symbol, \":\")) then\n\t\tlocal passSelfFunctionName = expect(self, TokenKind.Ident).value;\n\t\tlocal args = {};\n\t\tif(is(self, TokenKind.String)) then\n\t\t\targs = {\n\t\t\t\tAst.StringExpression(get(self).value),\n\t\t\t};\n\t\telseif(is(self, TokenKind.Symbol, \"{\")) then\n\t\t\targs = {\n\t\t\t\tself:tableConstructor(scope),\n\t\t\t};\n\t\telse\n\t\t\texpect(self, TokenKind.Symbol, \"(\");\n\t\t\tif(not is(self, TokenKind.Symbol, \")\")) then\n\t\t\t\targs = self:exprList(scope);\n\t\t\tend\n\t\t\texpect(self, TokenKind.Symbol, \")\");\n\t\tend\n\t\t\n\t\tlocal node = Ast.PassSelfFunctionCallExpression(base, passSelfFunctionName, args);\n\n\t\t-- the result of a function call can be indexed\n\t\tif(is(self, TokenKind.Symbol, \".\") or is(self, TokenKind.Symbol, \"[\") or is(self, TokenKind.Symbol, \":\")) then\n\t\t\treturn self:expressionIndex(scope, node);\n\t\tend\n\n\t\t-- The result of a function call can be a function that is again called\n\t\tif(is(self, TokenKind.Symbol, \"(\") or is(self, TokenKind.Symbol, \"{\") or is(self, TokenKind.String)) then\n\t\t\treturn self:expressionFunctionCall(scope, node);\n\t\tend\n\t\t\n\t\treturn node\n\tend\n\n\t-- The result of a function call can be a function that is again called\n\tif(is(self, TokenKind.Symbol, \"(\") or is(self, TokenKind.Symbol, \"{\") or is(self, TokenKind.String)) then\n\t\treturn self:expressionFunctionCall(scope, base);\n\tend\n\t\n\treturn base;\nend\n\nfunction Parser:expressionLiteral(scope)\n\t-- () expression\n\tif(consume(self, TokenKind.Symbol, \"(\")) then\n\t\tlocal expr = self:expression(scope);\n\t\texpect(self, TokenKind.Symbol, \")\");\n\t\treturn expr;\n\tend\n\t\n\t-- String Literal\n\tif(is(self, TokenKind.String)) then\n\t\treturn Ast.StringExpression(get(self).value);\n\tend\n\t\n\t-- Number Literal\n\tif(is(self, TokenKind.Number)) then\n\t\treturn Ast.NumberExpression(get(self).value);\n\tend\n\t\n\t-- True Literal\n\tif(consume(self, TokenKind.Keyword, \"true\")) then\n\t\treturn Ast.BooleanExpression(true);\n\tend\n\t\n\t-- False Literal\n\tif(consume(self, TokenKind.Keyword, \"false\")) then\n\t\treturn Ast.BooleanExpression(false);\n\tend\n\t\n\t-- Nil Literal\n\tif(consume(self, TokenKind.Keyword, \"nil\")) then\n\t\treturn Ast.NilExpression();\n\tend\n\t\n\t-- Vararg Literal\n\tif(consume(self, TokenKind.Symbol, \"...\")) then\n\t\treturn Ast.VarargExpression();\n\tend\n\t\n\t-- Variable\n\tif(is(self, TokenKind.Ident)) then\n\t\tlocal ident = get(self);\n\t\tlocal name = ident.value;\n\t\t\n\t\tlocal scope, id = scope:resolve(name);\n\t\treturn Ast.VariableExpression(scope, id);\n\tend\n\n\t-- IfElse\n\tif(LuaVersion.LuaU) then\n\t\tif(consume(self, TokenKind.Keyword, \"if\")) then\n\t\t\tlocal condition = self:expression(scope);\n\t\t\texpect(self, TokenKind.Keyword, \"then\");\n\t\t\tlocal true_value = self:expression(scope);\n\t\t\texpect(self, TokenKind.Keyword, \"else\");\n\t\t\tlocal false_value = self:expression(scope);\n\n\t\t\treturn Ast.IfElseExpression(condition, true_value, false_value);\n\t\tend\n\tend\n\t\n\tif(self.disableLog) then error() end\n\tlogger:error(generateError(self, \"Unexpected Token \\\"\" .. peek(self).source .. \"\\\". Expected a Expression!\"))\nend\n\nfunction Parser:tableConstructor(scope)\n\t-- TODO: Parse Table Literals\n\tlocal entries = {};\n\t\n\texpect(self, TokenKind.Symbol, \"{\");\n\t\n\twhile (not consume(self, TokenKind.Symbol, \"}\")) do\n\t\tif(consume(self, TokenKind.Symbol, \"[\")) then\n\t\t\tlocal key = self:expression(scope);\n\t\t\texpect(self, TokenKind.Symbol, \"]\");\n\t\t\texpect(self, TokenKind.Symbol, \"=\");\n\t\t\tlocal value = self:expression(scope);\n\t\t\ttable.insert(entries, Ast.KeyedTableEntry(key, value));\n\t\telseif(is(self, TokenKind.Ident, 0) and is(self, TokenKind.Symbol, \"=\", 1)) then\n\t\t\tlocal key = Ast.StringExpression(get(self).value);\n\t\t\texpect(self, TokenKind.Symbol, \"=\");\n\t\t\tlocal value = self:expression(scope);\n\t\t\ttable.insert(entries, Ast.KeyedTableEntry(key, value));\n\t\telse\n\t\t\tlocal value = self:expression(scope);\n\t\t\ttable.insert(entries, Ast.TableEntry(value));\n\t\tend\n\t\t\n\t\t\n\t\tif (not consume(self, TokenKind.Symbol, \";\") and not consume(self, TokenKind.Symbol, \",\") and not is(self, TokenKind.Symbol, \"}\")) then\n\t\t\tif self.disableLog then error() end\n\t\t\tlogger:error(generateError(self, \"expected a \\\";\\\" or a \\\",\\\"\"));\n\t\tend\n\tend\n\t\n\treturn Ast.TableConstructorExpression(entries);\nend\n\nreturn Parser\n",
  "prometheus.pipeline": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- pipeline.lua\n--\n-- This Script Provides a Configurable Obfuscation Pipeline that can obfuscate code using different Modules\n-- These Modules can simply be added to the pipeline\n\nlocal config = require(\"config\");\nlocal Ast    = require(\"prometheus.ast\");\nlocal Enums  = require(\"prometheus.enums\");\nlocal util = require(\"prometheus.util\");\nlocal Parser = require(\"prometheus.parser\");\nlocal Unparser = require(\"prometheus.unparser\");\nlocal logger = require(\"logger\");\n\nlocal NameGenerators = require(\"prometheus.namegenerators\");\n\nlocal Steps = require(\"prometheus.steps\");\n\nlocal lookupify = util.lookupify;\nlocal LuaVersion = Enums.LuaVersion;\nlocal AstKind = Ast.AstKind;\n\n-- On Windows os.clock can be used. On other Systems os.time must be used for benchmarking\nlocal isWindows = package and package.config and type(package.config) == \"string\" and package.config:sub(1,1) == \"\\\\\";\nlocal function gettime()\n\tif isWindows then\n\t\treturn os.clock();\n\telse\n\t\treturn os.time();\n\tend\nend\n\nlocal Pipeline = {\n\tNameGenerators = NameGenerators;\n\tSteps = Steps;\n\tDefaultSettings = {\n\t\tLuaVersion = LuaVersion.LuaU; -- The Lua Version to use for the Tokenizer, Parser and Unparser\n\t\tPrettyPrint = false; -- Note that Pretty Print is currently not producing Pretty results\n\t\tSeed = 0; -- The Seed. 0 or below uses the current time as a seed\n\t\tVarNamePrefix = \"\"; -- The Prefix that every variable will start with\n\t}\n}\n\n\nfunction Pipeline:new(settings)\n\tlocal luaVersion = settings.luaVersion or settings.LuaVersion or Pipeline.DefaultSettings.LuaVersion;\n\tlocal conventions = Enums.Conventions[luaVersion];\n\tif(not conventions) then\n\t\tlogger:error(\"The Lua Version \\\"\" .. luaVersion \n\t\t\t.. \"\\\" is not recognised by the Tokenizer! Please use one of the following: \\\"\" .. table.concat(util.keys(Enums.Conventions), \"\\\",\\\"\") .. \"\\\"\");\n\tend\n\t\n\tlocal prettyPrint = settings.PrettyPrint or Pipeline.DefaultSettings.PrettyPrint;\n\tlocal prefix = settings.VarNamePrefix or Pipeline.DefaultSettings.VarNamePrefix;\n\tlocal seed = settings.Seed or 0;\n\t\n\tlocal pipeline = {\n\t\tLuaVersion = luaVersion;\n\t\tPrettyPrint = prettyPrint;\n\t\tVarNamePrefix = prefix;\n\t\tSeed = seed;\n\t\tparser = Parser:new({\n\t\t\tLuaVersion = luaVersion;\n\t\t});\n\t\tunparser = Unparser:new({\n\t\t\tLuaVersion = luaVersion;\n\t\t\tPrettyPrint = prettyPrint;\n\t\t\tHighlight = settings.Highlight;\n\t\t});\n\t\tnamegenerator = Pipeline.NameGenerators.MangledShuffled;\n\t\tconventions = conventions;\n\t\tsteps = {};\n\t}\n\t\n\tsetmetatable(pipeline, self);\n\tself.__index = self;\n\t\n\treturn pipeline;\nend\n\nfunction Pipeline:fromConfig(config)\n\tconfig = config or {};\n\tlocal pipeline = Pipeline:new({\n\t\tLuaVersion    = config.LuaVersion or LuaVersion.Lua51;\n\t\tPrettyPrint   = config.PrettyPrint or false;\n\t\tVarNamePrefix = config.VarNamePrefix or \"\";\n\t\tSeed          = config.Seed or 0;\n\t});\n\n\tpipeline:setNameGenerator(config.NameGenerator or \"MangledShuffled\")\n\n\t-- Add all Steps defined in Config\n\tlocal steps = config.Steps or {};\n\tfor i, step in ipairs(steps) do\n\t\tif type(step.Name) ~= \"string\" then\n\t\t\tlogger:error(\"Step.Name must be a String\");\n\t\tend\n\t\tlocal constructor = pipeline.Steps[step.Name];\n\t\tif not constructor then\n\t\t\tlogger:error(string.format(\"The Step \\\"%s\\\" was not found!\", step.Name));\n\t\tend\n\t\tpipeline:addStep(constructor:new(step.Settings or {}));\n\tend\n\n\treturn pipeline;\nend\n\nfunction Pipeline:addStep(step)\n\ttable.insert(self.steps, step);\nend\n\nfunction Pipeline:resetSteps(step)\n\tself.steps = {};\nend\n\nfunction Pipeline:getSteps()\n\treturn self.steps;\nend\n\nfunction Pipeline:setOption(name, value)\n\tassert(false, \"TODO\");\n\tif(Pipeline.DefaultSettings[name] ~= nil) then\n\t\t\n\telse\n\t\tlogger:error(string.format(\"\\\"%s\\\" is not a valid setting\"));\n\tend\nend\n\nfunction Pipeline:setLuaVersion(luaVersion)\n\tlocal conventions = Enums.Conventions[luaVersion];\n\tif(not conventions) then\n\t\tlogger:error(\"The Lua Version \\\"\" .. luaVersion \n\t\t\t.. \"\\\" is not recognised by the Tokenizer! Please use one of the following: \\\"\" .. table.concat(util.keys(Enums.Conventions), \"\\\",\\\"\") .. \"\\\"\");\n\tend\n\t\n\tself.parser = Parser:new({\n\t\tluaVersion = luaVersion;\n\t});\n\tself.unparser = Unparser:new({\n\t\tluaVersion = luaVersion;\n\t});\n\tself.conventions = conventions;\nend\n\nfunction Pipeline:getLuaVersion()\n\treturn self.luaVersion;\nend\n\nfunction Pipeline:setNameGenerator(nameGenerator)\n\tif(type(nameGenerator) == \"string\") then\n\t\tnameGenerator = Pipeline.NameGenerators[nameGenerator];\n\tend\n\t\n\tif(type(nameGenerator) == \"function\" or type(nameGenerator) == \"table\") then\n\t\tself.namegenerator = nameGenerator;\n\t\treturn;\n\telse\n\t\tlogger:error(\"The Argument to Pipeline:setNameGenerator must be a valid NameGenerator function or function name e.g: \\\"mangled\\\"\")\n\tend\nend\n\nfunction Pipeline:apply(code, filename)\n\tlocal startTime = gettime();\n\tfilename = filename or \"Anonymus Script\";\n\tlogger:info(string.format(\"Applying Obfuscation Pipeline to %s ...\", filename));\n\t-- Seed the Random Generator\n\tif(self.Seed > 0) then\n\t\tmath.randomseed(self.Seed);\n\telse\n\t\tmath.randomseed(os.time())\n\tend\n\t\n\tlogger:info(\"Parsing ...\");\n\tlocal parserStartTime = gettime();\n\n\tlocal sourceLen = string.len(code);\n\tlocal ast = self.parser:parse(code);\n\n\tlocal parserTimeDiff = gettime() - parserStartTime;\n\tlogger:info(string.format(\"Parsing Done in %.2f seconds\", parserTimeDiff));\n\t\n\t-- User Defined Steps\n\tfor i, step in ipairs(self.steps) do\n\t\tlocal stepStartTime = gettime();\n\t\tlogger:info(string.format(\"Applying Step \\\"%s\\\" ...\", step.Name or \"Unnamed\"));\n\t\tlocal newAst = step:apply(ast, self);\n\t\tif type(newAst) == \"table\" then\n\t\t\tast = newAst;\n\t\tend\n\t\tlogger:info(string.format(\"Step \\\"%s\\\" Done in %.2f seconds\", step.Name or \"Unnamed\", gettime() - stepStartTime));\n\tend\n\t\n\t-- Rename Variables Step\n\tself:renameVariables(ast);\n\t\n\tcode = self:unparse(ast);\n\t\n\tlocal timeDiff = gettime() - startTime;\n\tlogger:info(string.format(\"Obfuscation Done in %.2f seconds\", timeDiff));\n\t\n\tlogger:info(string.format(\"Generated Code size is %.2f%% of the Source Code size\", (string.len(code) / sourceLen)*100))\n\t\n\treturn code;\nend\n\nfunction Pipeline:unparse(ast)\n\tlocal startTime = gettime();\n\tlogger:info(\"Generating Code ...\");\n\t\n\tlocal unparsed = self.unparser:unparse(ast);\n\t\n\tlocal timeDiff = gettime() - startTime;\n\tlogger:info(string.format(\"Code Generation Done in %.2f seconds\", timeDiff));\n\t\n\treturn unparsed;\nend\n\nfunction Pipeline:renameVariables(ast)\n\tlocal startTime = gettime();\n\tlogger:info(\"Renaming Variables ...\");\n\t\n\t\n\tlocal generatorFunction = self.namegenerator or Pipeline.NameGenerators.mangled;\n\tif(type(generatorFunction) == \"table\") then\n\t\tif (type(generatorFunction.prepare) == \"function\") then\n\t\t\tgeneratorFunction.prepare(ast);\n\t\tend\n\t\tgeneratorFunction = generatorFunction.generateName;\n\tend\n\t\n\tif not self.unparser:isValidIdentifier(self.VarNamePrefix) and #self.VarNamePrefix ~= 0 then\n\t\tlogger:error(string.format(\"The Prefix \\\"%s\\\" is not a valid Identifier in %s\", self.VarNamePrefix, self.LuaVersion));\n\tend\n\n\tlocal globalScope = ast.globalScope;\n\tglobalScope:renameVariables({\n\t\tKeywords = self.conventions.Keywords;\n\t\tgenerateName = generatorFunction;\n\t\tprefix = self.VarNamePrefix;\n\t});\n\t\n\tlocal timeDiff = gettime() - startTime;\n\tlogger:info(string.format(\"Renaming Done in %.2f seconds\", timeDiff));\nend\n\n\n\n\nreturn Pipeline;\n",
  "prometheus.randomLiterals": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- Library for Creating Random Literals\n\nlocal Ast = require(\"prometheus.ast\");\nlocal RandomStrings = require(\"prometheus.randomStrings\");\n\nlocal RandomLiterals = {};\n\nlocal function callNameGenerator(generatorFunction, ...)\n\tif(type(generatorFunction) == \"table\") then\n\t\tgeneratorFunction = generatorFunction.generateName;\n\tend\n\treturn generatorFunction(...);\nend\n\nfunction RandomLiterals.String(pipeline)\n    return Ast.StringExpression(callNameGenerator(pipeline.namegenerator, math.random(1, 4096)));\nend\n\nfunction RandomLiterals.Dictionary()\n    return RandomStrings.randomStringNode(true);\nend\n\nfunction RandomLiterals.Number()\n    return Ast.NumberExpression(math.random(-8388608, 8388607));\nend\n\nfunction RandomLiterals.Any(pipeline)\n    local type = math.random(1, 3);\n    if type == 1 then\n        return RandomLiterals.String(pipeline);\n    elseif type == 2 then\n        return RandomLiterals.Number();\n    elseif type == 3 then\n        return RandomLiterals.Dictionary();\n    end\nend\n\n\nreturn RandomLiterals;",
  "prometheus.randomStrings": "local Ast = require(\"prometheus.ast\")\nlocal utils = require(\"prometheus.util\")\nlocal charset = utils.chararray(\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\")\n\nlocal function randomString(wordsOrLen)\n\tif type(wordsOrLen) == \"table\" then\n\t\treturn wordsOrLen[math.random(1, #wordsOrLen)];\n\tend\n\n\twordsOrLen = wordsOrLen or math.random(2, 15);\n\tif wordsOrLen > 0 then\n\t\treturn randomString(wordsOrLen - 1) .. charset[math.random(1, #charset)]\n\telse\n\t\treturn \"\"\n\tend\nend\n\nlocal function randomStringNode(wordsOrLen)\n\treturn Ast.StringExpression(randomString(wordsOrLen))\nend\n\nreturn {\n\trandomString = randomString,\n\trandomStringNode = randomStringNode,\n}\n",
  "prometheus.scope": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- scope.lua\n\nlocal logger = require(\"logger\");\nlocal config = require(\"config\");\n\nlocal Scope = {};\n\nlocal scopeI = 0;\nlocal function nextName()\n\tscopeI = scopeI + 1;\n\treturn \"local_scope_\" .. tostring(scopeI);\nend\n\nlocal function generateWarning(token, message)\n\treturn \"Warning at Position \" .. tostring(token.line) .. \":\" .. tostring(token.linePos) .. \", \" .. message;\nend\n\n-- Create a new Local Scope\nfunction Scope:new(parentScope, name)\n\tlocal scope = {\n\t\tisGlobal = false,\n\t\tparentScope = parentScope,\n\t\tvariables = {},\n\t\treferenceCounts = {};\n\t\tvariablesLookup = {},\n\t\tvariablesFromHigherScopes = {},\n\t\tskipIdLookup = {};\n\t\tname = name or nextName(),\n\t\tchildren = {},\n\t\tlevel = parentScope.level and (parentScope.level + 1) or 1;\n\t}\n\t\n\tsetmetatable(scope, self);\n\tself.__index = self;\n\tparentScope:addChild(scope);\n\treturn scope;\nend\n\n-- Create a new Global Scope\nfunction Scope:newGlobal()\n\tlocal scope = {\n\t\tisGlobal = true,\n\t\tparentScope = nil,\n\t\tvariables = {},\n\t\tvariablesLookup = {};\n\t\treferenceCounts = {};\n\t\tskipIdLookup = {};\n\t\tname = \"global_scope\",\n\t\tchildren = {},\n\t\tlevel = 0,\n\t};\n\t\n\tsetmetatable(scope, self);\n\tself.__index = self;\n\t\n\treturn scope;\nend\n\n-- Returns the Parent Scope\nfunction Scope:getParent(parentScope)\n\treturn self.parentScope;\nend\n\nfunction Scope:setParent(parentScope)\n\tself.parentScope:removeChild(self);\n\tparentScope:addChild(self);\n\tself.parentScope = parentScope;\n\tself.level = parentScope.level + 1;\nend\n\nlocal next_name_i = 1;\n-- Adds a Variable to the scope and returns the variable id, if no name is passed then a name is generated\nfunction Scope:addVariable(name, token)\n\tif (not name) then\n\t\tname = string.format(\"%s%i\", config.IdentPrefix, next_name_i);\n\t\tnext_name_i = next_name_i + 1;\n\tend\n\t\n\tif self.variablesLookup[name] ~= nil then\n\t\tif(token) then\n\t\t\tlogger:warn(generateWarning(token, \"the variable \\\"\" .. name .. \"\\\" is already defined in that scope\"));\n\t\telse\n\t\t\tlogger:error(string.format(\"A variable with the name \\\"%s\\\" was already defined, you should have no variables starting with \\\"%s\\\"\", name, config.IdentPrefix));\n\t\tend\n\t\t\n\t\t--return self.variablesLookup[name];\n\tend\n\t\n\ttable.insert(self.variables, name);\n\tlocal id = #self.variables;\n\tself.variablesLookup[name] = id;\n\treturn id;\nend\n\nfunction Scope:enableVariable(id)\n\tlocal name = self.variables[id];\n\tself.variablesLookup[name] = id;\nend\n\nfunction Scope:addDisabledVariable(name, token)\n\tif (not name) then\n\t\tname = string.format(\"%s%i\", config.IdentPrefix, next_name_i);\n\t\tnext_name_i = next_name_i + 1;\n\tend\n\t\n\tif self.variablesLookup[name] ~= nil then\n\t\tif(token) then\n\t\t\tlogger:warn(generateWarning(token, \"the variable \\\"\" .. name .. \"\\\" is already defined in that scope\"));\n\t\telse\n\t\t\tlogger:warn(string.format(\"a variable with the name \\\"%s\\\" was already defined\", name));\n\t\tend\n\t\t\n\t\t--return self.variablesLookup[name];\n\tend\n\t\n\ttable.insert(self.variables, name);\n\tlocal id = #self.variables;\n\treturn id;\nend\n\nfunction Scope:addIfNotExists(id)\n\tif(not self.variables[id]) then\n\t\tlocal name = string.format(\"%s%i\", config.IdentPrefix, next_name_i);\n\t\tnext_name_i = next_name_i + 1;\n\t\tself.variables[id] = name;\n\t\tself.variablesLookup[name] = id;\n\tend\n\treturn id;\nend\n\n-- Returns wether the variable is defined in this Scope\nfunction Scope:hasVariable(name)\n\tif(self.isGlobal) then\n\t\tif self.variablesLookup[name] == nil then\n\t\t\tself:addVariable(name);\n\t\tend\n\t\treturn true;\n\tend\n\treturn self.variablesLookup[name] ~= nil;\nend\n\n-- Get List of all Variables defined in this Scope\nfunction Scope:getVariables()\n\treturn self.variables;\nend\n\nfunction Scope:resetReferences(id)\n\tself.referenceCounts[id] = 0;\nend\n\nfunction Scope:getReferences(id)\n\treturn self.referenceCounts[id] or 0;\nend\n\nfunction Scope:removeReference(id)\n\tself.referenceCounts[id] = (self.referenceCounts[id] or 0) - 1;\nend\n\nfunction Scope:addReference(id)\n\tself.referenceCounts[id] = (self.referenceCounts[id] or 0) + 1;\nend\n\n-- Resolve the scope of a variable by name\nfunction Scope:resolve(name)\n\tif(self:hasVariable(name)) then\n\t\treturn self, self.variablesLookup[name];\n\tend\n\tassert(self.parentScope, \"No Global Variable Scope was Created! This should not be Possible!\");\n\tlocal scope, id = self.parentScope:resolve(name);\n\tself:addReferenceToHigherScope(scope, id, nil, true);\n\treturn scope, id;\nend\n\nfunction Scope:resolveGlobal(name)\n\tif(self.isGlobal and self:hasVariable(name)) then\n\t\treturn self, self.variablesLookup[name];\n\tend\n\tassert(self.parentScope, \"No Global Variable Scope was Created! This should not be Possible!\");\n\tlocal scope, id = self.parentScope:resolveGlobal(name);\n\tself:addReferenceToHigherScope(scope, id, nil, true);\n\treturn scope, id;\nend\n\n-- Returns the name of an Variable by id - this is used for unparsing\nfunction Scope:getVariableName(id)\n\treturn self.variables[id];\nend\n\n-- Remove A Variable from this Scope\nfunction Scope:removeVariable(id)\n\tlocal name = self.variables[id];\n\tself.variables[id] = nil;\n\tself.variablesLookup[name] = nil;\n\tself.skipIdLookup[id] = true;\nend\n\n-- Add a Children Scope\nfunction Scope:addChild(scope)\n\t-- This will add all References from that Scope to higher Scopes. Note that the higher scopes may only be global\n\tfor scope, ids in pairs(scope.variablesFromHigherScopes) do\n\t\tfor id, count in pairs(ids) do\n\t\t\tif count and count > 0 then\n\t\t\t\tself:addReferenceToHigherScope(scope, id, count);\n\t\t\tend\n\t\tend\n\tend\n\ttable.insert(self.children, scope);\nend\n\nfunction Scope:clearReferences()\n\tself.referenceCounts = {};\n\tself.variablesFromHigherScopes = {};\nend\n\nfunction Scope:removeChild(child)\n\tfor i, v in ipairs(self.children) do\n\t\tif(v == child) then\n\t\t\t-- This will add all References from that Scope to higher Scopes. Note that the higher scopes may only be global\n\t\t\tfor scope, ids in pairs(v.variablesFromHigherScopes) do\n\t\t\t\tfor id, count in pairs(ids) do\n\t\t\t\t\tif count and count > 0 then\n\t\t\t\t\t\tself:removeReferenceToHigherScope(scope, id, count);\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn table.remove(self.children, i);\n\t\tend\n\tend\nend\n\nfunction Scope:getMaxId()\n\treturn #self.variables;\nend\n\nfunction Scope:addReferenceToHigherScope(scope, id, n, b)\n\tn = n or 1;\n\tif self.isGlobal then\n\t\tif not scope.isGlobal then\n\t\t\tlogger:error(string.format(\"Could not resolve Scope \\\"%s\\\"\", scope.name))\n\t\tend\n\t\treturn\n\tend\n\tif scope == self then\n\t\tself.referenceCounts[id] = (self.referenceCounts[id] or 0) + n;\n\t\treturn\n\tend\n\tif not self.variablesFromHigherScopes[scope] then\n\t\tself.variablesFromHigherScopes[scope] = {};\n\tend\n\tlocal scopeReferences = self.variablesFromHigherScopes[scope];\n\tif scopeReferences[id] then\n\t\tscopeReferences[id]  = scopeReferences[id] + n;\n\telse\n\t\tscopeReferences[id] = n;\n\tend\n\tif not b then\n\t\tself.parentScope:addReferenceToHigherScope(scope, id, n);\n\tend\nend\n\nfunction Scope:removeReferenceToHigherScope(scope, id, n, b)\n\tn = n or 1;\n\tif self.isGlobal then\n\t\treturn\n\tend\n\tif scope == self then\n\t\tself.referenceCounts[id] = (self.referenceCounts[id] or 0) - n;\n\t\treturn\n\tend\n\tif not self.variablesFromHigherScopes[scope] then\n\t\tself.variablesFromHigherScopes[scope] = {};\n\tend\n\tlocal scopeReferences = self.variablesFromHigherScopes[scope];\n\tif scopeReferences[id] then\n\t\tscopeReferences[id]  = scopeReferences[id] - n;\n\telse\n\t\tscopeReferences[id] = 0;\n\tend\n\tif not b then\n\t\tself.parentScope:removeReferenceToHigherScope(scope, id, n);\n\tend\nend\n\n-- Rename Variables from that scope downwards\n-- this function needs a settings object with the following properties\n-- Keywords => forbidden Variable Names\n-- generateName(id, scope, originalName) => function to generate unique variable name based on the id and scope\nfunction Scope:renameVariables(settings)\n\tif(not self.isGlobal) then\n\t\tlocal prefix = settings.prefix or \"\";\n\t\tlocal forbiddenNamesLookup = {};\n\t\tfor _, keyword in pairs(settings.Keywords) do\n\t\t\tforbiddenNamesLookup[keyword] = true;\n\t\tend\n\t\t\n\t\tfor scope, ids in pairs(self.variablesFromHigherScopes) do\n\t\t\tfor id, count in pairs(ids) do\n\t\t\t\tif count and count > 0 then\n\t\t\t\t\tlocal name = scope:getVariableName(id);\n\t\t\t\t\tforbiddenNamesLookup[name] = true;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tself.variablesLookup = {};\n\t\t\n\t\tlocal i = 0;\n\t\tfor id, originalName in pairs(self.variables) do\n\t\t\tif(not self.skipIdLookup[id] and (self.referenceCounts[id] or 0) >= 0) then\n\t\t\t\tlocal name;\n\t\t\t\trepeat\n\t\t\t\t\tname = prefix .. settings.generateName(i, self, originalName);\n\t\t\t\t\tif name == nil then\n\t\t\t\t\t\tname = originalName;\n\t\t\t\t\tend\n\t\t\t\t\ti = i + 1;\n\t\t\t\tuntil not forbiddenNamesLookup[name];\n\n\t\t\t\tself.variables[id] = name;\n\t\t\t\tself.variablesLookup[name] = id;\n\t\t\tend\n\t\tend\n\tend\n\t\n\tfor _, scope in pairs(self.children) do\n\t\tscope:renameVariables(settings);\n\tend\nend\n\nreturn Scope;",
  "prometheus.step": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- step.lua\n--\n-- This file Provides the base class for Obfuscation Steps\n\nlocal logger = require(\"logger\");\nlocal util = require(\"prometheus.util\");\n\nlocal lookupify = util.lookupify;\n\nlocal Step = {};\n\nStep.SettingsDescriptor = {}\n\nfunction Step:new(settings)\n\tlocal instance = {};\n\tsetmetatable(instance, self);\n\tself.__index = self;\n\t\n\tif type(settings) ~= \"table\" then\n\t\tsettings = {};\n\tend\n\t\n\tfor key, data in pairs(self.SettingsDescriptor) do\n\t\tif settings[key] == nil then\n\t\t\tif data.default == nil then\n\t\t\t\tlogger:error(string.format(\"The Setting \\\"%s\\\" was not provided for the Step \\\"%s\\\"\", key, self.Name));\n\t\t\tend\n\t\t\tinstance[key] = data.default;\n\t\telseif(data.type == \"enum\") then\n\t\t\tlocal lookup = lookupify(data.values);\n\t\t\tif not lookup[settings[key]] then\n\t\t\t\tlogger:error(string.format(\"Invalid value for the Setting \\\"%s\\\" of the Step \\\"%s\\\". It must be one of the following: %s\", key, self.Name, table.concat(data, \", \")));\n\t\t\tend\n\t\t\tinstance[key] = settings[key];\n\t\telseif(type(settings[key]) ~= data.type) then\n\t\t\tlogger:error(string.format(\"Invalid value for the Setting \\\"%s\\\" of the Step \\\"%s\\\". It must be a %s\", key, self.Name, data.type));\n\t\telse\n\t\t\tif data.min then\n\t\t\t\tif  settings[key] < data.min then\n\t\t\t\t\tlogger:error(string.format(\"Invalid value for the Setting \\\"%s\\\" of the Step \\\"%s\\\". It must be at least %d\", key, self.Name, data.min));\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tif data.max then\n\t\t\t\tif  settings[key] > data.max then\n\t\t\t\t\tlogger:error(string.format(\"Invalid value for the Setting \\\"%s\\\" of the Step \\\"%s\\\". The biggest allowed value is %d\", key, self.Name, data.min));\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tinstance[key] = settings[key];\n\t\tend\n\tend\n\t\n\tinstance:init();\n\n\treturn instance;\nend\n\nfunction Step:init()\n\tlogger:error(\"Abstract Steps cannot be Created\");\nend\n\nfunction Step:extend()\n\tlocal ext = {};\n\tsetmetatable(ext, self);\n\tself.__index = self;\n\treturn ext;\nend\n\nfunction Step:apply(ast, pipeline)\n\tlogger:error(\"Abstract Steps cannot be Applied\")\nend\n\nStep.Name = \"Abstract Step\";\nStep.Description = \"Abstract Step\";\n\nreturn Step;\n",
  "prometheus.steps": "return {\n\tWrapInFunction       = require(\"prometheus.steps.WrapInFunction\");\n\tSplitStrings         = require(\"prometheus.steps.SplitStrings\");\n\tVmify                = require(\"prometheus.steps.Vmify\");\n\tConstantArray        = require(\"prometheus.steps.ConstantArray\");\n\tProxifyLocals  \t\t\t = require(\"prometheus.steps.ProxifyLocals\");\n\tAntiTamper  \t\t\t\t = require(\"prometheus.steps.AntiTamper\");\n\tEncryptStrings \t\t\t = require(\"prometheus.steps.EncryptStrings\");\n\tNumbersToExpressions = require(\"prometheus.steps.NumbersToExpressions\");\n\tAddVararg \t\t\t\t\t = require(\"prometheus.steps.AddVararg\");\n\tWatermarkCheck\t\t   = require(\"prometheus.steps.WatermarkCheck\");\n}",
  "prometheus.tokenizer": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- tokenizer.lua\n-- Overview:\n-- This Script provides a class for lexical Analysis of lua code.\n-- This Tokenizer is Capable of tokenizing LuaU and Lua5.1\nlocal Enums = require(\"prometheus.enums\");\nlocal util = require(\"prometheus.util\");\nlocal logger = require(\"logger\");\nlocal config = require(\"config\");\n\nlocal LuaVersion = Enums.LuaVersion;\nlocal lookupify = util.lookupify;\nlocal unlookupify = util.unlookupify;\nlocal escape = util.escape;\nlocal chararray = util.chararray;\nlocal keys = util.keys;\nlocal Tokenizer = {};\n\nTokenizer.EOF_CHAR = \"<EOF>\";\nTokenizer.WHITESPACE_CHARS = lookupify{\n\t\" \", \"\\t\", \"\\n\", \"\\r\",\n}\n\nTokenizer.ANNOTATION_CHARS = lookupify(chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\"))\nTokenizer.ANNOTATION_START_CHARS = lookupify(chararray(\"!@\"))\n\nTokenizer.Conventions = Enums.Conventions;\n\nTokenizer.TokenKind = {\n\tEof     = \"Eof\",\n\tKeyword = \"Keyword\",\n\tSymbol  = \"Symbol\",\n\tIdent   = \"Identifier\",\n\tNumber  = \"Number\",\n\tString  = \"String\",\n}\n\nTokenizer.EOF_TOKEN = {\n\tkind = Tokenizer.TokenKind.Eof,\n\tvalue = \"<EOF>\",\n\tstartPos = -1,\n\tendPos = -1,\n\tsource = \"<EOF>\",\n}\n\nlocal function token(self, startPos, kind, value)\n\tlocal line, linePos = self:getPosition(self.index);\n\tlocal annotations = self.annotations\n\tself.annotations = {};\n\treturn {\n\t\tkind     = kind,\n\t\tvalue    = value,\n\t\tstartPos = startPos,\n\t\tendPos   = self.index,\n\t\tsource   = self.source:sub(startPos + 1, self.index),\n\t\tline     = line,\n\t\tlinePos  = linePos,\n\t\tannotations = annotations,\n\t}\nend\n\nlocal function generateError(self, message)\n\tlocal line, linePos = self:getPosition(self.index);\n\treturn \"Lexing Error at Position \" .. tostring(line) .. \":\" .. tostring(linePos) .. \", \" .. message;\nend\n\nlocal function generateWarning(token, message)\n\treturn \"Warning at Position \" .. tostring(token.line) .. \":\" .. tostring(token.linePos) .. \", \" .. message;\nend\n\nfunction Tokenizer:getPosition(i)\n\tlocal column = self.columnMap[i]\n\n\tif not column then --// `i` is bigger than self.length, this shouldnt happen, but it did. (Theres probably some error in the tokenizer, cant find it.)\n\t\tcolumn = self.columnMap[#self.columnMap] \n\tend\n\n\treturn column.id, column.charMap[i]\nend\n\n--// Prepare columnMap for getPosition\nfunction Tokenizer:prepareGetPosition()\n\tlocal columnMap, column = {}, { charMap = {}, id = 1, length = 0 }\n\n\tfor index = 1, self.length do\n\t\tlocal character = string.sub(self.source, index, index) -- NOTE_1: this could use table.clone to reduce amount of NEWTABLE (if that causes any performance issues)\n\n\t\tlocal columnLength = column.length + 1\n\t\tcolumn.length = columnLength\n\t\tcolumn.charMap[index] = columnLength\n\n\t\tif character == \"\\n\" then\n\t\t\tcolumn = { charMap = {}, id = column.id + 1, length = 0 } -- NOTE_1\n\t\tend\n\n\t\tcolumnMap[index] = column\n\tend\n\n\tself.columnMap = columnMap\nend\n\n-- Constructor for Tokenizer\nfunction Tokenizer:new(settings) \n\tlocal luaVersion = (settings and (settings.luaVersion or settings.LuaVersion)) or LuaVersion.LuaU;\n\tlocal conventions = Tokenizer.Conventions[luaVersion];\n\t\n\tif(conventions == nil) then\n\t\tlogger:error(\"The Lua Version \\\"\" .. luaVersion .. \"\\\" is not recognised by the Tokenizer! Please use one of the following: \\\"\" .. table.concat(keys(Tokenizer.Conventions), \"\\\",\\\"\") .. \"\\\"\");\n\tend\n\t\n\tlocal tokenizer = {\n\t\tindex  = 0,           -- Index where the current char is read\n\t\tlength = 0,\n\t\tsource = \"\", -- Source to Tokenize\n\t\tluaVersion = luaVersion, -- LuaVersion to be used while Tokenizing\n\t\tconventions = conventions;\n\t\t\n\t\tNumberChars       = conventions.NumberChars,\n\t\tNumberCharsLookup = lookupify(conventions.NumberChars),\n\t\tKeywords          = conventions.Keywords,\n\t\tKeywordsLookup    = lookupify(conventions.Keywords),\n\t\tBinaryNumberChars = conventions.BinaryNumberChars,\n\t\tBinaryNumberCharsLookup = lookupify(conventions.BinaryNumberChars);\n\t\tBinaryNums        = conventions.BinaryNums,\n\t\tHexadecimalNums   = conventions.HexadecimalNums,\n\t\tHexNumberChars    = conventions.HexNumberChars,\n\t\tHexNumberCharsLookup = lookupify(conventions.HexNumberChars),\n\t\tDecimalExponent   = conventions.DecimalExponent,\n\t\tDecimalSeperators = conventions.DecimalSeperators,\n\t\tIdentChars        = conventions.IdentChars,\n\t\tIdentCharsLookup  = lookupify(conventions.IdentChars),\n\t\t\n\t\tEscapeSequences   = conventions.EscapeSequences,\n\t\tNumericalEscapes  = conventions.NumericalEscapes,\n\t\tEscapeZIgnoreNextWhitespace = conventions.EscapeZIgnoreNextWhitespace,\n\t\tHexEscapes        = conventions.HexEscapes,\n\t\tUnicodeEscapes    = conventions.UnicodeEscapes,\n\t\t\n\t\tSymbolChars       = conventions.SymbolChars,\n\t\tSymbolCharsLookup = lookupify(conventions.SymbolChars),\n\t\tMaxSymbolLength   = conventions.MaxSymbolLength,\n\t\tSymbols           = conventions.Symbols,\n\t\tSymbolsLookup     = lookupify(conventions.Symbols),\n\t\t\n\t\tStringStartLookup = lookupify({\"\\\"\", \"\\'\"}),\n\t\tannotations = {},\n\t};\n\t\n\tsetmetatable(tokenizer, self);\n\tself.__index = self;\n\t\n\treturn tokenizer;\nend\n\n-- Reset State of Tokenizer to Tokenize another File\nfunction Tokenizer:reset()\n\tself.index = 0;\n\tself.length = 0;\n\tself.source = \"\";\n\tself.annotations = {};\n\tself.columnMap = {};\nend\n\n-- Append String to this Tokenizer\nfunction Tokenizer:append(code)\n\tself.source = self.source .. code\n\tself.length = self.length + code:len();\n\tself:prepareGetPosition();\nend\n\n-- Function to peek the n'th char in the source of the tokenizer\nlocal function peek(self, n)\n\tn = n or 0;\n\tlocal i = self.index + n + 1;\n\tif i > self.length then\n\t\treturn Tokenizer.EOF_CHAR\n\tend\n\treturn self.source:sub(i, i);\nend\n\n-- Function to get the next char in the source\nlocal function get(self)\n\tlocal i = self.index + 1;\n\tif i > self.length then\n\t\tlogger:error(generateError(self, \"Unexpected end of Input\"));\n\tend\n\tself.index = self.index + 1;\n\treturn self.source:sub(i, i);\nend\n\n-- The same as get except it throws an Error if the char is not contained in charOrLookup\nlocal function expect(self, charOrLookup)\n\tif(type(charOrLookup) == \"string\") then\n\t\tcharOrLookup = {[charOrLookup] = true};\n\tend\n\t\n\tlocal char = peek(self);\n\tif charOrLookup[char] ~= true then\n\t\tlocal etb = unlookupify(charOrLookup);\n\t\tfor i, v in ipairs(etb) do\n\t\t\tetb[i] = escape(v);\n\t\tend\n\t\tlocal errorMessage = \"Unexpected char \\\"\" .. escape(char) .. \"\\\"! Expected one of \\\"\" .. table.concat(etb, \"\\\",\\\"\") .. \"\\\"\";\n\t\tlogger:error(generateError(self, errorMessage));\n\tend\n\t\n\tself.index = self.index + 1;\n\treturn char;\nend\n\n-- Returns wether the n'th char is in the lookup\nlocal function is(self, charOrLookup, n)\n\tlocal char = peek(self, n);\n\tif(type(charOrLookup) == \"string\") then\n\t\treturn char == charOrLookup;\n\tend\n\treturn charOrLookup[char];\nend\n\nfunction Tokenizer:parseAnnotation()\n\tif is(self, Tokenizer.ANNOTATION_START_CHARS) then\n\t\tself.index = self.index + 1;\n\t\tlocal source, length = {}, 0;\n\t\twhile(is(self, Tokenizer.ANNOTATION_CHARS)) do\n\t\t\tsource[length + 1] = get(self)\n\t\t\tlength = #source\n\t\tend\n\t\tif length > 0 then\n\t\t\tself.annotations[string.lower(table.concat(source))] = true;\n\t\tend\n\t\treturn nil;\n\tend\n\treturn get(self);\nend\n\n-- skip one or 0 Comments and return wether one was found\nfunction Tokenizer:skipComment()\n\tif(is(self, \"-\", 0) and is(self, \"-\", 1)) then\n\t\tself.index = self.index + 2;\n\t\tif(is(self, \"[\")) then\n\t\t\tself.index = self.index + 1;\n\t\t\tlocal eqCount = 0;\n\t\t\twhile(is(self, \"=\")) do\n\t\t\t\tself.index = self.index + 1;\n\t\t\t\teqCount = eqCount + 1;\n\t\t\tend\n\t\t\tif(is(self, \"[\")) then\n\t\t\t\t-- Multiline Comment\n\t\t\t\t-- Get all Chars to Closing bracket but also consider that the count of equal signs must be the same\n\t\t\t\twhile true do\n\t\t\t\t\tif(self:parseAnnotation() == ']') then\n\t\t\t\t\t\tlocal eqCount2 = 0;\n\t\t\t\t\t\twhile(is(self, \"=\")) do\n\t\t\t\t\t\t\tself.index = self.index + 1;\n\t\t\t\t\t\t\teqCount2 = eqCount2 + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\tif(is(self, \"]\")) then\n\t\t\t\t\t\t\tif(eqCount2 == eqCount) then\n\t\t\t\t\t\t\t\tself.index = self.index + 1;\n\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t-- Single Line Comment\n\t\t-- Get all Chars to next Newline\n\t\twhile(self.index < self.length and self:parseAnnotation() ~= \"\\n\") do end\n\t\treturn true;\n\tend\n\treturn false;\nend\n\n-- skip All Whitespace and Comments to next Token\nfunction Tokenizer:skipWhitespaceAndComments()\n\twhile self:skipComment() do end\n\twhile is(self, Tokenizer.WHITESPACE_CHARS) do\n\t\tself.index = self.index + 1;\n\t\twhile self:skipComment() do end\n\tend\nend\n\nlocal function int(self, chars, seperators)\n\tlocal buffer = {};\n\twhile true do\n\t\tif (is(self, chars)) then\n\t\t\tbuffer[#buffer + 1] = get(self)\n\t\telseif (is(self, seperators)) then\n\t\t\tself.index = self.index + 1;\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn table.concat(buffer);\nend\n\n-- Lex the next token as a Number\nfunction Tokenizer:number()\n\tlocal startPos = self.index;\n\tlocal source   = expect(self, setmetatable({[\".\"] = true}, {__index = self.NumberCharsLookup}));\n\t\n\tif source == \"0\" then\n\t\tif self.BinaryNums and is(self, lookupify(self.BinaryNums)) then\n\t\t\tself.index = self.index + 1;\n\t\t\tsource = int(self, self.BinaryNumberCharsLookup, lookupify(self.DecimalSeperators or {}));\n\t\t\tlocal value = tonumber(source, 2);\n\t\t\treturn token(self, startPos, Tokenizer.TokenKind.Number, value);\n\t\tend\n\t\t\n\t\tif self.HexadecimalNums and is(self, lookupify(self.HexadecimalNums)) then\n\t\t\tself.index = self.index + 1;\n\t\t\tsource = int(self, self.HexNumberCharsLookup, lookupify(self.DecimalSeperators or {}));\n\t\t\tlocal value = tonumber(source, 16);\n\t\t\treturn token(self, startPos, Tokenizer.TokenKind.Number, value);\n\t\tend\n\tend\n\t\n\tif source == \".\" then\n\t\tsource = source .. int(self, self.NumberCharsLookup, lookupify(self.DecimalSeperators or {}));\n\telse\n\t\tsource = source .. int(self, self.NumberCharsLookup, lookupify(self.DecimalSeperators or {}));\n\t\tif(is(self, \".\")) then\n\t\t\tsource = source .. get(self) .. int(self, self.NumberCharsLookup, lookupify(self.DecimalSeperators or {}));\n\t\tend\n\tend\n\t\n\tif(self.DecimalExponent and is(self, lookupify(self.DecimalExponent))) then\n\t\tsource = source .. get(self);\n\t\tif(is(self, lookupify({\"+\",\"-\"}))) then\n\t\t\tsource = source .. get(self);\n\t\tend\n\t\tlocal v = int(self, self.NumberCharsLookup, lookupify(self.DecimalSeperators or {}));\n\t\tif(v:len() < 1) then\n\t\t\tlogger:error(generateError(self, \"Expected a Valid Exponent!\"));\n\t\tend\n\t\tsource = source .. v;\n\tend\n\t\n\tlocal value = tonumber(source);\n\treturn token(self, startPos, Tokenizer.TokenKind.Number, value);\nend\n\n-- Lex the Next Token as Identifier or Keyword\nfunction Tokenizer:ident()\n\tlocal startPos = self.index;\n\tlocal source = expect(self, self.IdentCharsLookup)\n\tlocal sourceAddContent = {source}\n\twhile(is(self, self.IdentCharsLookup)) do\n\t\t-- source = source .. get(self);\n\t\ttable.insert(sourceAddContent, get(self))\n\tend\n\tsource = table.concat(sourceAddContent)\n\tif(self.KeywordsLookup[source]) then\n\t\treturn token(self, startPos, Tokenizer.TokenKind.Keyword, source);\n\tend\n\t\n\tlocal tk = token(self, startPos, Tokenizer.TokenKind.Ident, source);\n\t\n\tif(string.sub(source, 1, string.len(config.IdentPrefix)) == config.IdentPrefix) then\n\t\tlogger:warn(generateWarning(tk, string.format(\"identifiers should not start with \\\"%s\\\" as this may break the program\", config.IdentPrefix)));\n\tend\n\t\n\treturn tk;\nend\n\nfunction Tokenizer:singleLineString()\n\tlocal startPos = self.index;\n\tlocal startChar = expect(self, self.StringStartLookup);\n\tlocal buffer = {};\n\n\twhile (not is(self, startChar)) do\n\t\tlocal char = get(self);\n\t\t\n\t\t-- Single Line String may not contain Linebreaks except when they are escaped by \\\n\t\tif(char == '\\n') then\n\t\t\tself.index = self.index - 1;\n\t\t\tlogger:error(generateError(self, \"Unterminated String\"));\n\t\tend\n\t\t\n\t\t\n\t\tif(char == \"\\\\\") then\n\t\t\tchar = get(self);\n\t\t\t\n\t\t\tlocal escape = self.EscapeSequences[char];\n\t\t\tif(type(escape) == \"string\") then\n\t\t\t\tchar = escape;\n\t\t\t\t\n\t\t\telseif(self.NumericalEscapes and self.NumberCharsLookup[char]) then\n\t\t\t\tlocal numstr = char;\n\t\t\t\t\n\t\t\t\tif(is(self, self.NumberCharsLookup)) then\n\t\t\t\t\tchar = get(self);\n\t\t\t\t\tnumstr = numstr .. char;\n\t\t\t\tend\n\t\t\n\t\t\t\tif(is(self, self.NumberCharsLookup)) then\n\t\t\t\t\tchar = get(self);\n\t\t\t\t\tnumstr = numstr .. char;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tchar = string.char(tonumber(numstr));\n\t\t\t\t\n\t\t\telseif(self.UnicodeEscapes and char == \"u\") then\n\t\t\t\texpect(self, \"{\");\n\t\t\t\tlocal num = \"\";\n\t\t\t\twhile (is(self, self.HexNumberCharsLookup)) do\n\t\t\t\t\tnum = num .. get(self);\n\t\t\t\tend\n\t\t\t\texpect(self, \"}\");\n\t\t\t\tchar = util.utf8char(tonumber(num, 16));\n\t\t\telseif(self.HexEscapes and char == \"x\") then\n\t\t\t\tlocal hex = expect(self, self.HexNumberCharsLookup) .. expect(self, self.HexNumberCharsLookup);\n\t\t\t\tchar = string.char(tonumber(hex, 16));\n\t\t\telseif(self.EscapeZIgnoreNextWhitespace and char == \"z\") then\n\t\t\t\tchar = \"\";\n\t\t\t\twhile(is(self, Tokenizer.WHITESPACE_CHARS)) do\n\t\t\t\t\tself.index = self.index + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\t--// since table.insert is slower in lua51\n\t\tbuffer[#buffer + 1] = char\n\tend\n\t\n\texpect(self, startChar);\n\t\n\treturn token(self, startPos, Tokenizer.TokenKind.String, table.concat(buffer))\nend\n\nfunction Tokenizer:multiLineString()\n\tlocal startPos = self.index;\n\tif(is(self, \"[\")) then\n\t\tself.index = self.index + 1;\n\t\tlocal eqCount = 0;\n\t\twhile(is(self, \"=\")) do\n\t\t\tself.index = self.index + 1;\n\t\t\teqCount = eqCount + 1;\n\t\tend\n\t\tif(is(self, \"[\")) then\n\t\t\t-- Multiline String\n\t\t\t-- Parse String to Closing bracket but also consider that the count of equal signs must be the same\n\t\t\t\n\t\t\t-- Skip Leading newline if existing\n\t\t\tself.index = self.index + 1;\n\t\t\tif(is(self, \"\\n\")) then\n\t\t\t\tself.index = self.index + 1;\n\t\t\tend\n\t\t\t\n\t\t\tlocal value = \"\";\n\t\t\twhile true do\n\t\t\t\tlocal char = get(self);\n\t\t\t\tif(char == ']') then\n\t\t\t\t\tlocal eqCount2 = 0;\n\t\t\t\t\twhile(is(self, \"=\")) do\n\t\t\t\t\t\tchar = char .. get(self);\n\t\t\t\t\t\teqCount2 = eqCount2 + 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(is(self, \"]\")) then\n\t\t\t\t\t\tif(eqCount2 == eqCount) then\n\t\t\t\t\t\t\tself.index = self.index + 1;\n\t\t\t\t\t\t\treturn token(self, startPos, Tokenizer.TokenKind.String, value), true\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tvalue = value .. char;\n\t\t\tend\n\t\tend\n\tend\n\tself.index = startPos;\n\treturn nil, false -- There was not an actual multiline string at the given Position\nend\n\nfunction Tokenizer:symbol()\n\tlocal startPos = self.index;\n\tfor len = self.MaxSymbolLength, 1, -1 do\n\t\tlocal str = self.source:sub(self.index + 1, self.index + len);\n\t\tif self.SymbolsLookup[str] then\n\t\t\tself.index = self.index + len;\n\t\t\treturn token(self, startPos, Tokenizer.TokenKind.Symbol, str);\n\t\tend\n\tend\n\tlogger:error(generateError(self, \"Unknown Symbol\"));\nend\n\n\n-- get the Next token\nfunction Tokenizer:next()\n\t-- Skip All Whitespace before the token\n\tself:skipWhitespaceAndComments();\n\t\n\tlocal startPos = self.index;\n\tif startPos >= self.length then\n\t\treturn token(self, startPos, Tokenizer.TokenKind.Eof);\n\tend\n\t\n\t-- Numbers\n\tif(is(self, self.NumberCharsLookup)) then\n\t\treturn self:number();\n\tend\n\t\n\t-- Identifiers and Keywords\n\tif(is(self, self.IdentCharsLookup)) then\n\t\treturn self:ident();\n\tend\n\t\n\t-- Singleline String Literals\n\tif(is(self, self.StringStartLookup)) then\n\t\treturn self:singleLineString();\n\tend\n\t\n\t-- Multiline String Literals\n\tif(is(self, \"[\", 0)) then\n\t\t-- The isString variable is due to the fact that \"[\" could also be a symbol for indexing\n\t\tlocal value, isString = self:multiLineString();\n\t\tif isString then\n\t\t\treturn value;\n\t\tend\n\tend\n\n\t-- Number starting with dot\n\tif(is(self, \".\") and is(self, self.NumberCharsLookup, 1)) then\n\t\treturn self:number();\n\tend\n\t\n\t-- Symbols\n\tif(is(self, self.SymbolCharsLookup)) then\n\t\treturn self:symbol();\n\tend\n\t\n\n\tlogger:error(generateError(self, \"Unexpected char \\\"\" .. escape(peek(self)) .. \"\\\"!\"));\nend\n\nfunction Tokenizer:scanAll()\n\tlocal tb = {};\n\trepeat\n\t\tlocal token = self:next();\n\t\ttable.insert(tb, token);\n\tuntil token.kind == Tokenizer.TokenKind.Eof\n\treturn tb\nend\n\nreturn Tokenizer\n",
  "prometheus.unparser": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- unparser.lua\n-- Overview:\n-- This Script provides a class for lua code generation from an ast\n-- This UnParser is Capable of generating LuaU and Lua5.1\n-- \n-- Note that a LuaU ast can only be unparsed as LuaU if it contains any continue statements\n--\n-- Settings Object:\n-- luaVersion : The LuaVersion of the Script\n--\n\nlocal config = require(\"config\");\nlocal Ast    = require(\"prometheus.ast\");\nlocal Enums  = require(\"prometheus.enums\");\nlocal util = require(\"prometheus.util\");\nlocal logger = require(\"logger\");\n\nlocal lookupify = util.lookupify;\nlocal LuaVersion = Enums.LuaVersion;\nlocal AstKind = Ast.AstKind;\n\nlocal Unparser = {}\n\nUnparser.SPACE = config.SPACE;\nUnparser.TAB = config.TAB;\n\nlocal function escapeString(str)\n\tstr = util.escape(str)\n\treturn str;\nend\n\nfunction Unparser:new(settings)\n\tlocal luaVersion = settings.LuaVersion or LuaVersion.LuaU;\n\tlocal conventions = Enums.Conventions[luaVersion];\n\tlocal unparser = {\n\t\tluaVersion = luaVersion;\n\t\tconventions = conventions;\n\t\tidentCharsLookup = lookupify(conventions.IdentChars);\n\t\tnumberCharsLookup = lookupify(conventions.NumberChars);\n\t\tprettyPrint = settings and settings.PrettyPrint or false;\n\t\tnotIdentPattern = \"[^\" .. table.concat(conventions.IdentChars, \"\") .. \"]\";\n\t\tnumberPattern = \"^[\" .. table.concat(conventions.NumberChars, \"\") .. \"]\";\n\t\thighlight     = settings and settings.Highlight or false;\n\t\tkeywordsLookup = lookupify(conventions.Keywords);\n\t}\n\t\n\tsetmetatable(unparser, self);\n\tself.__index = self;\n\t\n\treturn unparser;\nend\n\nfunction Unparser:isValidIdentifier(source)\n\tif(string.find(source, self.notIdentPattern)) then\n\t\treturn false;\n\tend\n\tif(string.find(source, self.numberPattern)) then\n\t\treturn false;\n\tend\n\tif self.keywordsLookup[source] then\n\t\treturn false;\n\tend\n\treturn #source > 0;\nend\n\nfunction Unparser:setPrettyPrint(prettyPrint)\n\tself.prettyPrint = prettyPrint;\nend\n\nfunction Unparser:getPrettyPrint()\n\treturn self.prettyPrint;\nend\n\nfunction Unparser:tabs(i, ws_needed)\n\treturn self.prettyPrint and string.rep(self.TAB, i) or ws_needed and self.SPACE or \"\";\nend\n\nfunction Unparser:newline(ws_needed)\n\treturn self.prettyPrint and \"\\n\" or ws_needed and self.SPACE or \"\";\nend\n\nfunction Unparser:whitespaceIfNeeded(following, ws)\n\tif(self.prettyPrint or self.identCharsLookup[string.sub(following, 1, 1)]) then\n\t\treturn ws or self.SPACE;\n\tend\n\treturn \"\";\nend\n\nfunction Unparser:whitespaceIfNeeded2(leading, ws)\n\tif(self.prettyPrint or self.identCharsLookup[string.sub(leading, #leading, #leading)]) then\n\t\treturn ws or self.SPACE;\n\tend\n\treturn \"\";\nend\n\nfunction Unparser:optionalWhitespace(ws)\n\treturn self.prettyPrint and (ws or self.SPACE) or \"\";\nend\n\nfunction Unparser:whitespace(ws)\n\treturn self.SPACE or ws;\nend\n\nfunction Unparser:unparse(ast)\n\tif(ast.kind ~= AstKind.TopNode) then\n\t\tlogger:error(\"Unparser:unparse expects a TopNode as first argument\")\n\tend\n\t\n\treturn self:unparseBlock(ast.body);\nend\n\nfunction Unparser:unparseBlock(block, tabbing)\n\tlocal code = \"\";\n\t\n\tif(#block.statements < 1) then\n\t\treturn self:whitespace();\n\tend\n\t\n\tfor i, statement in ipairs(block.statements) do\n\t\tif(statement.kind ~= AstKind.NopStatement) then\n\t\t\tlocal statementCode = self:unparseStatement(statement, tabbing);\n\t\t\tif(not self.prettyPrint and #code > 0 and string.sub(statementCode, 1, 1) == \"(\") then\n\t\t\t\t-- This is so that the following works:\n\t\t\t\t-- print(\"Test\");(function() print(\"Test2\") end)();\n\t\t\t\tstatementCode = \";\" .. statementCode;\n\t\t\tend\n\t\t\tlocal ws = self:whitespaceIfNeeded2(code, self:whitespaceIfNeeded(statementCode, self:newline(true)));\n\t\t\tif i ~= 1 then\n\t\t\t\tcode = code .. ws;\n\t\t\tend\n\t\t\tif(self.prettyPrint) then\n\t\t\t\tstatementCode = statementCode .. \";\"\n\t\t\tend\n\t\t\tcode = code .. statementCode;\n\t\tend\n\tend\n\t\n\treturn code;\nend\n\nfunction Unparser:unparseStatement(statement, tabbing)\n\ttabbing = tabbing and tabbing + 1 or 0;\n\tlocal code = \"\";\n\t\n\tif(statement.kind == AstKind.ContinueStatement) then\n\t\tcode = \"continue\";\n\t\t\n\t-- Break Statement\n\telseif(statement.kind == AstKind.BreakStatement) then\n\t\tcode = \"break\";\n\t\t\n\t\t\n\t-- Do Statement\n\telseif(statement.kind == AstKind.DoStatement) then\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\tcode = \"do\" ..  self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t.. bodyCode .. self:newline(false)\n\t\t\t.. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\n\t-- While Statement\n\telseif(statement.kind == AstKind.WhileStatement) then\n\t\tlocal expressionCode = self:unparseExpression(statement.condition, tabbing);\n\t\t\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\t\n\t\t\n\t\tcode = \"while\" .. self:whitespaceIfNeeded(expressionCode) .. expressionCode .. self:whitespaceIfNeeded2(expressionCode) \n\t\t\t.. \"do\" .. self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t.. bodyCode .. self:newline(false)\n\t\t\t.. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\t\n\t-- Repeat Until Statement\n\telseif(statement.kind == AstKind.RepeatStatement) then\n\t\tlocal expressionCode = self:unparseExpression(statement.condition, tabbing);\n\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\n\n\t\tcode = \"repeat\" ..  self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t.. bodyCode\n\t\t\t.. self:whitespaceIfNeeded2(bodyCode, self:newline() .. self:tabs(tabbing, true)) .. \"until\" .. self:whitespaceIfNeeded(expressionCode) .. expressionCode;\n\n\t-- For Statement\n\telseif(statement.kind == AstKind.ForStatement) then\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\t\n\t\tcode = \"for\" .. self:whitespace() .. statement.scope:getVariableName(statement.id) .. self:optionalWhitespace() .. \"=\";\n\t\tcode = code .. self:optionalWhitespace() .. self:unparseExpression(statement.initialValue, tabbing) .. \",\";\n\t\tcode = code .. self:optionalWhitespace() .. self:unparseExpression(statement.finalValue, tabbing) .. \",\";\n\t\t\n\t\tlocal incrementByCode = statement.incrementBy and self:unparseExpression(statement.incrementBy, tabbing) or \"1\";\n\t\tcode = code .. self:optionalWhitespace() .. incrementByCode .. self:whitespaceIfNeeded2(incrementByCode)  .. \"do\" .. self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t.. bodyCode .. self:newline(false)\n\t\t\t.. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\n\t\t\n\t-- For In Statement\n\telseif(statement.kind == AstKind.ForInStatement) then\n\t\tcode = \"for\" .. self:whitespace();\n\t\t\n\t\tfor i, id in ipairs(statement.ids) do\n\t\t\tif(i ~= 1) then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\t\n\t\t\tcode = code .. statement.scope:getVariableName(id);\n\t\tend\n\t\t\n\t\tcode = code .. self:whitespace() .. \"in\";\n\t\t\n\t\tlocal exprcode = self:unparseExpression(statement.expressions[1], tabbing);\n\t\tcode = code .. self:whitespaceIfNeeded(exprcode) .. exprcode;\n\t\tfor i = 2, #statement.expressions, 1 do\n\t\t\texprcode = self:unparseExpression(statement.expressions[i], tabbing);\n\t\t\tcode = code .. \",\" .. self:optionalWhitespace() .. exprcode;\n\t\tend\n\t\t\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\tcode = code .. self:whitespaceIfNeeded2(code) .. \"do\" .. self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t.. bodyCode .. self:newline(false)\n\t\t\t.. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\n\t\t\n\t-- If Statement\n\telseif(statement.kind == AstKind.IfStatement) then\n\t\tlocal exprcode = self:unparseExpression(statement.condition, tabbing);\n\t\t\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\tcode = \"if\" .. self:whitespaceIfNeeded(exprcode) .. exprcode .. self:whitespaceIfNeeded2(exprcode) .. \"then\" .. self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t.. bodyCode;\n\t\t\n\t\tfor i, eif in ipairs(statement.elseifs) do\n\t\t\texprcode = self:unparseExpression(eif.condition, tabbing);\n\t\t\tbodyCode = self:unparseBlock(eif.body, tabbing);\n\t\t\tcode = code .. self:newline(false) .. self:whitespaceIfNeeded2(code, self:tabs(tabbing, true)) .. \"elseif\" .. self:whitespaceIfNeeded(exprcode) .. exprcode .. self:whitespaceIfNeeded2(exprcode) \n\t\t\t\t.. \"then\" .. self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t\t.. bodyCode;\n\t\tend\n\t\t\n\t\tif(statement.elsebody) then\n\t\t\tbodyCode = self:unparseBlock(statement.elsebody, tabbing);\n\t\t\tcode = code .. self:newline(false) .. self:whitespaceIfNeeded2(code, self:tabs(tabbing, true)) .. \"else\" .. self:whitespaceIfNeeded(bodyCode, self:newline(true))\n\t\t\t\t.. bodyCode;\n\t\tend\n\t\t\n\t\tcode = code .. self:newline(false) .. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\n\t\t\n\t-- Function Declaration\n\telseif(statement.kind == AstKind.FunctionDeclaration) then\n\t\tlocal funcname = statement.scope:getVariableName(statement.id);\n\t\tfor _, index in ipairs(statement.indices) do\n\t\t\tfuncname = funcname .. \".\" .. index;\n\t\tend\n\t\t\n\t\tcode = \"function\" .. self:whitespace() .. funcname .. \"(\";\n\t\t\n\t\tfor i, arg in ipairs(statement.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tif(arg.kind == AstKind.VarargExpression) then\n\t\t\t\tcode = code .. \"...\";\n\t\t\telse\n\t\t\t\tcode = code .. arg.scope:getVariableName(arg.id);\n\t\t\tend\n\t\tend\n\t\tcode = code .. \")\";\n\t\t\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\tcode = code .. self:newline(false) .. bodyCode .. self:newline(false) .. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\n\t\t\n\t-- Local Function Declaration\n\telseif(statement.kind == AstKind.LocalFunctionDeclaration) then\n\t\tlocal funcname = statement.scope:getVariableName(statement.id);\n\t\tcode = \"local\" ..  self:whitespace() .. \"function\" .. self:whitespace() .. funcname .. \"(\";\n\t\t\n\t\tfor i, arg in ipairs(statement.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tif(arg.kind == AstKind.VarargExpression) then\n\t\t\t\tcode = code .. \"...\";\n\t\t\telse\n\t\t\t\tcode = code .. arg.scope:getVariableName(arg.id);\n\t\t\tend\n\t\tend\n\t\tcode = code .. \")\";\n\n\t\tlocal bodyCode = self:unparseBlock(statement.body, tabbing);\n\t\tcode = code .. self:newline(false) .. bodyCode .. self:newline(false) .. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\t\n\t-- Local Variable Declaration\n\telseif(statement.kind == AstKind.LocalVariableDeclaration) then\n\t\tcode = \"local\" .. self:whitespace();\n\t\t\n\t\tfor i, id in ipairs(statement.ids) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. statement.scope:getVariableName(id);\n\t\tend\n\n\t\tif(#statement.expressions > 0) then\n\t\t\tcode = code .. self:optionalWhitespace() .. \"=\" .. self:optionalWhitespace();\n\t\t\tfor i, expr in ipairs(statement.expressions) do\n\t\t\t\tif i > 1 then\n\t\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\t\tend\n\t\t\t\tcode = code .. self:unparseExpression(expr, tabbing + 1);\n\t\t\tend\n\t\tend\n\t-- Function Call Statement\n\telseif(statement.kind == AstKind.FunctionCallStatement) then\n\t\tif not (statement.base.kind == AstKind.IndexExpression or statement.base.kind == AstKind.VariableExpression) then\n\t\t\tcode = \"(\" .. self:unparseExpression(statement.base, tabbing) .. \")\";\n\t\telse\n\t\t\tcode = self:unparseExpression(statement.base, tabbing);\n\t\tend\n\t\t\n\t\tcode = code .. \"(\";\n\t\t\n\t\tfor i, arg in ipairs(statement.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. self:unparseExpression(arg, tabbing);\n\t\tend\n\t\t\n\t\tcode = code .. \")\";\n\t\t\n\t-- Pass Self Function Call Statement\n\telseif(statement.kind == AstKind.PassSelfFunctionCallStatement) then\n\t\tif not (statement.base.kind == AstKind.IndexExpression or statement.base.kind == AstKind.VariableExpression) then\n\t\t\tcode = \"(\" .. self:unparseExpression(statement.base, tabbing) .. \")\";\n\t\telse\n\t\t\tcode = self:unparseExpression(statement.base, tabbing);\n\t\tend\n\n\t\tcode = code .. \":\" .. statement.passSelfFunctionName;\n\n\t\tcode = code .. \"(\";\n\n\t\tfor i, arg in ipairs(statement.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. self:unparseExpression(arg, tabbing);\n\t\tend\n\n\t\tcode = code .. \")\";\n\t\t\n\t\t\n\telseif(statement.kind == AstKind.AssignmentStatement) then\n\t\tfor i, primary_expr in ipairs(statement.lhs) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. self:unparseExpression(primary_expr, tabbing);\n\t\tend\n\t\t\n\t\tcode = code .. self:optionalWhitespace() .. \"=\" .. self:optionalWhitespace();\n\t\t\n\t\tfor i, expr in ipairs(statement.rhs) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. self:unparseExpression(expr, tabbing + 1);\n\t\tend\n\t\t\n\t-- Return Statement\n\telseif(statement.kind == AstKind.ReturnStatement) then\n\t\tcode = \"return\";\n\t\tif(#statement.args > 0) then\n\t\t\tlocal exprcode = self:unparseExpression(statement.args[1], tabbing);\n\t\t\tcode = code .. self:whitespaceIfNeeded(exprcode) .. exprcode;\n\t\t\tfor i = 2, #statement.args, 1 do\n\t\t\t\texprcode = self:unparseExpression(statement.args[i], tabbing);\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace() .. exprcode;\n\t\t\tend\n\t\tend\n\telseif self.luaVersion == LuaVersion.LuaU then\n\t\tlocal compoundOperators = {\n\t\t    [AstKind.CompoundAddStatement] = \"+=\",\n\t\t    [AstKind.CompoundSubStatement] = \"-=\",\n\t\t    [AstKind.CompoundMulStatement] = \"*=\",\n\t\t    [AstKind.CompoundDivStatement] = \"/=\",\n\t\t    [AstKind.CompoundModStatement] = \"%=\",\n\t\t    [AstKind.CompoundPowStatement] = \"^=\",\n\t\t    [AstKind.CompoundConcatStatement] = \"..=\",\n\t\t}\n\t\t\n\t\tlocal operator = compoundOperators[statement.kind]\n\t\tif operator then\n\t\t    code = code .. self:unparseExpression(statement.lhs, tabbing) .. self:optionalWhitespace() .. operator .. self:optionalWhitespace() .. self:unparseExpression(statement.rhs, tabbing)\n\t\telse\n\t\t    logger:error(string.format(\"\\\"%s\\\" is not a valid unparseable statement in %s!\", statement.kind, self.luaVersion))\n\t\tend\n\tend\n\t\n\treturn self:tabs(tabbing, false) .. code;\nend\n\nlocal function randomTrueNode()\n\tlocal op = math.random(1, 2);\n\tif(op == 1) then\n\t\t-- Less than\n\t\tlocal a = math.random(1, 9)\n\t\tlocal b = math.random(0, a - 1);\n\t\treturn tostring(a) .. \">\" .. tostring(b);\n\telse\n\t\t-- Greater than\n\t\tlocal a = math.random(1, 9)\n\t\tlocal b = math.random(0, a - 1);\n\t\treturn tostring(b) .. \"<\" .. tostring(a);\n\tend\nend\n\nlocal function randomFalseNode()\n\tlocal op = math.random(1, 2);\n\tif(op == 1) then\n\t\t-- Less than\n\t\tlocal a = math.random(1, 9)\n\t\tlocal b = math.random(0, a - 1);\n\t\treturn tostring(b) .. \">\" .. tostring(a);\n\telse\n\t\t-- Greater than\n\t\tlocal a = math.random(1, 9)\n\t\tlocal b = math.random(0, a - 1);\n\t\treturn tostring(a) .. \"<\" .. tostring(b);\n\tend\nend\n\nfunction Unparser:unparseExpression(expression, tabbing)\n\tlocal code = \"\";\n\t\n\tif(expression.kind == AstKind.BooleanExpression) then\n\t\tif(expression.value) then\n\t\t\treturn \"true\";\n\t\telse\n\t\t\treturn \"false\";\n\t\tend\n\tend\n\t\n\tif(expression.kind == AstKind.NumberExpression) then\n\t\tlocal str = tostring(expression.value);\n\t\tif(str == \"inf\") then\n\t\t\treturn \"2e1024\"\n\t\tend\n\t\tif(str == \"-inf\") then\n\t\t\treturn \"-2e1024\"\n\t\tend\n\t\tif(str:sub(1, 2) == \"0.\") then\n\t\t\tstr = str:sub(2);\n\t\tend\n\t\treturn str;\n\tend\n\t\n\tif(expression.kind == AstKind.VariableExpression or expression.kind == AstKind.AssignmentVariable) then\n\t\t\treturn expression.scope:getVariableName(expression.id);\n\tend\n\t\n\tif(expression.kind == AstKind.StringExpression) then\n\t\treturn \"\\\"\" .. escapeString(expression.value) .. \"\\\"\";\n\tend\n\t\n\tif(expression.kind == AstKind.NilExpression) then\n\t\treturn \"nil\";\n\tend\n\t\n\tif(expression.kind == AstKind.VarargExpression) then\n\t\treturn \"...\";\n\tend\n\t\n\tlocal k = AstKind.OrExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\treturn lhs .. self:whitespaceIfNeeded2(lhs) .. \"or\" .. self:whitespaceIfNeeded(rhs) .. rhs;\n\tend\n\t\n\tk = AstKind.AndExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\t\t\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\t\t\n\t\treturn lhs .. self:whitespaceIfNeeded2(lhs) .. \"and\" .. self:whitespaceIfNeeded(rhs) .. rhs;\n\tend\n\t\n\tk = AstKind.LessThanExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"<\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.GreaterThanExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \">\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.LessThanOrEqualsExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"<=\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.GreaterThanOrEqualsExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \">=\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.NotEqualsExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"~=\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.EqualsExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"==\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.StrCatExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\tif(self.numberCharsLookup[string.sub(lhs, #lhs, #lhs)]) then\n\t\t\tlhs = lhs .. \" \";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"..\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.AddExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"+\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.SubExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\tif string.sub(rhs, 1, 1) == \"-\" then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend \n\n\t\treturn lhs .. self:optionalWhitespace() .. \"-\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.MulExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"*\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.DivExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"/\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.ModExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"%\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\tk = AstKind.PowExpression;\n\tif(expression.kind == k) then\n\t\tlocal lhs = self:unparseExpression(expression.lhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.lhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\tlhs = \"(\" .. lhs .. \")\";\n\t\tend\n\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn lhs .. self:optionalWhitespace() .. \"^\" .. self:optionalWhitespace() .. rhs;\n\tend\n\t\n\t-- Unary Expressions\n\tk = AstKind.NotExpression;\n\tif(expression.kind == k) then\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn \"not\" .. self:whitespaceIfNeeded(rhs) .. rhs;\n\tend\n\t\n\tk = AstKind.NegateExpression;\n\tif(expression.kind == k) then\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\tif string.sub(rhs, 1, 1) == \"-\" then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend \n\n\t\treturn \"-\" .. rhs;\n\tend\n\t\n\tk = AstKind.LenExpression;\n\tif(expression.kind == k) then\n\t\tlocal rhs = self:unparseExpression(expression.rhs, tabbing);\n\t\tif(Ast.astKindExpressionToNumber(expression.rhs.kind) >= Ast.astKindExpressionToNumber(k)) then\n\t\t\trhs = \"(\" .. rhs .. \")\";\n\t\tend\n\n\t\treturn \"#\" .. rhs;\n\tend\n\t\n\tk = AstKind.IndexExpression;\n\tif(expression.kind == k or expression.kind == AstKind.AssignmentIndexing) then\n\t\tlocal base = self:unparseExpression(expression.base, tabbing);\n\t\tif(expression.base.kind == AstKind.VarargExpression or Ast.astKindExpressionToNumber(expression.base.kind) > Ast.astKindExpressionToNumber(k)) then\n\t\t\tbase = \"(\" .. base .. \")\";\n\t\tend\n\t\t\n\t\t-- Identifier Indexing e.g: x.y instead of x[\"y\"];\n\t\tif(expression.index.kind == AstKind.StringExpression and self:isValidIdentifier(expression.index.value)) then\n\t\t\treturn base .. \".\" .. expression.index.value;\n\t\tend\n\t\t\n\t\t-- Index never needs parens\n\t\tlocal index = self:unparseExpression(expression.index, tabbing);\n\t\treturn base .. \"[\" .. index .. \"]\";\n\tend\n\t\n\tk = AstKind.FunctionCallExpression;\n\tif(expression.kind == k) then\n\t\tif not (expression.base.kind == AstKind.IndexExpression or expression.base.kind == AstKind.VariableExpression) then\n\t\t\tcode = \"(\" .. self:unparseExpression(expression.base, tabbing) .. \")\";\n\t\telse\n\t\t\tcode = self:unparseExpression(expression.base, tabbing);\n\t\tend\n\n\t\tcode = code .. \"(\";\n\n\t\tfor i, arg in ipairs(expression.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. self:unparseExpression(arg, tabbing);\n\t\tend\n\n\t\tcode = code .. \")\";\n\t\treturn code;\n\tend\n\t\n\t\n\tk = AstKind.PassSelfFunctionCallExpression;\n\tif(expression.kind == k) then\n\t\tif not (expression.base.kind == AstKind.IndexExpression or expression.base.kind == AstKind.VariableExpression) then\n\t\t\tcode = \"(\" .. self:unparseExpression(expression.base, tabbing) .. \")\";\n\t\telse\n\t\t\tcode = self:unparseExpression(expression.base, tabbing);\n\t\tend\n\n\t\tcode = code .. \":\" .. expression.passSelfFunctionName;\n\n\t\tcode = code .. \"(\";\n\n\t\tfor i, arg in ipairs(expression.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tcode = code .. self:unparseExpression(arg, tabbing);\n\t\tend\n\n\t\tcode = code .. \")\";\n\t\treturn code;\n\tend\n\t\n\tk = AstKind.FunctionLiteralExpression;\n\tif(expression.kind == k) then\n\t\tcode = \"function\" .. \"(\";\n\n\t\tfor i, arg in ipairs(expression.args) do\n\t\t\tif i > 1 then\n\t\t\t\tcode = code .. \",\" .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tif(arg.kind == AstKind.VarargExpression) then\n\t\t\t\tcode = code .. \"...\";\n\t\t\telse\n\t\t\t\tcode = code .. arg.scope:getVariableName(arg.id);\n\t\t\tend\n\t\tend\n\t\tcode = code .. \")\";\n\n\t\tlocal bodyCode = self:unparseBlock(expression.body, tabbing);\n\t\tcode = code .. self:newline(false) .. bodyCode .. self:newline(false) .. self:whitespaceIfNeeded2(bodyCode, self:tabs(tabbing, true)) .. \"end\";\n\t\treturn code;\n\tend\n\t\n\tk = AstKind.TableConstructorExpression;\n\tif(expression.kind == k) then\n\t\tif(#expression.entries == 0) then return \"{}\" end;\n\n\t\tlocal inlineTable = #expression.entries <= 3;\n\t\tlocal tableTabbing = tabbing + 1;\n\t\t\n\t\tcode = \"{\";\n\t\tif inlineTable then\n\t\t\tcode = code .. self:optionalWhitespace();\n\t\telse\n\t\t\tcode = code .. self:optionalWhitespace(self:newline() .. self:tabs(tableTabbing));\n\t\tend\n\t\t\n\t\tlocal p = false;\n\t\tfor i, entry in ipairs(expression.entries) do\n\t\t\tp = true;\n\t\t\tlocal sep = self.prettyPrint and \",\" or (math.random(1, 2) == 1 and \",\" or \";\");\n\t\t\tif i > 1 and not inlineTable then\n\t\t\t\tcode = code .. sep .. self:optionalWhitespace(self:newline() .. self:tabs(tableTabbing));\n\t\t\telseif i > 1 then\n\t\t\t\tcode = code .. sep .. self:optionalWhitespace();\n\t\t\tend\n\t\t\tif(entry.kind == AstKind.KeyedTableEntry) then\n\t\t\t\tif(entry.key.kind == AstKind.StringExpression and self:isValidIdentifier(entry.key.value)) then\n\t\t\t\t\tcode = code .. entry.key.value;\n\t\t\t\telse\n\t\t\t\t\tcode = code .. \"[\" .. self:unparseExpression(entry.key, tableTabbing) .. \"]\";\n\t\t\t\tend\n\t\t\t\tcode = code .. self:optionalWhitespace() .. \"=\" .. self:optionalWhitespace() .. self:unparseExpression(entry.value, tableTabbing);\n\t\t\telse\n\t\t\t\tcode = code .. self:unparseExpression(entry.value, tableTabbing);\n\t\t\tend\n\t\tend\n\n\t\tif inlineTable then\n\t\t\treturn code .. self:optionalWhitespace() .. \"}\";\n\t\tend\n\t\t\n\t\treturn code .. self:optionalWhitespace((p and \",\" or \"\") .. self:newline() .. self:tabs(tabbing)) .. \"}\";\n\tend\n\n\tif (self.luaVersion == LuaVersion.LuaU) then\n\t\tk = AstKind.IfElseExpression\n\t\tif(expression.kind == k) then\n\t\t\tcode = \"if \";\n\n\t\t\tcode = code .. self:unparseExpression(expression.condition);\n\t\t\tcode = code .. \" then \";\n\t\t\tcode = code .. self:unparseExpression(expression.true_value);\n\t\t\tcode = code .. \" else \";\n\t\t\tcode = code .. self:unparseExpression(expression.false_value);\n\n\t\t\treturn code\n\t\tend\n\tend\n\n\tlogger:error(string.format(\"\\\"%s\\\" is not a valid unparseable expression\", expression.kind));\nend\n\nreturn Unparser\n",
  "prometheus.util": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- util.lua\n-- This file Provides some utility functions\n\nlocal logger = require(\"logger\");\nlocal bit32  = require(\"prometheus.bit\").bit32;\n\nlocal MAX_UNPACK_COUNT = 195;\n\nlocal function lookupify(tb)\n\tlocal tb2 = {};\n\tfor _, v in ipairs(tb) do\n\t\ttb2[v] = true\n\tend\n\treturn tb2\nend\n\nlocal function unlookupify(tb)\n\tlocal tb2 = {};\n\tfor v, _ in pairs(tb) do\n\t\ttable.insert(tb2, v);\n\tend\n\treturn tb2;\nend\n\nlocal function escape(str)\n\treturn str:gsub(\".\", function(char)\n\t\tif char:match(\"[^ %-~\\n\\t\\a\\b\\v\\r\\\"\\']\") then -- Check if non Printable ASCII Character\n\t\t\treturn string.format(\"\\\\%03d\", string.byte(char))\n\t\tend\n\t\tif(char == \"\\\\\") then\n\t\t\treturn \"\\\\\\\\\";\n\t\tend\n\t\tif(char == \"\\n\") then\n\t\t\treturn \"\\\\n\";\n\t\tend\n\t\tif(char == \"\\r\") then\n\t\t\treturn \"\\\\r\";\n\t\tend\n\t\tif(char == \"\\t\") then\n\t\t\treturn \"\\\\t\";\n\t\tend\n\t\tif(char == \"\\a\") then\n\t\t\treturn \"\\\\a\";\n\t\tend\n\t\tif(char == \"\\b\") then\n\t\t\treturn \"\\\\b\";\n\t\tend\n\t\tif(char == \"\\v\") then\n\t\t\treturn \"\\\\v\";\n\t\tend\n\t\tif(char == \"\\\"\") then\n\t\t\treturn \"\\\\\\\"\";\n\t\tend\n\t\tif(char == \"\\'\") then\n\t\t\treturn \"\\\\\\'\";\n\t\tend\n\t\treturn char;\n\tend)\nend\n\nlocal function chararray(str)\n\tlocal tb = {};\n\tfor i = 1, str:len(), 1 do\n\t\ttable.insert(tb, str:sub(i, i));\n\tend\n\treturn tb;\nend\n\nlocal function keys(tb)\n\tlocal keyset={}\n\tlocal n=0\n\tfor k,v in pairs(tb) do\n\t\tn=n+1\n\t\tkeyset[n]=k\n\tend\n\treturn keyset\nend\n\nlocal utf8char;\ndo\n\tlocal string_char = string.char\n\tfunction utf8char(cp)\n\t  if cp < 128 then\n\t\treturn string_char(cp)\n\t  end\n\t  local suffix = cp % 64\n\t  local c4 = 128 + suffix\n\t  cp = (cp - suffix) / 64\n\t  if cp < 32 then\n\t\treturn string_char(192 + cp, c4)\n\t  end\n\t  suffix = cp % 64\n\t  local c3 = 128 + suffix\n\t  cp = (cp - suffix) / 64\n\t  if cp < 16 then\n\t\treturn string_char(224 + cp, c3, c4)\n\t  end\n\t  suffix = cp % 64\n\t  cp = (cp - suffix) / 64\n\t  return string_char(240 + cp, 128 + suffix, c3, c4)\n\tend\n  end\n\nlocal function shuffle(tb)\n\tfor i = #tb, 2, -1 do\n\t\tlocal j = math.random(i)\n\t\ttb[i], tb[j] = tb[j], tb[i]\n\tend\n\treturn tb\nend\nlocal function shuffle_string(str)\n    local len = #str\n    local t = {}\n    for i = 1, len do\n        t[i] = string.sub(str, i, i)\n    end\n    for i = 1, len do\n        local j = math.random(i, len)\n        t[i], t[j] = t[j], t[i]\n    end\n    return table.concat(t)\nend\n\nlocal function readDouble(bytes) \n\tlocal sign = 1\n\tlocal mantissa = bytes[2] % 2^4\n\tfor i = 3, 8 do\n\t\tmantissa = mantissa * 256 + bytes[i]\n\tend\n\tif bytes[1] > 127 then sign = -1 end\n\tlocal exponent = (bytes[1] % 128) * 2^4 + math.floor(bytes[2] / 2^4)\n\n\tif exponent == 0 then\n\t\treturn 0\n\tend\n\tmantissa = (math.ldexp(mantissa, -52) + 1) * sign\n\treturn math.ldexp(mantissa, exponent - 1023)\nend\n\nlocal function writeDouble(num)\n\tlocal bytes = {0,0,0,0, 0,0,0,0}\n\tif num == 0 then\n\t\treturn bytes\n\tend\n\tlocal anum = math.abs(num)\n\n\tlocal mantissa, exponent = math.frexp(anum)\n\texponent = exponent - 1\n\tmantissa = mantissa * 2 - 1\n\tlocal sign = num ~= anum and 128 or 0\n\texponent = exponent + 1023\n\n\tbytes[1] = sign + math.floor(exponent / 2^4)\n\tmantissa = mantissa * 2^4\n\tlocal currentmantissa = math.floor(mantissa)\n\tmantissa = mantissa - currentmantissa\n\tbytes[2] = (exponent % 2^4) * 2^4 + currentmantissa\n\tfor i= 3, 8 do\n\t\tmantissa = mantissa * 2^8\n\t\tcurrentmantissa = math.floor(mantissa)\n\t\tmantissa = mantissa - currentmantissa\n\t\tbytes[i] = currentmantissa\n\tend\n\treturn bytes\nend\n\nlocal function writeU16(u16)\n\tif (u16 < 0 or u16 > 65535) then\n\t\tlogger:error(string.format(\"u16 out of bounds: %d\", u16));\n\tend\n\tlocal lower = bit32.band(u16, 255);\n\tlocal upper = bit32.rshift(u16, 8);\n\treturn {lower, upper}\nend\n\nlocal function readU16(arr)\n\treturn bit32.bor(arr[1], bit32.lshift(arr[2], 8));\nend\n\nlocal function writeU24(u24)\n\tif(u24 < 0 or u24 > 16777215) then\n\t\tlogger:error(string.format(\"u24 out of bounds: %d\", u24));\n\tend\n\t\n\tlocal arr = {};\n\tfor i = 0, 2 do\n\t\tarr[i + 1] = bit32.band(bit32.rshift(u24, 8 * i), 255);\n\tend\n\treturn arr;\nend\n\nlocal function readU24(arr)\n\tlocal val = 0;\n\n\tfor i = 0, 2 do\n\t\tval = bit32.bor(val, bit32.lshift(arr[i + 1], 8 * i));\n\tend\n\n\treturn val;\nend\n\nlocal function writeU32(u32)\n\tif(u32 < 0 or u32 > 4294967295) then\n\t\tlogger:error(string.format(\"u32 out of bounds: %d\", u32));\n\tend\n\n\tlocal arr = {};\n\tfor i = 0, 3 do\n\t\tarr[i + 1] = bit32.band(bit32.rshift(u32, 8 * i), 255);\n\tend\n\treturn arr;\nend\n\nlocal function readU32(arr)\n\tlocal val = 0;\n\n\tfor i = 0, 3 do\n\t\tval = bit32.bor(val, bit32.lshift(arr[i + 1], 8 * i));\n\tend\n\n\treturn val;\nend\n\nlocal function bytesToString(arr)\n\tlocal length = arr.n or #arr;\n\n\tif length < MAX_UNPACK_COUNT then\n\t\treturn string.char(table.unpack(arr))\n\tend\n\n\tlocal str = \"\";\n\tlocal overflow = length % MAX_UNPACK_COUNT;\n\n\tfor i = 1, (#arr - overflow) / MAX_UNPACK_COUNT do\n\t\tstr = str .. string.char(table.unpack(arr, (i - 1) * MAX_UNPACK_COUNT + 1, i * MAX_UNPACK_COUNT));\n\tend\n\n\treturn str..(overflow > 0 and string.char(table.unpack(arr, length - overflow + 1, length)) or \"\");\nend\n\nlocal function isNaN(n)\n\treturn type(n) == \"number\" and n ~= n;\nend\n\nlocal function isInt(n)\n\treturn math.floor(n) == n;\nend\n\nlocal function isU32(n)\n\treturn n >= 0 and n <= 4294967295 and isInt(n);\nend\n\nlocal function toBits(num)\n    -- returns a table of bits, least significant first.\n    local t={} -- will contain the bits\n\tlocal rest;\n    while num>0 do\n        rest=math.fmod(num,2)\n        t[#t+1]=rest\n        num=(num-rest)/2\n    end\n    return t\nend\n\n\nlocal function readonly(obj)\n\tlocal r = newproxy(true);\n\tgetmetatable(r).__index = obj;\n\treturn r;\nend\n\nreturn {\n\tlookupify = lookupify,\n\tunlookupify = unlookupify,\n\tescape = escape,\n\tchararray = chararray,\n\tkeys = keys,\n\tshuffle = shuffle,\n\tshuffle_string = shuffle_string,\n\treadDouble = readDouble,\n\twriteDouble = writeDouble,\n\treadU16 = readU16,\n\twriteU16 = writeU16,\n\treadU32 = readU32,\n\twriteU32 = writeU32,\n\treadU24 = readU24,\n\twriteU24 = writeU24,\n\tisNaN = isNaN,\n\tisU32 = isU32,\n\tisInt = isInt,\n\tutf8char = utf8char,\n\ttoBits = toBits,\n\tbytesToString = bytesToString,\n\treadonly = readonly,\n}\n",
  "prometheus.visitast": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- util.lua\n-- This file Provides a Utility function for visiting each node of an ast\n\nlocal Ast = require(\"prometheus.ast\");\nlocal util = require(\"prometheus.util\");\n\nlocal AstKind = Ast.AstKind;\nlocal lookupify = util.lookupify;\n\nlocal visitAst, visitBlock, visitStatement, visitExpression;\n\nfunction visitAst(ast, previsit, postvisit, data)\n\tast.isAst = true;\n\tdata = data or {};\n\tdata.scopeStack = {};\n\tdata.functionData = {\n\t\tdepth = 0;\n\t\tscope = ast.body.scope;\n\t\tnode = ast;\n\t};\n\tdata.scope = ast.globalScope;\n\tdata.globalScope = ast.globalScope;\n\tif(type(previsit) == \"function\") then\n\t\tlocal node, skip = previsit(ast, data);\n\t\tast = node or ast;\n\t\tif skip then\n\t\t\treturn ast;\n\t\tend\n\tend\n\t\n\t-- Is Function Block because global scope is treated like a Function\n\tvisitBlock(ast.body, previsit, postvisit, data, true);\n\t\n\tif(type(postvisit) == \"function\") then\n\t\tast = postvisit(ast, data) or ast;\n\tend\n\treturn ast;\nend\n\nlocal compundStats = lookupify{\n\tAstKind.CompoundAddStatement,\n\tAstKind.CompoundSubStatement,\n\tAstKind.CompoundMulStatement,\n\tAstKind.CompoundDivStatement,\n\tAstKind.CompoundModStatement,\n\tAstKind.CompoundPowStatement,\n\tAstKind.CompoundConcatStatement,\n}\n\nfunction visitBlock(block, previsit, postvisit, data, isFunctionBlock)\n\tblock.isBlock = true;\n\tblock.isFunctionBlock = isFunctionBlock or false;\n\tdata.scope = block.scope;\n\tlocal parentBlockData = data.blockData;\n\tdata.blockData = {};\n\ttable.insert(data.scopeStack, block.scope);\n\tif(type(previsit) == \"function\") then\n\t\tlocal node, skip = previsit(block, data);\n\t\tblock = node or block;\n\t\tif skip then\n\t\t\tdata.scope = table.remove(data.scopeStack);\n\t\t\treturn block\n\t\tend\n\tend\n\t\n\tlocal i = 1;\n\twhile i <= #block.statements do\n\t\tlocal statement = table.remove(block.statements, i);\n\t\ti = i - 1;\n\t\tlocal returnedStatements = {visitStatement(statement, previsit, postvisit, data)};\n\t\tfor j, statement in ipairs(returnedStatements) do\n\t\t\ti = i + 1;\n\t\t\ttable.insert(block.statements, i, statement);\n\t\tend\n\t\ti = i + 1;\n\tend\n\n\tif(type(postvisit) == \"function\") then\n\t\tblock = postvisit(block, data) or block;\n\tend\n\tdata.scope = table.remove(data.scopeStack);\n\tdata.blockData = parentBlockData;\n\treturn block;\nend\n\nfunction visitStatement(statement, previsit, postvisit, data)\n\tstatement.isStatement = true;\n\tif(type(previsit) == \"function\") then\n\t\tlocal node, skip = previsit(statement, data);\n\t\tstatement = node or statement;\n\t\tif skip then\n\t\t\treturn statement;\n\t\tend\n\tend\n\t\n\t-- Visit Child Nodes of Statement\n\tif(statement.kind == AstKind.ReturnStatement) then\n\t\tfor i, expression in ipairs(statement.args) do\n\t\t\tstatement.args[i] = visitExpression(expression, previsit, postvisit, data);\n\t\tend\n\telseif(statement.kind == AstKind.PassSelfFunctionCallStatement or statement.kind == AstKind.FunctionCallStatement) then\n\t\tstatement.base = visitExpression(statement.base, previsit, postvisit, data);\n\t\tfor i, expression in ipairs(statement.args) do\n\t\t\tstatement.args[i] = visitExpression(expression, previsit, postvisit, data);\n\t\tend\n\telseif(statement.kind == AstKind.AssignmentStatement) then\n\t\tfor i, primaryExpr in ipairs(statement.lhs) do\n\t\t\tstatement.lhs[i] = visitExpression(primaryExpr, previsit, postvisit, data);\n\t\tend\n\t\tfor i, expression in ipairs(statement.rhs) do\n\t\t\tstatement.rhs[i] = visitExpression(expression, previsit, postvisit, data);\n\t\tend\n\telseif(statement.kind == AstKind.FunctionDeclaration or statement.kind == AstKind.LocalFunctionDeclaration) then\n\t\tlocal parentFunctionData = data.functionData;\n\t\tdata.functionData = {\n\t\t\tdepth = parentFunctionData.depth + 1;\n\t\t\tscope = statement.body.scope;\n\t\t\tnode = statement;\n\t\t};\n\t\tstatement.body = visitBlock(statement.body, previsit, postvisit, data, true);\n\t\tdata.functionData = parentFunctionData;\n\telseif(statement.kind == AstKind.DoStatement) then\n\t\tstatement.body = visitBlock(statement.body, previsit, postvisit, data, false);\n\telseif(statement.kind == AstKind.WhileStatement) then\n\t\tstatement.condition = visitExpression(statement.condition, previsit, postvisit, data);\n\t\tstatement.body = visitBlock(statement.body, previsit, postvisit, data, false);\n\telseif(statement.kind == AstKind.RepeatStatement) then\n\t\tstatement.body = visitBlock(statement.body, previsit, postvisit, data);\n\t\tstatement.condition = visitExpression(statement.condition, previsit, postvisit, data);\n\telseif(statement.kind == AstKind.ForStatement) then\n\t\tstatement.initialValue = visitExpression(statement.initialValue, previsit, postvisit, data);\n\t\tstatement.finalValue = visitExpression(statement.finalValue, previsit, postvisit, data);\n\t\tstatement.incrementBy = visitExpression(statement.incrementBy, previsit, postvisit, data);\n\t\tstatement.body = visitBlock(statement.body, previsit, postvisit, data, false);\n\telseif(statement.kind == AstKind.ForInStatement) then\n\t\tfor i, expression in ipairs(statement.expressions) do\n\t\t\tstatement.expressions[i] = visitExpression(expression, previsit, postvisit, data);\n\t\tend\n\t\tvisitBlock(statement.body, previsit, postvisit, data, false);\n\telseif(statement.kind == AstKind.IfStatement) then\n\t\tstatement.condition = visitExpression(statement.condition, previsit, postvisit, data);\n\t\tstatement.body = visitBlock(statement.body, previsit, postvisit, data, false);\n\t\tfor i, eif in ipairs(statement.elseifs) do\n\t\t\teif.condition = visitExpression(eif.condition, previsit, postvisit, data);\n\t\t\teif.body = visitBlock(eif.body, previsit, postvisit, data, false);\n\t\tend\n\t\tif(statement.elsebody) then\n\t\t\tstatement.elsebody = visitBlock(statement.elsebody, previsit, postvisit, data, false);\n\t\tend\n\telseif(statement.kind == AstKind.LocalVariableDeclaration) then\n\t\tfor i, expression in ipairs(statement.expressions) do\n\t\t\tstatement.expressions[i] = visitExpression(expression, previsit, postvisit, data);\n\t\tend\n\telseif compundStats[statement.kind] then\n\t\tstatement.lhs = visitExpression(statement.lhs, previsit, postvisit, data);\n\t\tstatement.rhs = visitExpression(statement.rhs, previsit, postvisit, data);\n\tend\n\n\tif(type(postvisit) == \"function\") then\n\t\tlocal statements = {postvisit(statement, data)};\n\t\tif #statements > 0 then\n\t\t\treturn unpack(statements);\n\t\tend\n\tend\n\t\n\treturn statement;\nend\n\nlocal binaryExpressions = lookupify{\n\tAstKind.OrExpression,\n\tAstKind.AndExpression,\n\tAstKind.LessThanExpression,\n\tAstKind.GreaterThanExpression,\n\tAstKind.LessThanOrEqualsExpression,\n\tAstKind.GreaterThanOrEqualsExpression,\n\tAstKind.NotEqualsExpression,\n\tAstKind.EqualsExpression,\n\tAstKind.StrCatExpression,\n\tAstKind.AddExpression,\n\tAstKind.SubExpression,\n\tAstKind.MulExpression,\n\tAstKind.DivExpression,\n\tAstKind.ModExpression,\n\tAstKind.PowExpression,\n}\nfunction visitExpression(expression, previsit, postvisit, data)\n\texpression.isExpression = true;\n\tif(type(previsit) == \"function\") then\n\t\tlocal node, skip = previsit(expression, data);\n\t\texpression = node or expression;\n\t\tif skip then\n\t\t\treturn expression;\n\t\tend\n\tend\n\t\n\tif(binaryExpressions[expression.kind]) then\n\t\texpression.lhs = visitExpression(expression.lhs, previsit, postvisit, data);\n\t\texpression.rhs = visitExpression(expression.rhs, previsit, postvisit, data);\n\tend\n\t\n\tif(expression.kind == AstKind.NotExpression or expression.kind == AstKind.NegateExpression or expression.kind == AstKind.LenExpression) then\n\t\texpression.rhs = visitExpression(expression.rhs, previsit, postvisit, data);\n\tend\n\t\n\tif(expression.kind == AstKind.PassSelfFunctionCallExpression or expression.kind == AstKind.FunctionCallExpression) then\n\t\texpression.base = visitExpression(expression.base, previsit, postvisit, data);\n\t\tfor i, arg in ipairs(expression.args) do\n\t\t\texpression.args[i] = visitExpression(arg, previsit, postvisit, data);\n\t\tend\n\tend\n\t\n\tif(expression.kind == AstKind.FunctionLiteralExpression) then\n\t\tlocal parentFunctionData = data.functionData;\n\t\tdata.functionData = {\n\t\t\tdepth = parentFunctionData.depth + 1;\n\t\t\tscope = expression.body.scope;\n\t\t\tnode = expression;\n\t\t};\n\t\texpression.body = visitBlock(expression.body, previsit, postvisit, data, true);\n\t\tdata.functionData = parentFunctionData;\n\tend\n\t\n\tif(expression.kind == AstKind.TableConstructorExpression) then\n\t\tfor i, entry in ipairs(expression.entries) do\n\t\t\tif entry.kind == AstKind.KeyedTableEntry then\n\t\t\t\tentry.key = visitExpression(entry.key, previsit, postvisit, data);\n\t\t\tend\n\t\t\tentry.value = visitExpression(entry.value, previsit, postvisit, data);\n\t\tend\n\tend\n\t\n\tif(expression.kind == AstKind.IndexExpression or expression.kind == AstKind.AssignmentIndexing) then\n\t\texpression.base = visitExpression(expression.base, previsit, postvisit, data);\n\t\texpression.index = visitExpression(expression.index, previsit, postvisit, data);\n\tend\n\tif(expression.kind == AstKind.IfElseExpression) then\n\t\texpression.condition = visitExpression(expression.condition, previsit, postvisit, data);\n\t\texpression.true_expr = visitExpression(expression.true_expr, previsit, postvisit, data);\n\t\texpression.false_expr = visitExpression(expression.false_expr, previsit, postvisit, data);\n\tend\n\n\tif(type(postvisit) == \"function\") then\n\t\texpression = postvisit(expression, data) or expression;\n\tend\n\treturn expression;\nend\n\nreturn visitAst;\n",
  "prometheus.compiler.compiler": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- compiler.lua\n-- This Script contains the new Compiler\n\n-- The max Number of variables used as registers\nlocal MAX_REGS = 100;\nlocal MAX_REGS_MUL = 0;\n\nlocal Compiler = {};\n\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal logger = require(\"logger\");\nlocal util = require(\"prometheus.util\");\nlocal visitast = require(\"prometheus.visitast\")\nlocal randomStrings = require(\"prometheus.randomStrings\")\n\nlocal lookupify = util.lookupify;\nlocal AstKind = Ast.AstKind;\n\nlocal unpack = unpack or table.unpack;\n\nfunction Compiler:new()\n    local compiler = {\n        blocks = {};\n        registers = {\n        };\n        activeBlock = nil;\n        registersForVar = {};\n        usedRegisters = 0;\n        maxUsedRegister = 0;\n        registerVars = {};\n\n        VAR_REGISTER = newproxy(false);\n        RETURN_ALL = newproxy(false); \n        POS_REGISTER = newproxy(false);\n        RETURN_REGISTER = newproxy(false);\n        UPVALUE = newproxy(false);\n\n        BIN_OPS = lookupify{\n            AstKind.LessThanExpression,\n            AstKind.GreaterThanExpression,\n            AstKind.LessThanOrEqualsExpression,\n            AstKind.GreaterThanOrEqualsExpression,\n            AstKind.NotEqualsExpression,\n            AstKind.EqualsExpression,\n            AstKind.StrCatExpression,\n            AstKind.AddExpression,\n            AstKind.SubExpression,\n            AstKind.MulExpression,\n            AstKind.DivExpression,\n            AstKind.ModExpression,\n            AstKind.PowExpression,\n        };\n    };\n\n    setmetatable(compiler, self);\n    self.__index = self;\n\n    return compiler;\nend\n\nfunction Compiler:createBlock()\n    local id;\n    repeat\n        id = math.random(0, 2^24)\n    until not self.usedBlockIds[id];\n    self.usedBlockIds[id] = true;\n\n    local scope = Scope:new(self.containerFuncScope);\n    local block = {\n        id = id;\n        statements = {\n\n        };\n        scope = scope;\n        advanceToNextBlock = true;\n    };\n    table.insert(self.blocks, block);\n    return block;\nend\n\nfunction Compiler:setActiveBlock(block)\n    self.activeBlock = block;\nend\n\nfunction Compiler:addStatement(statement, writes, reads, usesUpvals)\n    if(self.activeBlock.advanceToNextBlock) then  \n        table.insert(self.activeBlock.statements, {\n            statement = statement,\n            writes = lookupify(writes),\n            reads = lookupify(reads),\n            usesUpvals = usesUpvals or false,\n        });\n    end\nend\n\nfunction Compiler:compile(ast)\n    self.blocks = {};\n    self.registers = {};\n    self.activeBlock = nil;\n    self.registersForVar = {};\n    self.scopeFunctionDepths = {};\n    self.maxUsedRegister = 0;\n    self.usedRegisters = 0;\n    self.registerVars = {};\n    self.usedBlockIds = {};\n\n    self.upvalVars = {};\n    self.registerUsageStack = {};\n\n    self.upvalsProxyLenReturn = math.random(-2^22, 2^22);\n\n    local newGlobalScope = Scope:newGlobal();\n    local psc = Scope:new(newGlobalScope, nil);\n\n    local _, getfenvVar = newGlobalScope:resolve(\"getfenv\");\n    local _, tableVar  = newGlobalScope:resolve(\"table\");\n    local _, unpackVar = newGlobalScope:resolve(\"unpack\");\n    local _, envVar = newGlobalScope:resolve(\"_ENV\");\n    local _, newproxyVar = newGlobalScope:resolve(\"newproxy\");\n    local _, setmetatableVar = newGlobalScope:resolve(\"setmetatable\");\n    local _, getmetatableVar = newGlobalScope:resolve(\"getmetatable\");\n    local _, selectVar = newGlobalScope:resolve(\"select\");\n    \n    psc:addReferenceToHigherScope(newGlobalScope, getfenvVar, 2);\n    psc:addReferenceToHigherScope(newGlobalScope, tableVar);\n    psc:addReferenceToHigherScope(newGlobalScope, unpackVar);\n    psc:addReferenceToHigherScope(newGlobalScope, envVar);\n    psc:addReferenceToHigherScope(newGlobalScope, newproxyVar);\n    psc:addReferenceToHigherScope(newGlobalScope, setmetatableVar);\n    psc:addReferenceToHigherScope(newGlobalScope, getmetatableVar);\n\n    self.scope = Scope:new(psc);\n    self.envVar = self.scope:addVariable();\n    self.containerFuncVar = self.scope:addVariable();\n    self.unpackVar = self.scope:addVariable();\n    self.newproxyVar = self.scope:addVariable();\n    self.setmetatableVar = self.scope:addVariable();\n    self.getmetatableVar = self.scope:addVariable();\n    self.selectVar = self.scope:addVariable();\n\n    local argVar = self.scope:addVariable();\n\n    self.containerFuncScope = Scope:new(self.scope);\n    self.whileScope = Scope:new(self.containerFuncScope);\n\n    self.posVar = self.containerFuncScope:addVariable();\n    self.argsVar = self.containerFuncScope:addVariable();\n    self.currentUpvaluesVar = self.containerFuncScope:addVariable();\n    self.detectGcCollectVar = self.containerFuncScope:addVariable();\n    self.returnVar  = self.containerFuncScope:addVariable();\n\n    -- Upvalues Handling\n    self.upvaluesTable = self.scope:addVariable();\n    self.upvaluesReferenceCountsTable = self.scope:addVariable();\n    self.allocUpvalFunction = self.scope:addVariable();\n    self.currentUpvalId = self.scope:addVariable();\n\n    -- Gc Handling for Upvalues\n    self.upvaluesProxyFunctionVar = self.scope:addVariable();\n    self.upvaluesGcFunctionVar = self.scope:addVariable();\n    self.freeUpvalueFunc = self.scope:addVariable();\n\n    self.createClosureVars = {};\n    self.createVarargClosureVar = self.scope:addVariable();\n    local createClosureScope = Scope:new(self.scope);\n    local createClosurePosArg = createClosureScope:addVariable();\n    local createClosureUpvalsArg = createClosureScope:addVariable();\n    local createClosureProxyObject = createClosureScope:addVariable();\n    local createClosureFuncVar = createClosureScope:addVariable();\n\n    local createClosureSubScope = Scope:new(createClosureScope);\n\n    local upvalEntries = {};\n    local upvalueIds   = {};\n    self.getUpvalueId = function(self, scope, id)\n        local expression;\n        local scopeFuncDepth = self.scopeFunctionDepths[scope];\n        if(scopeFuncDepth == 0) then\n            if upvalueIds[id] then\n                return upvalueIds[id];\n            end\n            expression = Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {});\n        else\n            logger:error(\"Unresolved Upvalue, this error should not occur!\");\n        end\n        table.insert(upvalEntries, Ast.TableEntry(expression));\n        local uid = #upvalEntries;\n        upvalueIds[id] = uid;\n        return uid;\n    end\n\n    -- Reference to Higher Scopes\n    createClosureSubScope:addReferenceToHigherScope(self.scope, self.containerFuncVar);\n    createClosureSubScope:addReferenceToHigherScope(createClosureScope, createClosurePosArg)\n    createClosureSubScope:addReferenceToHigherScope(createClosureScope, createClosureUpvalsArg, 1)\n    createClosureScope:addReferenceToHigherScope(self.scope, self.upvaluesProxyFunctionVar)\n    createClosureSubScope:addReferenceToHigherScope(createClosureScope, createClosureProxyObject);\n\n    -- Invoke Compiler\n    self:compileTopNode(ast);\n\n    local functionNodeAssignments = {\n        {\n            var = Ast.AssignmentVariable(self.scope, self.containerFuncVar),\n            val = Ast.FunctionLiteralExpression({\n                Ast.VariableExpression(self.containerFuncScope, self.posVar),\n                Ast.VariableExpression(self.containerFuncScope, self.argsVar),\n                Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar),\n                Ast.VariableExpression(self.containerFuncScope, self.detectGcCollectVar)\n            }, self:emitContainerFuncBody());\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.createVarargClosureVar),\n            val = Ast.FunctionLiteralExpression({\n                    Ast.VariableExpression(createClosureScope, createClosurePosArg),\n                    Ast.VariableExpression(createClosureScope, createClosureUpvalsArg),\n                },\n                Ast.Block({\n                    Ast.LocalVariableDeclaration(createClosureScope, {\n                        createClosureProxyObject\n                    }, {\n                        Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.upvaluesProxyFunctionVar), {\n                            Ast.VariableExpression(createClosureScope, createClosureUpvalsArg)\n                        })\n                    }),\n                    Ast.LocalVariableDeclaration(createClosureScope, {createClosureFuncVar},{\n                        Ast.FunctionLiteralExpression({\n                            Ast.VarargExpression();\n                        },\n                        Ast.Block({\n                            Ast.ReturnStatement{\n                                Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.containerFuncVar), {\n                                    Ast.VariableExpression(createClosureScope, createClosurePosArg),\n                                    Ast.TableConstructorExpression({Ast.TableEntry(Ast.VarargExpression())}),\n                                    Ast.VariableExpression(createClosureScope, createClosureUpvalsArg), -- Upvalues\n                                    Ast.VariableExpression(createClosureScope, createClosureProxyObject)\n                                })\n                            }\n                        }, createClosureSubScope)\n                        );\n                    });\n                    Ast.ReturnStatement{Ast.VariableExpression(createClosureScope, createClosureFuncVar)};\n                }, createClosureScope)\n            );\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.upvaluesTable),\n            val = Ast.TableConstructorExpression({}),\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.upvaluesReferenceCountsTable),\n            val = Ast.TableConstructorExpression({}),\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.allocUpvalFunction),\n            val = self:createAllocUpvalFunction(),\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.currentUpvalId),\n            val = Ast.NumberExpression(0),\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.upvaluesProxyFunctionVar),\n            val = self:createUpvaluesProxyFunc(),\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.upvaluesGcFunctionVar),\n            val = self:createUpvaluesGcFunc(),\n        }, {\n            var = Ast.AssignmentVariable(self.scope, self.freeUpvalueFunc),\n            val = self:createFreeUpvalueFunc(),\n        },\n    }\n\n    local tbl = {\n        Ast.VariableExpression(self.scope, self.containerFuncVar),\n        Ast.VariableExpression(self.scope, self.createVarargClosureVar),\n        Ast.VariableExpression(self.scope, self.upvaluesTable),\n        Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable),\n        Ast.VariableExpression(self.scope, self.allocUpvalFunction),\n        Ast.VariableExpression(self.scope, self.currentUpvalId),\n        Ast.VariableExpression(self.scope, self.upvaluesProxyFunctionVar),\n        Ast.VariableExpression(self.scope, self.upvaluesGcFunctionVar),\n        Ast.VariableExpression(self.scope, self.freeUpvalueFunc),\n    };\n    for i, entry in pairs(self.createClosureVars) do\n        table.insert(functionNodeAssignments, entry);\n        table.insert(tbl, Ast.VariableExpression(entry.var.scope, entry.var.id));\n    end\n\n    util.shuffle(functionNodeAssignments);\n    local assignmentStatLhs, assignmentStatRhs = {}, {};\n    for i, v in ipairs(functionNodeAssignments) do\n        assignmentStatLhs[i] = v.var;\n        assignmentStatRhs[i] = v.val;\n    end\n\n    -- Emit Code\n    local functionNode = Ast.FunctionLiteralExpression({\n        Ast.VariableExpression(self.scope, self.envVar),\n        Ast.VariableExpression(self.scope, self.unpackVar),\n        Ast.VariableExpression(self.scope, self.newproxyVar),\n        Ast.VariableExpression(self.scope, self.setmetatableVar),\n        Ast.VariableExpression(self.scope, self.getmetatableVar),\n        Ast.VariableExpression(self.scope, self.selectVar),\n        Ast.VariableExpression(self.scope, argVar),\n        unpack(util.shuffle(tbl))\n    }, Ast.Block({\n        Ast.AssignmentStatement(assignmentStatLhs, assignmentStatRhs);\n        Ast.ReturnStatement{\n            Ast.FunctionCallExpression(Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.createVarargClosureVar), {\n                    Ast.NumberExpression(self.startBlockId);\n                    Ast.TableConstructorExpression(upvalEntries);\n                }), {Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.unpackVar), {Ast.VariableExpression(self.scope, argVar)})});\n        }\n    }, self.scope));\n\n    return Ast.TopNode(Ast.Block({\n        Ast.ReturnStatement{Ast.FunctionCallExpression(functionNode, {\n            Ast.OrExpression(Ast.AndExpression(Ast.VariableExpression(newGlobalScope, getfenvVar), Ast.FunctionCallExpression(Ast.VariableExpression(newGlobalScope, getfenvVar), {})), Ast.VariableExpression(newGlobalScope, envVar));\n            Ast.OrExpression(Ast.VariableExpression(newGlobalScope, unpackVar), Ast.IndexExpression(Ast.VariableExpression(newGlobalScope, tableVar), Ast.StringExpression(\"unpack\")));\n            Ast.VariableExpression(newGlobalScope, newproxyVar);\n            Ast.VariableExpression(newGlobalScope, setmetatableVar);\n            Ast.VariableExpression(newGlobalScope, getmetatableVar);\n            Ast.VariableExpression(newGlobalScope, selectVar);\n            Ast.TableConstructorExpression({\n                Ast.TableEntry(Ast.VarargExpression());\n            })\n        })};\n    }, psc), newGlobalScope);\nend\n\nfunction Compiler:getCreateClosureVar(argCount)\n    if not self.createClosureVars[argCount] then\n        local var = Ast.AssignmentVariable(self.scope, self.scope:addVariable());\n        local createClosureScope = Scope:new(self.scope);\n        local createClosureSubScope = Scope:new(createClosureScope);\n        \n        local createClosurePosArg = createClosureScope:addVariable();\n        local createClosureUpvalsArg = createClosureScope:addVariable();\n        local createClosureProxyObject = createClosureScope:addVariable();\n        local createClosureFuncVar = createClosureScope:addVariable();\n\n        createClosureSubScope:addReferenceToHigherScope(self.scope, self.containerFuncVar);\n        createClosureSubScope:addReferenceToHigherScope(createClosureScope, createClosurePosArg)\n        createClosureSubScope:addReferenceToHigherScope(createClosureScope, createClosureUpvalsArg, 1)\n        createClosureScope:addReferenceToHigherScope(self.scope, self.upvaluesProxyFunctionVar)\n        createClosureSubScope:addReferenceToHigherScope(createClosureScope, createClosureProxyObject);\n\n        local  argsTb, argsTb2 = {}, {};\n        for i = 1, argCount do\n            local arg = createClosureSubScope:addVariable()\n            argsTb[i] = Ast.VariableExpression(createClosureSubScope, arg);\n            argsTb2[i] = Ast.TableEntry(Ast.VariableExpression(createClosureSubScope, arg));\n        end\n\n        local val = Ast.FunctionLiteralExpression({\n            Ast.VariableExpression(createClosureScope, createClosurePosArg),\n            Ast.VariableExpression(createClosureScope, createClosureUpvalsArg),\n        }, Ast.Block({\n                Ast.LocalVariableDeclaration(createClosureScope, {\n                    createClosureProxyObject\n                }, {\n                    Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.upvaluesProxyFunctionVar), {\n                        Ast.VariableExpression(createClosureScope, createClosureUpvalsArg)\n                    })\n                }),\n                Ast.LocalVariableDeclaration(createClosureScope, {createClosureFuncVar},{\n                    Ast.FunctionLiteralExpression(argsTb,\n                    Ast.Block({\n                        Ast.ReturnStatement{\n                            Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.containerFuncVar), {\n                                Ast.VariableExpression(createClosureScope, createClosurePosArg),\n                                Ast.TableConstructorExpression(argsTb2),\n                                Ast.VariableExpression(createClosureScope, createClosureUpvalsArg), -- Upvalues\n                                Ast.VariableExpression(createClosureScope, createClosureProxyObject)\n                            })\n                        }\n                    }, createClosureSubScope)\n                    );\n                });\n                Ast.ReturnStatement{Ast.VariableExpression(createClosureScope, createClosureFuncVar)}\n            }, createClosureScope)\n        );\n        self.createClosureVars[argCount] = {\n            var = var,\n            val = val,\n        }\n    end\n\n    \n    local var = self.createClosureVars[argCount].var;\n    return var.scope, var.id;\nend\n\nfunction Compiler:pushRegisterUsageInfo()\n    table.insert(self.registerUsageStack, {\n        usedRegisters = self.usedRegisters;\n        registers = self.registers;\n    });\n    self.usedRegisters = 0;\n    self.registers = {};\nend\n\nfunction Compiler:popRegisterUsageInfo()\n    local info = table.remove(self.registerUsageStack);\n    self.usedRegisters = info.usedRegisters;\n    self.registers = info.registers;\nend\n\nfunction Compiler:createUpvaluesGcFunc()\n    local scope = Scope:new(self.scope);\n    local selfVar = scope:addVariable();\n\n    local iteratorVar = scope:addVariable();\n    local valueVar = scope:addVariable();\n\n    local whileScope = Scope:new(scope);\n    whileScope:addReferenceToHigherScope(self.scope, self.upvaluesReferenceCountsTable, 3);\n    whileScope:addReferenceToHigherScope(scope, valueVar, 3);\n    whileScope:addReferenceToHigherScope(scope, iteratorVar, 3);\n\n    local ifScope = Scope:new(whileScope);\n    ifScope:addReferenceToHigherScope(self.scope, self.upvaluesReferenceCountsTable, 1);\n    ifScope:addReferenceToHigherScope(self.scope, self.upvaluesTable, 1);\n    \n\n    return Ast.FunctionLiteralExpression({Ast.VariableExpression(scope, selfVar)}, Ast.Block({\n        Ast.LocalVariableDeclaration(scope, {iteratorVar, valueVar}, {Ast.NumberExpression(1), Ast.IndexExpression(Ast.VariableExpression(scope, selfVar), Ast.NumberExpression(1))}),\n        Ast.WhileStatement(Ast.Block({\n            Ast.AssignmentStatement({\n                Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, valueVar)),\n                Ast.AssignmentVariable(scope, iteratorVar),\n            }, {\n                Ast.SubExpression(Ast.IndexExpression(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, valueVar)), Ast.NumberExpression(1)),\n                Ast.AddExpression(unpack(util.shuffle{Ast.VariableExpression(scope, iteratorVar), Ast.NumberExpression(1)})),\n            }),\n            Ast.IfStatement(Ast.EqualsExpression(unpack(util.shuffle{Ast.IndexExpression(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, valueVar)), Ast.NumberExpression(0)})), Ast.Block({\n                Ast.AssignmentStatement({\n                    Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, valueVar)),\n                    Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesTable), Ast.VariableExpression(scope, valueVar)),\n                }, {\n                    Ast.NilExpression(),\n                    Ast.NilExpression(),\n                })\n            }, ifScope), {}, nil),\n            Ast.AssignmentStatement({\n                Ast.AssignmentVariable(scope, valueVar),\n            }, {\n                Ast.IndexExpression(Ast.VariableExpression(scope, selfVar), Ast.VariableExpression(scope, iteratorVar)),\n            }),\n        }, whileScope), Ast.VariableExpression(scope, valueVar), scope);\n    }, scope));\nend\n\nfunction Compiler:createFreeUpvalueFunc()\n    local scope = Scope:new(self.scope);\n    local argVar = scope:addVariable();\n    local ifScope = Scope:new(scope);\n    ifScope:addReferenceToHigherScope(scope, argVar, 3);\n    scope:addReferenceToHigherScope(self.scope, self.upvaluesReferenceCountsTable, 2);\n    return Ast.FunctionLiteralExpression({Ast.VariableExpression(scope, argVar)}, Ast.Block({\n        Ast.AssignmentStatement({\n            Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, argVar))\n        }, {\n            Ast.SubExpression(Ast.IndexExpression(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, argVar)), Ast.NumberExpression(1));\n        }),\n        Ast.IfStatement(Ast.EqualsExpression(unpack(util.shuffle{Ast.IndexExpression(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, argVar)), Ast.NumberExpression(0)})), Ast.Block({\n            Ast.AssignmentStatement({\n                Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(scope, argVar)),\n                Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesTable), Ast.VariableExpression(scope, argVar)),\n            }, {\n                Ast.NilExpression(),\n                Ast.NilExpression(),\n            })\n        }, ifScope), {}, nil)\n    }, scope))\nend\n\nfunction Compiler:createUpvaluesProxyFunc()\n    local scope = Scope:new(self.scope);\n    scope:addReferenceToHigherScope(self.scope, self.newproxyVar);\n\n    local entriesVar = scope:addVariable();\n\n    local ifScope = Scope:new(scope);\n    local proxyVar = ifScope:addVariable();\n    local metatableVar = ifScope:addVariable();\n    local elseScope = Scope:new(scope);\n    ifScope:addReferenceToHigherScope(self.scope, self.newproxyVar);\n    ifScope:addReferenceToHigherScope(self.scope, self.getmetatableVar);\n    ifScope:addReferenceToHigherScope(self.scope, self.upvaluesGcFunctionVar);\n    ifScope:addReferenceToHigherScope(scope, entriesVar);\n    elseScope:addReferenceToHigherScope(self.scope, self.setmetatableVar);\n    elseScope:addReferenceToHigherScope(scope, entriesVar);\n    elseScope:addReferenceToHigherScope(self.scope, self.upvaluesGcFunctionVar);\n\n    local forScope = Scope:new(scope);\n    local forArg = forScope:addVariable();\n    forScope:addReferenceToHigherScope(self.scope, self.upvaluesReferenceCountsTable, 2);\n    forScope:addReferenceToHigherScope(scope, entriesVar, 2);\n\n    return Ast.FunctionLiteralExpression({Ast.VariableExpression(scope, entriesVar)}, Ast.Block({\n        Ast.ForStatement(forScope, forArg, Ast.NumberExpression(1), Ast.LenExpression(Ast.VariableExpression(scope, entriesVar)), Ast.NumberExpression(1), Ast.Block({\n            Ast.AssignmentStatement({\n                Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.IndexExpression(Ast.VariableExpression(scope, entriesVar), Ast.VariableExpression(forScope, forArg)))\n            }, {\n                Ast.AddExpression(unpack(util.shuffle{\n                    Ast.IndexExpression(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.IndexExpression(Ast.VariableExpression(scope, entriesVar), Ast.VariableExpression(forScope, forArg))),\n                    Ast.NumberExpression(1),\n                }))\n            })\n        }, forScope), scope);\n        Ast.IfStatement(Ast.VariableExpression(self.scope, self.newproxyVar), Ast.Block({\n            Ast.LocalVariableDeclaration(ifScope, {proxyVar}, {\n                Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.newproxyVar), {\n                    Ast.BooleanExpression(true)\n                });\n            });\n            Ast.LocalVariableDeclaration(ifScope, {metatableVar}, {\n                Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.getmetatableVar), {\n                    Ast.VariableExpression(ifScope, proxyVar);\n                });\n            });\n            Ast.AssignmentStatement({\n                Ast.AssignmentIndexing(Ast.VariableExpression(ifScope, metatableVar), Ast.StringExpression(\"__index\")),\n                Ast.AssignmentIndexing(Ast.VariableExpression(ifScope, metatableVar), Ast.StringExpression(\"__gc\")),\n                Ast.AssignmentIndexing(Ast.VariableExpression(ifScope, metatableVar), Ast.StringExpression(\"__len\")),\n            }, {\n                Ast.VariableExpression(scope, entriesVar),\n                Ast.VariableExpression(self.scope, self.upvaluesGcFunctionVar),\n                Ast.FunctionLiteralExpression({}, Ast.Block({\n                    Ast.ReturnStatement({Ast.NumberExpression(self.upvalsProxyLenReturn)})\n                }, Scope:new(ifScope)));\n            });\n            Ast.ReturnStatement({\n                Ast.VariableExpression(ifScope, proxyVar)\n            })\n        }, ifScope), {}, Ast.Block({\n            Ast.ReturnStatement({Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.setmetatableVar), {\n                Ast.TableConstructorExpression({}),\n                Ast.TableConstructorExpression({\n                    Ast.KeyedTableEntry(Ast.StringExpression(\"__gc\"), Ast.VariableExpression(self.scope, self.upvaluesGcFunctionVar)),\n                    Ast.KeyedTableEntry(Ast.StringExpression(\"__index\"), Ast.VariableExpression(scope, entriesVar)),\n                    Ast.KeyedTableEntry(Ast.StringExpression(\"__len\"), Ast.FunctionLiteralExpression({}, Ast.Block({\n                        Ast.ReturnStatement({Ast.NumberExpression(self.upvalsProxyLenReturn)})\n                    }, Scope:new(ifScope)))),\n                })\n            })})\n        }, elseScope));\n    }, scope));\nend\n\nfunction Compiler:createAllocUpvalFunction()\n    local scope = Scope:new(self.scope);\n    scope:addReferenceToHigherScope(self.scope, self.currentUpvalId, 4);\n    scope:addReferenceToHigherScope(self.scope, self.upvaluesReferenceCountsTable, 1);\n\n    return Ast.FunctionLiteralExpression({}, Ast.Block({\n        Ast.AssignmentStatement({\n                Ast.AssignmentVariable(self.scope, self.currentUpvalId),\n            },{\n                Ast.AddExpression(unpack(util.shuffle({\n                    Ast.VariableExpression(self.scope, self.currentUpvalId),\n                    Ast.NumberExpression(1),\n                }))),\n            }\n        ),\n        Ast.AssignmentStatement({\n            Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesReferenceCountsTable), Ast.VariableExpression(self.scope, self.currentUpvalId)),\n        }, {\n            Ast.NumberExpression(1),\n        }),\n        Ast.ReturnStatement({\n            Ast.VariableExpression(self.scope, self.currentUpvalId),\n        })\n    }, scope));\nend\n\nfunction Compiler:emitContainerFuncBody()\n    local blocks = {};\n\n    util.shuffle(self.blocks);\n\n    for _, block in ipairs(self.blocks) do\n        local id = block.id;\n        local blockstats = block.statements;\n\n        -- Shuffle Blockstats\n        for i = 2, #blockstats do\n            local stat = blockstats[i];\n            local reads = stat.reads;\n            local writes = stat.writes;\n            local maxShift = 0;\n            local usesUpvals = stat.usesUpvals;\n            for shift = 1, i - 1 do\n                local stat2 = blockstats[i - shift];\n\n                if stat2.usesUpvals and usesUpvals then\n                    break;\n                end\n\n                local reads2 = stat2.reads;\n                local writes2 = stat2.writes;\n                local f = true;\n\n                for r, b in pairs(reads2) do\n                    if(writes[r]) then\n                        f = false;\n                        break;\n                    end\n                end\n\n                if f then\n                    for r, b in pairs(writes2) do\n                        if(writes[r]) then\n                            f = false;\n                            break;\n                        end\n                        if(reads[r]) then\n                            f = false;\n                            break;\n                        end\n                    end\n                end\n\n                if not f then\n                    break\n                end\n\n                maxShift = shift;\n            end\n\n            local shift = math.random(0, maxShift);\n            for j = 1, shift do\n                    blockstats[i - j], blockstats[i - j + 1] = blockstats[i - j + 1], blockstats[i - j];\n            end\n        end\n\n        blockstats = {};\n        for i, stat in ipairs(block.statements) do\n            table.insert(blockstats, stat.statement);\n        end\n\n        table.insert(blocks, { id = id, block = Ast.Block(blockstats, block.scope) });\n    end\n\n    table.sort(blocks, function(a, b)\n        return a.id < b.id;\n    end);\n\n    local function buildIfBlock(scope, id, lBlock, rBlock)\n        return Ast.Block({\n            Ast.IfStatement(Ast.LessThanExpression(self:pos(scope), Ast.NumberExpression(id)), lBlock, {}, rBlock);\n        }, scope);\n    end\n\n    local function buildWhileBody(tb, l, r, pScope, scope)\n        local len = r - l + 1;\n        if len == 1 then\n            tb[r].block.scope:setParent(pScope);\n            return tb[r].block;\n        elseif len == 0 then\n            return nil;\n        end\n\n        local mid = l + math.ceil(len / 2);\n        local bound = math.random(tb[mid - 1].id + 1, tb[mid].id);\n        local ifScope = scope or Scope:new(pScope);\n\n        local lBlock = buildWhileBody(tb, l, mid - 1, ifScope);\n        local rBlock = buildWhileBody(tb, mid, r, ifScope);\n\n        return buildIfBlock(ifScope, bound, lBlock, rBlock);\n    end\n\n    local whileBody = buildWhileBody(blocks, 1, #blocks, self.containerFuncScope, self.whileScope);\n\n    self.whileScope:addReferenceToHigherScope(self.containerFuncScope, self.returnVar, 1);\n    self.whileScope:addReferenceToHigherScope(self.containerFuncScope, self.posVar);\n \n    self.containerFuncScope:addReferenceToHigherScope(self.scope, self.unpackVar);\n\n    local declarations = {\n        self.returnVar,\n    }\n\n    for i, var in pairs(self.registerVars) do\n        if(i ~= MAX_REGS) then\n            table.insert(declarations, var);\n        end\n    end\n\n    local stats = {\n        Ast.LocalVariableDeclaration(self.containerFuncScope, util.shuffle(declarations), {});\n        Ast.WhileStatement(whileBody, Ast.VariableExpression(self.containerFuncScope, self.posVar));\n        Ast.AssignmentStatement({\n            Ast.AssignmentVariable(self.containerFuncScope, self.posVar)\n        }, {\n            Ast.LenExpression(Ast.VariableExpression(self.containerFuncScope, self.detectGcCollectVar))\n        }),\n        Ast.ReturnStatement{\n            Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.unpackVar), {\n                Ast.VariableExpression(self.containerFuncScope, self.returnVar)\n            });\n        }\n    }\n\n    if self.maxUsedRegister >= MAX_REGS then\n        table.insert(stats, 1, Ast.LocalVariableDeclaration(self.containerFuncScope, {self.registerVars[MAX_REGS]}, {Ast.TableConstructorExpression({})}));\n    end\n\n    return Ast.Block(stats, self.containerFuncScope);\nend\n\nfunction Compiler:freeRegister(id, force)\n    if force or not (self.registers[id] == self.VAR_REGISTER) then\n        self.usedRegisters = self.usedRegisters - 1;\n        self.registers[id] = false\n    end\nend\n\nfunction Compiler:isVarRegister(id)\n    return self.registers[id] == self.VAR_REGISTER;\nend\n\nfunction Compiler:allocRegister(isVar)\n    self.usedRegisters = self.usedRegisters + 1;\n\n    if not isVar then\n        -- POS register can be temporarily used\n        if not self.registers[self.POS_REGISTER] then\n            self.registers[self.POS_REGISTER] = true;\n            return self.POS_REGISTER;\n        end\n\n        -- RETURN register can be temporarily used\n        if not self.registers[self.RETURN_REGISTER] then\n            self.registers[self.RETURN_REGISTER] = true;\n            return self.RETURN_REGISTER;\n        end\n    end\n    \n\n    local id = 0;\n    if self.usedRegisters < MAX_REGS * MAX_REGS_MUL then\n        repeat\n            id = math.random(1, MAX_REGS - 1);\n        until not self.registers[id];\n    else\n        repeat\n            id = id + 1;\n        until not self.registers[id];\n    end\n\n    if id > self.maxUsedRegister then\n        self.maxUsedRegister = id;\n    end\n\n    if(isVar) then\n        self.registers[id] = self.VAR_REGISTER;\n    else\n        self.registers[id] = true\n    end\n    return id;\nend\n\nfunction Compiler:isUpvalue(scope, id)\n    return self.upvalVars[scope] and self.upvalVars[scope][id];\nend\n\nfunction Compiler:makeUpvalue(scope, id)\n    if(not self.upvalVars[scope]) then\n        self.upvalVars[scope] = {}\n    end\n    self.upvalVars[scope][id] = true;\nend\n\nfunction Compiler:getVarRegister(scope, id, functionDepth, potentialId)\n    if(not self.registersForVar[scope]) then\n        self.registersForVar[scope] = {};\n        self.scopeFunctionDepths[scope] = functionDepth;\n    end\n\n    local reg = self.registersForVar[scope][id];\n    if not reg then\n        if potentialId and self.registers[potentialId] ~= self.VAR_REGISTER and potentialId ~= self.POS_REGISTER and potentialId ~= self.RETURN_REGISTER then\n            self.registers[potentialId] = self.VAR_REGISTER;\n            reg = potentialId;\n        else\n            reg = self:allocRegister(true);\n        end\n        self.registersForVar[scope][id] = reg;\n    end\n    return reg;\nend\n\nfunction Compiler:getRegisterVarId(id)\n    local varId = self.registerVars[id];\n    if not varId then\n        varId = self.containerFuncScope:addVariable();\n        self.registerVars[id] = varId;\n    end\n    return varId;\nend\n\n-- Maybe convert ids to strings\nfunction Compiler:register(scope, id)\n    if id == self.POS_REGISTER then\n        return self:pos(scope);\n    end\n\n    if id == self.RETURN_REGISTER then\n        return self:getReturn(scope);\n    end\n\n    if id < MAX_REGS then\n        local vid = self:getRegisterVarId(id);\n        scope:addReferenceToHigherScope(self.containerFuncScope, vid);\n        return Ast.VariableExpression(self.containerFuncScope, vid);\n    end\n\n    local vid = self:getRegisterVarId(MAX_REGS);\n    scope:addReferenceToHigherScope(self.containerFuncScope, vid);\n    return Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, vid), Ast.NumberExpression((id - MAX_REGS) + 1));\nend\n\nfunction Compiler:registerList(scope, ids)\n    local l = {};\n    for i, id in ipairs(ids) do\n        table.insert(l, self:register(scope, id));\n    end\n    return l;\nend\n\nfunction Compiler:registerAssignment(scope, id)\n    if id == self.POS_REGISTER then\n        return self:posAssignment(scope);\n    end\n    if id == self.RETURN_REGISTER then\n        return self:returnAssignment(scope);\n    end\n\n    if id < MAX_REGS then\n        local vid = self:getRegisterVarId(id);\n        scope:addReferenceToHigherScope(self.containerFuncScope, vid);\n        return Ast.AssignmentVariable(self.containerFuncScope, vid);\n    end\n\n    local vid = self:getRegisterVarId(MAX_REGS);\n    scope:addReferenceToHigherScope(self.containerFuncScope, vid);\n    return Ast.AssignmentIndexing(Ast.VariableExpression(self.containerFuncScope, vid), Ast.NumberExpression((id - MAX_REGS) + 1));\nend\n\n-- Maybe convert ids to strings\nfunction Compiler:setRegister(scope, id, val, compundArg)\n    if(compundArg) then\n        return compundArg(self:registerAssignment(scope, id), val);\n    end\n    return Ast.AssignmentStatement({\n        self:registerAssignment(scope, id)\n    }, {\n        val\n    });\nend\n\nfunction Compiler:setRegisters(scope, ids, vals)\n    local idStats = {};\n    for i, id in ipairs(ids) do\n        table.insert(idStats, self:registerAssignment(scope, id));\n    end\n\n    return Ast.AssignmentStatement(idStats, vals);\nend\n\nfunction Compiler:copyRegisters(scope, to, from)\n    local idStats = {};\n    local vals    = {};\n    for i, id in ipairs(to) do\n        local from = from[i];\n        if(from ~= id) then\n            table.insert(idStats, self:registerAssignment(scope, id));\n            table.insert(vals, self:register(scope, from));\n        end\n    end\n\n    if(#idStats > 0 and #vals > 0) then\n        return Ast.AssignmentStatement(idStats, vals);\n    end\nend\n\nfunction Compiler:resetRegisters()\n    self.registers = {};\nend\n\nfunction Compiler:pos(scope)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.posVar);\n    return Ast.VariableExpression(self.containerFuncScope, self.posVar);\nend\n\nfunction Compiler:posAssignment(scope)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.posVar);\n    return Ast.AssignmentVariable(self.containerFuncScope, self.posVar);\nend\n\nfunction Compiler:args(scope)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.argsVar);\n    return Ast.VariableExpression(self.containerFuncScope, self.argsVar);\nend\n\nfunction Compiler:unpack(scope)\n    scope:addReferenceToHigherScope(self.scope, self.unpackVar);\n    return Ast.VariableExpression(self.scope, self.unpackVar);\nend\n\nfunction Compiler:env(scope)\n    scope:addReferenceToHigherScope(self.scope, self.envVar);\n    return Ast.VariableExpression(self.scope, self.envVar);\nend\n\nfunction Compiler:jmp(scope, to)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.posVar);\n    return Ast.AssignmentStatement({Ast.AssignmentVariable(self.containerFuncScope, self.posVar)},{to});\nend\n\nfunction Compiler:setPos(scope, val)\n    if not val then\n       \n        local v =  Ast.IndexExpression(self:env(scope), randomStrings.randomStringNode(math.random(12, 14))); --Ast.NilExpression();\n        scope:addReferenceToHigherScope(self.containerFuncScope, self.posVar);\n        return Ast.AssignmentStatement({Ast.AssignmentVariable(self.containerFuncScope, self.posVar)}, {v});\n    end\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.posVar);\n    return Ast.AssignmentStatement({Ast.AssignmentVariable(self.containerFuncScope, self.posVar)}, {Ast.NumberExpression(val) or Ast.NilExpression()});\nend\n\nfunction Compiler:setReturn(scope, val)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.returnVar);\n    return Ast.AssignmentStatement({Ast.AssignmentVariable(self.containerFuncScope, self.returnVar)}, {val});\nend\n\nfunction Compiler:getReturn(scope)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.returnVar);\n    return Ast.VariableExpression(self.containerFuncScope, self.returnVar);\nend\n\nfunction Compiler:returnAssignment(scope)\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.returnVar);\n    return Ast.AssignmentVariable(self.containerFuncScope, self.returnVar);\nend\n\nfunction Compiler:setUpvalueMember(scope, idExpr, valExpr, compoundConstructor)\n    scope:addReferenceToHigherScope(self.scope, self.upvaluesTable);\n    if compoundConstructor then\n        return compoundConstructor(Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesTable), idExpr), valExpr);\n    end\n    return Ast.AssignmentStatement({Ast.AssignmentIndexing(Ast.VariableExpression(self.scope, self.upvaluesTable), idExpr)}, {valExpr});\nend\n\nfunction Compiler:getUpvalueMember(scope, idExpr)\n    scope:addReferenceToHigherScope(self.scope, self.upvaluesTable);\n    return Ast.IndexExpression(Ast.VariableExpression(self.scope, self.upvaluesTable), idExpr);\nend\n\nfunction Compiler:compileTopNode(node)\n    -- Create Initial Block\n    local startBlock = self:createBlock();\n    local scope = startBlock.scope;\n    self.startBlockId = startBlock.id;\n    self:setActiveBlock(startBlock);\n\n    local varAccessLookup = lookupify{\n        AstKind.AssignmentVariable,\n        AstKind.VariableExpression,\n        AstKind.FunctionDeclaration,\n        AstKind.LocalFunctionDeclaration,\n    }\n\n    local functionLookup = lookupify{\n        AstKind.FunctionDeclaration,\n        AstKind.LocalFunctionDeclaration,\n        AstKind.FunctionLiteralExpression,\n        AstKind.TopNode,\n    }\n    -- Collect Upvalues\n    visitast(node, function(node, data) \n        if node.kind == AstKind.Block then\n            node.scope.__depth = data.functionData.depth;\n        end\n\n        if varAccessLookup[node.kind] then\n            if not node.scope.isGlobal then\n                if node.scope.__depth < data.functionData.depth then\n                    if not self:isUpvalue(node.scope, node.id) then\n                        self:makeUpvalue(node.scope, node.id);\n                    end\n                end\n            end\n        end\n    end, nil, nil)\n\n    self.varargReg = self:allocRegister(true);\n    scope:addReferenceToHigherScope(self.containerFuncScope, self.argsVar);\n    scope:addReferenceToHigherScope(self.scope, self.selectVar);\n    scope:addReferenceToHigherScope(self.scope, self.unpackVar);\n    self:addStatement(self:setRegister(scope, self.varargReg, Ast.VariableExpression(self.containerFuncScope, self.argsVar)), {self.varargReg}, {}, false);\n\n    -- Compile Block\n    self:compileBlock(node.body, 0);\n    if(self.activeBlock.advanceToNextBlock) then\n        self:addStatement(self:setPos(self.activeBlock.scope, nil), {self.POS_REGISTER}, {}, false);\n        self:addStatement(self:setReturn(self.activeBlock.scope, Ast.TableConstructorExpression({})), {self.RETURN_REGISTER}, {}, false)\n        self.activeBlock.advanceToNextBlock = false;\n    end\n\n    self:resetRegisters();\nend\n\nfunction Compiler:compileFunction(node, funcDepth)\n    funcDepth = funcDepth + 1;\n    local oldActiveBlock = self.activeBlock;\n\n    local upperVarargReg = self.varargReg;\n    self.varargReg = nil;\n\n    local upvalueExpressions = {};\n    local upvalueIds = {};\n    local usedRegs = {};\n\n    local oldGetUpvalueId = self.getUpvalueId;\n    self.getUpvalueId = function(self, scope, id)\n        if(not upvalueIds[scope]) then\n            upvalueIds[scope] = {};\n        end\n        if(upvalueIds[scope][id]) then\n            return upvalueIds[scope][id];\n        end\n        local scopeFuncDepth = self.scopeFunctionDepths[scope];\n        local expression;\n        if(scopeFuncDepth == funcDepth) then\n            oldActiveBlock.scope:addReferenceToHigherScope(self.scope, self.allocUpvalFunction);\n            expression = Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {});\n        elseif(scopeFuncDepth == funcDepth - 1) then\n            local varReg = self:getVarRegister(scope, id, scopeFuncDepth, nil);\n            expression = self:register(oldActiveBlock.scope, varReg);\n            table.insert(usedRegs, varReg);\n        else\n            local higherId = oldGetUpvalueId(self, scope, id);\n            oldActiveBlock.scope:addReferenceToHigherScope(self.containerFuncScope, self.currentUpvaluesVar);\n            expression = Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar), Ast.NumberExpression(higherId));\n        end\n        table.insert(upvalueExpressions, Ast.TableEntry(expression));\n        local uid = #upvalueExpressions;\n        upvalueIds[scope][id] = uid;\n        return uid;\n    end\n\n    local block = self:createBlock();\n    self:setActiveBlock(block);\n    local scope = self.activeBlock.scope;\n    self:pushRegisterUsageInfo();\n    for i, arg in ipairs(node.args) do\n        if(arg.kind == AstKind.VariableExpression) then\n            if(self:isUpvalue(arg.scope, arg.id)) then\n                scope:addReferenceToHigherScope(self.scope, self.allocUpvalFunction);\n                local argReg = self:getVarRegister(arg.scope, arg.id, funcDepth, nil);\n                self:addStatement(self:setRegister(scope, argReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {})), {argReg}, {}, false);\n                self:addStatement(self:setUpvalueMember(scope, self:register(scope, argReg), Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.argsVar), Ast.NumberExpression(i))), {}, {argReg}, true);\n            else\n                local argReg = self:getVarRegister(arg.scope, arg.id, funcDepth, nil);\n                scope:addReferenceToHigherScope(self.containerFuncScope, self.argsVar);\n                self:addStatement(self:setRegister(scope, argReg, Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.argsVar), Ast.NumberExpression(i))), {argReg}, {}, false);\n            end\n        else\n            self.varargReg = self:allocRegister(true);\n            scope:addReferenceToHigherScope(self.containerFuncScope, self.argsVar);\n            scope:addReferenceToHigherScope(self.scope, self.selectVar);\n            scope:addReferenceToHigherScope(self.scope, self.unpackVar);\n            self:addStatement(self:setRegister(scope, self.varargReg, Ast.TableConstructorExpression({\n                Ast.TableEntry(Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.selectVar), {\n                    Ast.NumberExpression(i);\n                    Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.unpackVar), {\n                        Ast.VariableExpression(self.containerFuncScope, self.argsVar),\n                    });\n                })),\n            })), {self.varargReg}, {}, false);\n        end\n    end\n\n    self:compileBlock(node.body, funcDepth);\n    if(self.activeBlock.advanceToNextBlock) then\n        self:addStatement(self:setPos(self.activeBlock.scope, nil), {self.POS_REGISTER}, {}, false);\n        self:addStatement(self:setReturn(self.activeBlock.scope, Ast.TableConstructorExpression({})), {self.RETURN_REGISTER}, {}, false);\n        self.activeBlock.advanceToNextBlock = false;\n    end\n\n    if(self.varargReg) then\n        self:freeRegister(self.varargReg, true);\n    end\n    self.varargReg = upperVarargReg;\n    self.getUpvalueId = oldGetUpvalueId;\n\n    self:popRegisterUsageInfo();\n    self:setActiveBlock(oldActiveBlock);\n\n    local scope = self.activeBlock.scope;\n    \n    local retReg = self:allocRegister(false);\n\n    local isVarargFunction = #node.args > 0 and node.args[#node.args].kind == AstKind.VarargExpression;\n\n    local retrieveExpression\n    if isVarargFunction then\n        scope:addReferenceToHigherScope(self.scope, self.createVarargClosureVar);\n        retrieveExpression = Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.createVarargClosureVar), {\n            Ast.NumberExpression(block.id),\n            Ast.TableConstructorExpression(upvalueExpressions)\n        });\n    else\n        local varScope, var = self:getCreateClosureVar(#node.args + math.random(0, 5));\n        scope:addReferenceToHigherScope(varScope, var);\n        retrieveExpression = Ast.FunctionCallExpression(Ast.VariableExpression(varScope, var), {\n            Ast.NumberExpression(block.id),\n            Ast.TableConstructorExpression(upvalueExpressions)\n        });\n    end\n\n    self:addStatement(self:setRegister(scope, retReg, retrieveExpression), {retReg}, usedRegs, false);\n    return retReg;\nend\n\nfunction Compiler:compileBlock(block, funcDepth)\n    for i, stat in ipairs(block.statements) do\n        self:compileStatement(stat, funcDepth);\n    end\n\n    local scope = self.activeBlock.scope;\n    for id, name in ipairs(block.scope.variables) do\n        local varReg = self:getVarRegister(block.scope, id, funcDepth, nil);\n        if self:isUpvalue(block.scope, id) then\n            scope:addReferenceToHigherScope(self.scope, self.freeUpvalueFunc);\n            self:addStatement(self:setRegister(scope, varReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.freeUpvalueFunc), {\n                self:register(scope, varReg)\n            })), {varReg}, {varReg}, false);\n        else\n            self:addStatement(self:setRegister(scope, varReg, Ast.NilExpression()), {varReg}, {}, false);\n        end\n        self:freeRegister(varReg, true);\n    end\nend\n\nfunction Compiler:compileStatement(statement, funcDepth)\n    local scope = self.activeBlock.scope;\n    -- Return Statement\n    if(statement.kind == AstKind.ReturnStatement) then\n        local entries = {};\n        local regs = {};\n\n        for i, expr in ipairs(statement.args) do\n            if i == #statement.args and (expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression or expr.kind == AstKind.VarargExpression) then\n                local reg = self:compileExpression(expr, funcDepth, self.RETURN_ALL)[1];\n                table.insert(entries, Ast.TableEntry(Ast.FunctionCallExpression(\n                    self:unpack(scope),\n                    {self:register(scope, reg)})));\n                table.insert(regs, reg);\n            else\n                local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                table.insert(entries, Ast.TableEntry(self:register(scope, reg)));\n                table.insert(regs, reg);\n            end\n        end\n\n        for _, reg in ipairs(regs) do\n            self:freeRegister(reg, false);\n        end\n\n        self:addStatement(self:setReturn(scope, Ast.TableConstructorExpression(entries)), {self.RETURN_REGISTER}, regs, false);\n        self:addStatement(self:setPos(self.activeBlock.scope, nil), {self.POS_REGISTER}, {}, false);\n        self.activeBlock.advanceToNextBlock = false;\n        return;\n    end\n\n    -- Local Variable Declaration\n    if(statement.kind == AstKind.LocalVariableDeclaration) then\n        local exprregs = {};\n        for i, expr in ipairs(statement.expressions) do\n            if(i == #statement.expressions and #statement.ids > #statement.expressions) then\n                local regs = self:compileExpression(expr, funcDepth, #statement.ids - #statement.expressions + 1);\n                for i, reg in ipairs(regs) do\n                    table.insert(exprregs, reg);\n                end\n            else\n                if statement.ids[i] or expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression then\n                    local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                    table.insert(exprregs, reg);\n                end\n            end\n        end\n\n        if #exprregs == 0 then\n            for i=1, #statement.ids do\n                table.insert(exprregs, self:compileExpression(Ast.NilExpression(), funcDepth, 1)[1]);\n            end\n        end\n\n        for i, id in ipairs(statement.ids) do\n            if(exprregs[i]) then\n                if(self:isUpvalue(statement.scope, id)) then\n                    local varreg = self:getVarRegister(statement.scope, id, funcDepth);\n                    local varReg = self:getVarRegister(statement.scope, id, funcDepth, nil);\n                    scope:addReferenceToHigherScope(self.scope, self.allocUpvalFunction);\n                    self:addStatement(self:setRegister(scope, varReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {})), {varReg}, {}, false);\n                    self:addStatement(self:setUpvalueMember(scope, self:register(scope, varReg), self:register(scope, exprregs[i])), {}, {varReg, exprregs[i]}, true);\n                    self:freeRegister(exprregs[i], false);\n                else\n                    local varreg = self:getVarRegister(statement.scope, id, funcDepth, exprregs[i]);\n                    self:addStatement(self:copyRegisters(scope, {varreg}, {exprregs[i]}), {varreg}, {exprregs[i]}, false);\n                    self:freeRegister(exprregs[i], false);\n                end\n            end\n        end\n\n        if not self.scopeFunctionDepths[statement.scope] then\n            self.scopeFunctionDepths[statement.scope] = funcDepth;\n        end\n\n        return;\n    end\n\n    -- Function Call Statement\n    if(statement.kind == AstKind.FunctionCallStatement) then\n        local baseReg = self:compileExpression(statement.base, funcDepth, 1)[1];\n        local retReg  = self:allocRegister(false);\n        local regs = {};\n        local args = {};\n\n        for i, expr in ipairs(statement.args) do\n            if i == #statement.args and (expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression or expr.kind == AstKind.VarargExpression) then\n                local reg = self:compileExpression(expr, funcDepth, self.RETURN_ALL)[1];\n                table.insert(args, Ast.FunctionCallExpression(\n                    self:unpack(scope),\n                    {self:register(scope, reg)}));\n                table.insert(regs, reg);\n            else\n                local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                table.insert(args, self:register(scope, reg));\n                table.insert(regs, reg);\n            end\n        end\n\n        self:addStatement(self:setRegister(scope, retReg, Ast.FunctionCallExpression(self:register(scope, baseReg), args)), {retReg}, {baseReg, unpack(regs)}, true);\n        self:freeRegister(baseReg, false);\n        self:freeRegister(retReg, false);\n        for i, reg in ipairs(regs) do\n            self:freeRegister(reg, false);\n        end\n        \n        return;\n    end\n\n    -- Pass Self Function Call Statement\n    if(statement.kind == AstKind.PassSelfFunctionCallStatement) then\n        local baseReg = self:compileExpression(statement.base, funcDepth, 1)[1];\n        local tmpReg  = self:allocRegister(false);\n        local args = { self:register(scope, baseReg) };\n        local regs = { baseReg };\n\n        for i, expr in ipairs(statement.args) do\n            if i == #statement.args and (expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression or expr.kind == AstKind.VarargExpression) then\n                local reg = self:compileExpression(expr, funcDepth, self.RETURN_ALL)[1];\n                table.insert(args, Ast.FunctionCallExpression(\n                    self:unpack(scope),\n                    {self:register(scope, reg)}));\n                table.insert(regs, reg);\n            else\n                local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                table.insert(args, self:register(scope, reg));\n                table.insert(regs, reg);\n            end\n        end\n        self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(statement.passSelfFunctionName)), {tmpReg}, {}, false);\n        self:addStatement(self:setRegister(scope, tmpReg, Ast.IndexExpression(self:register(scope, baseReg), self:register(scope, tmpReg))), {tmpReg}, {tmpReg, baseReg}, false);\n\n        self:addStatement(self:setRegister(scope, tmpReg, Ast.FunctionCallExpression(self:register(scope, tmpReg), args)), {tmpReg}, {tmpReg, unpack(regs)}, true);\n\n        self:freeRegister(tmpReg, false);\n        for i, reg in ipairs(regs) do\n            self:freeRegister(reg, false);\n        end\n        \n        return;\n    end\n\n    -- Local Function Declaration\n    if(statement.kind == AstKind.LocalFunctionDeclaration) then\n        \n        if(self:isUpvalue(statement.scope, statement.id)) then\n            local varReg = self:getVarRegister(statement.scope, statement.id, funcDepth, nil);\n            scope:addReferenceToHigherScope(self.scope, self.allocUpvalFunction);\n            self:addStatement(self:setRegister(scope, varReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {})), {varReg}, {}, false);\n            local retReg = self:compileFunction(statement, funcDepth);\n            self:addStatement(self:setUpvalueMember(scope, self:register(scope, varReg), self:register(scope, retReg)), {}, {varReg, retReg}, true);\n            self:freeRegister(retReg, false);\n        else\n            local retReg = self:compileFunction(statement, funcDepth);\n            local varReg = self:getVarRegister(statement.scope, statement.id, funcDepth, retReg);\n            self:addStatement(self:copyRegisters(scope, {varReg}, {retReg}), {varReg}, {retReg}, false);\n            self:freeRegister(retReg, false);\n        end\n        return;\n    end\n\n    -- Function Declaration\n    if(statement.kind == AstKind.FunctionDeclaration) then\n        local retReg = self:compileFunction(statement, funcDepth);\n        if(#statement.indices > 0) then\n            local tblReg;\n            if statement.scope.isGlobal then\n                tblReg = self:allocRegister(false);\n                self:addStatement(self:setRegister(scope, tblReg, Ast.StringExpression(statement.scope:getVariableName(statement.id))), {tblReg}, {}, false);\n                self:addStatement(self:setRegister(scope, tblReg, Ast.IndexExpression(self:env(scope), self:register(scope, tblReg))), {tblReg}, {tblReg}, true);\n            else\n                if self.scopeFunctionDepths[statement.scope] == funcDepth then\n                    if self:isUpvalue(statement.scope, statement.id) then\n                        tblReg = self:allocRegister(false);\n                        local reg = self:getVarRegister(statement.scope, statement.id, funcDepth);\n                        self:addStatement(self:setRegister(scope, tblReg, self:getUpvalueMember(scope, self:register(scope, reg))), {tblReg}, {reg}, true);\n                    else\n                        tblReg = self:getVarRegister(statement.scope, statement.id, funcDepth, retReg);\n                    end\n                else\n                    tblReg = self:allocRegister(false);\n                    local upvalId = self:getUpvalueId(statement.scope, statement.id);\n                    scope:addReferenceToHigherScope(self.containerFuncScope, self.currentUpvaluesVar);\n                    self:addStatement(self:setRegister(scope, tblReg, self:getUpvalueMember(scope, Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar), Ast.NumberExpression(upvalId)))), {tblReg}, {}, true);\n                end\n            end\n\n            for i = 1, #statement.indices - 1 do\n                local index = statement.indices[i];\n                local indexReg = self:compileExpression(Ast.StringExpression(index), funcDepth, 1)[1];\n                local tblRegOld = tblReg;\n                tblReg = self:allocRegister(false);\n                self:addStatement(self:setRegister(scope, tblReg, Ast.IndexExpression(self:register(scope, tblRegOld), self:register(scope, indexReg))), {tblReg}, {tblReg, indexReg}, false);\n                self:freeRegister(tblRegOld, false);\n                self:freeRegister(indexReg, false);\n            end\n\n            local index = statement.indices[#statement.indices];\n            local indexReg = self:compileExpression(Ast.StringExpression(index), funcDepth, 1)[1];\n            self:addStatement(Ast.AssignmentStatement({\n                Ast.AssignmentIndexing(self:register(scope, tblReg), self:register(scope, indexReg)),\n            }, {\n                self:register(scope, retReg),\n            }), {}, {tblReg, indexReg, retReg}, true);\n            self:freeRegister(indexReg, false);\n            self:freeRegister(tblReg, false);\n            self:freeRegister(retReg, false);\n\n            return;\n        end\n        if statement.scope.isGlobal then\n            local tmpReg = self:allocRegister(false);\n            self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(statement.scope:getVariableName(statement.id))), {tmpReg}, {}, false);\n            self:addStatement(Ast.AssignmentStatement({Ast.AssignmentIndexing(self:env(scope), self:register(scope, tmpReg))},\n             {self:register(scope, retReg)}), {}, {tmpReg, retReg}, true);\n            self:freeRegister(tmpReg, false);\n        else\n            if self.scopeFunctionDepths[statement.scope] == funcDepth then\n                if self:isUpvalue(statement.scope, statement.id) then\n                    local reg = self:getVarRegister(statement.scope, statement.id, funcDepth);\n                    self:addStatement(self:setUpvalueMember(scope, self:register(scope, reg), self:register(scope, retReg)), {}, {reg, retReg}, true);\n                else\n                    local reg = self:getVarRegister(statement.scope, statement.id, funcDepth, retReg);\n                    if reg ~= retReg then\n                        self:addStatement(self:setRegister(scope, reg, self:register(scope, retReg)), {reg}, {retReg}, false);\n                    end\n                end\n            else\n                local upvalId = self:getUpvalueId(statement.scope, statement.id);\n                scope:addReferenceToHigherScope(self.containerFuncScope, self.currentUpvaluesVar);\n                self:addStatement(self:setUpvalueMember(scope, Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar), Ast.NumberExpression(upvalId)), self:register(scope, retReg)), {}, {retReg}, true);\n            end\n        end\n        self:freeRegister(retReg, false);\n        return;\n     end\n\n    -- Assignment Statement\n    if(statement.kind == AstKind.AssignmentStatement) then\n        local exprregs = {};\n        local assignmentIndexingRegs = {};\n        for i, primaryExpr in ipairs(statement.lhs) do\n            if(primaryExpr.kind == AstKind.AssignmentIndexing) then\n                assignmentIndexingRegs [i] = {\n                    base = self:compileExpression(primaryExpr.base, funcDepth, 1)[1],\n                    index = self:compileExpression(primaryExpr.index, funcDepth, 1)[1],\n                };\n            end\n        end\n\n        for i, expr in ipairs(statement.rhs) do\n            if(i == #statement.rhs and #statement.lhs > #statement.rhs) then\n                local regs = self:compileExpression(expr, funcDepth, #statement.lhs - #statement.rhs + 1);\n\n                for i, reg in ipairs(regs) do\n                    if(self:isVarRegister(reg)) then\n                        local ro = reg;\n                        reg = self:allocRegister(false);\n                        self:addStatement(self:copyRegisters(scope, {reg}, {ro}), {reg}, {ro}, false);\n                    end\n                    table.insert(exprregs, reg);\n                end\n            else\n                if statement.lhs[i] or expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression then\n                    local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                    if(self:isVarRegister(reg)) then\n                        local ro = reg;\n                        reg = self:allocRegister(false);\n                        self:addStatement(self:copyRegisters(scope, {reg}, {ro}), {reg}, {ro}, false);\n                    end\n                    table.insert(exprregs, reg);\n                end\n            end\n        end\n\n        for i, primaryExpr in ipairs(statement.lhs) do\n            if primaryExpr.kind == AstKind.AssignmentVariable then\n                if primaryExpr.scope.isGlobal then\n                    local tmpReg = self:allocRegister(false);\n                    self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(primaryExpr.scope:getVariableName(primaryExpr.id))), {tmpReg}, {}, false);\n                    self:addStatement(Ast.AssignmentStatement({Ast.AssignmentIndexing(self:env(scope), self:register(scope, tmpReg))},\n                     {self:register(scope, exprregs[i])}), {}, {tmpReg, exprregs[i]}, true);\n                    self:freeRegister(tmpReg, false);\n                else\n                    if self.scopeFunctionDepths[primaryExpr.scope] == funcDepth then\n                        if self:isUpvalue(primaryExpr.scope, primaryExpr.id) then\n                            local reg = self:getVarRegister(primaryExpr.scope, primaryExpr.id, funcDepth);\n                            self:addStatement(self:setUpvalueMember(scope, self:register(scope, reg), self:register(scope, exprregs[i])), {}, {reg, exprregs[i]}, true);\n                        else\n                            local reg = self:getVarRegister(primaryExpr.scope, primaryExpr.id, funcDepth, exprregs[i]);\n                            if reg ~= exprregs[i] then\n                                self:addStatement(self:setRegister(scope, reg, self:register(scope, exprregs[i])), {reg}, {exprregs[i]}, false);\n                            end\n                        end\n                    else\n                        local upvalId = self:getUpvalueId(primaryExpr.scope, primaryExpr.id);\n                        scope:addReferenceToHigherScope(self.containerFuncScope, self.currentUpvaluesVar);\n                        self:addStatement(self:setUpvalueMember(scope, Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar), Ast.NumberExpression(upvalId)), self:register(scope, exprregs[i])), {}, {exprregs[i]}, true);\n                    end\n                end\n            elseif primaryExpr.kind == AstKind.AssignmentIndexing then\n                local baseReg = assignmentIndexingRegs[i].base;\n                local indexReg = assignmentIndexingRegs[i].index;\n                self:addStatement(Ast.AssignmentStatement({\n                    Ast.AssignmentIndexing(self:register(scope, baseReg), self:register(scope, indexReg))\n                }, {\n                    self:register(scope, exprregs[i])\n                }), {}, {exprregs[i], baseReg, indexReg}, true);\n                self:freeRegister(exprregs[i], false);\n                self:freeRegister(baseReg, false);\n                self:freeRegister(indexReg, false);\n            else\n                error(string.format(\"Invalid Assignment lhs: %s\", statement.lhs));\n            end\n        end\n\n        return\n    end\n\n    -- If Statement\n    if(statement.kind == AstKind.IfStatement) then\n        local conditionReg = self:compileExpression(statement.condition, funcDepth, 1)[1];\n        local finalBlock = self:createBlock();\n\n        local nextBlock\n        if statement.elsebody or #statement.elseifs > 0 then\n            nextBlock = self:createBlock();\n        else\n            nextBlock = finalBlock;\n        end\n        local innerBlock = self:createBlock();\n\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(Ast.AndExpression(self:register(scope, conditionReg), Ast.NumberExpression(innerBlock.id)), Ast.NumberExpression(nextBlock.id))), {self.POS_REGISTER}, {conditionReg}, false);\n        \n        self:freeRegister(conditionReg, false);\n\n        self:setActiveBlock(innerBlock);\n        scope = innerBlock.scope\n        self:compileBlock(statement.body, funcDepth);\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(finalBlock.id)), {self.POS_REGISTER}, {}, false);\n\n        for i, eif in ipairs(statement.elseifs) do\n            self:setActiveBlock(nextBlock);\n            conditionReg = self:compileExpression(eif.condition, funcDepth, 1)[1];\n            local innerBlock = self:createBlock();\n            if statement.elsebody or i < #statement.elseifs then\n                nextBlock = self:createBlock();\n            else\n                nextBlock = finalBlock;\n            end\n            local scope = self.activeBlock.scope;\n            self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(Ast.AndExpression(self:register(scope, conditionReg), Ast.NumberExpression(innerBlock.id)), Ast.NumberExpression(nextBlock.id))), {self.POS_REGISTER}, {conditionReg}, false);\n        \n            self:freeRegister(conditionReg, false);\n\n            self:setActiveBlock(innerBlock);\n            scope = innerBlock.scope;\n            self:compileBlock(eif.body, funcDepth);\n            self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(finalBlock.id)), {self.POS_REGISTER}, {}, false);\n        end\n\n        if statement.elsebody then\n            self:setActiveBlock(nextBlock);\n            self:compileBlock(statement.elsebody, funcDepth);\n            self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(finalBlock.id)), {self.POS_REGISTER}, {}, false);\n        end\n\n        self:setActiveBlock(finalBlock);\n\n        return;\n    end\n\n    -- Do Statement\n    if(statement.kind == AstKind.DoStatement) then\n        self:compileBlock(statement.body, funcDepth);\n        return;\n    end\n\n    -- While Statement\n    if(statement.kind == AstKind.WhileStatement) then\n        local innerBlock = self:createBlock();\n        local finalBlock = self:createBlock();\n        local checkBlock = self:createBlock();\n\n        statement.__start_block = checkBlock;\n        statement.__final_block = finalBlock;\n\n        self:addStatement(self:setPos(scope, checkBlock.id), {self.POS_REGISTER}, {}, false);\n\n        self:setActiveBlock(checkBlock);\n        local scope = self.activeBlock.scope;\n        local conditionReg = self:compileExpression(statement.condition, funcDepth, 1)[1];\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(Ast.AndExpression(self:register(scope, conditionReg), Ast.NumberExpression(innerBlock.id)), Ast.NumberExpression(finalBlock.id))), {self.POS_REGISTER}, {conditionReg}, false);\n        self:freeRegister(conditionReg, false);\n\n        self:setActiveBlock(innerBlock);\n        local scope = self.activeBlock.scope;\n        self:compileBlock(statement.body, funcDepth);\n        self:addStatement(self:setPos(scope, checkBlock.id), {self.POS_REGISTER}, {}, false);\n        self:setActiveBlock(finalBlock);\n        return;\n    end\n\n    -- Repeat Statement\n    if(statement.kind == AstKind.RepeatStatement) then\n        local innerBlock = self:createBlock();\n        local finalBlock = self:createBlock();\n        local checkBlock = self:createBlock();\n        statement.__start_block = checkBlock;\n        statement.__final_block = finalBlock;\n\n        local conditionReg = self:compileExpression(statement.condition, funcDepth, 1)[1];\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(innerBlock.id)), {self.POS_REGISTER}, {}, false);\n        self:freeRegister(conditionReg, false);\n\n        self:setActiveBlock(innerBlock);\n        self:compileBlock(statement.body, funcDepth);\n        local scope = self.activeBlock.scope\n        self:addStatement(self:setPos(scope, checkBlock.id), {self.POS_REGISTER}, {}, false);\n        self:setActiveBlock(checkBlock);\n        local scope = self.activeBlock.scope;\n        local conditionReg = self:compileExpression(statement.condition, funcDepth, 1)[1];\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(Ast.AndExpression(self:register(scope, conditionReg), Ast.NumberExpression(finalBlock.id)), Ast.NumberExpression(innerBlock.id))), {self.POS_REGISTER}, {conditionReg}, false);\n        self:freeRegister(conditionReg, false);\n\n        self:setActiveBlock(finalBlock);\n\n        return;\n    end\n\n    -- For Statement\n    if(statement.kind == AstKind.ForStatement) then\n        local checkBlock = self:createBlock();\n        local innerBlock = self:createBlock();\n        local finalBlock = self:createBlock();\n\n        statement.__start_block = checkBlock;\n        statement.__final_block = finalBlock;\n\n        local posState = self.registers[self.POS_REGISTER];\n        self.registers[self.POS_REGISTER] = self.VAR_REGISTER;\n\n        local initialReg = self:compileExpression(statement.initialValue, funcDepth, 1)[1];\n\n        local finalExprReg = self:compileExpression(statement.finalValue, funcDepth, 1)[1];\n        local finalReg = self:allocRegister(false);\n        self:addStatement(self:copyRegisters(scope, {finalReg}, {finalExprReg}), {finalReg}, {finalExprReg}, false);\n        self:freeRegister(finalExprReg);\n\n        local incrementExprReg = self:compileExpression(statement.incrementBy, funcDepth, 1)[1];\n        local incrementReg = self:allocRegister(false);\n        self:addStatement(self:copyRegisters(scope, {incrementReg}, {incrementExprReg}), {incrementReg}, {incrementExprReg}, false);\n        self:freeRegister(incrementExprReg);\n\n        local tmpReg = self:allocRegister(false);\n        self:addStatement(self:setRegister(scope, tmpReg, Ast.NumberExpression(0)), {tmpReg}, {}, false);\n        local incrementIsNegReg = self:allocRegister(false);\n        self:addStatement(self:setRegister(scope, incrementIsNegReg, Ast.LessThanExpression(self:register(scope, incrementReg), self:register(scope, tmpReg))), {incrementIsNegReg}, {incrementReg, tmpReg}, false);     \n        self:freeRegister(tmpReg);\n\n        local currentReg = self:allocRegister(true);\n        self:addStatement(self:setRegister(scope, currentReg, Ast.SubExpression(self:register(scope, initialReg), self:register(scope, incrementReg))), {currentReg}, {initialReg, incrementReg}, false);\n        self:freeRegister(initialReg);\n\n        self:addStatement(self:jmp(scope, Ast.NumberExpression(checkBlock.id)), {self.POS_REGISTER}, {}, false);\n\n        self:setActiveBlock(checkBlock);\n\n        scope = checkBlock.scope;\n        self:addStatement(self:setRegister(scope, currentReg, Ast.AddExpression(self:register(scope, currentReg), self:register(scope, incrementReg))), {currentReg}, {currentReg, incrementReg}, false);\n        local tmpReg1 = self:allocRegister(false);\n        local tmpReg2 = self:allocRegister(false);\n        self:addStatement(self:setRegister(scope, tmpReg2, Ast.NotExpression(self:register(scope, incrementIsNegReg))), {tmpReg2}, {incrementIsNegReg}, false);\n        self:addStatement(self:setRegister(scope, tmpReg1, Ast.LessThanOrEqualsExpression(self:register(scope, currentReg), self:register(scope, finalReg))), {tmpReg1}, {currentReg, finalReg}, false);\n        self:addStatement(self:setRegister(scope, tmpReg1, Ast.AndExpression(self:register(scope, tmpReg2), self:register(scope, tmpReg1))), {tmpReg1}, {tmpReg1, tmpReg2}, false);\n        self:addStatement(self:setRegister(scope, tmpReg2, Ast.GreaterThanOrEqualsExpression(self:register(scope, currentReg), self:register(scope, finalReg))), {tmpReg2}, {currentReg, finalReg}, false);\n        self:addStatement(self:setRegister(scope, tmpReg2, Ast.AndExpression(self:register(scope, incrementIsNegReg), self:register(scope, tmpReg2))), {tmpReg2}, {tmpReg2, incrementIsNegReg}, false);\n        self:addStatement(self:setRegister(scope, tmpReg1, Ast.OrExpression(self:register(scope, tmpReg2), self:register(scope, tmpReg1))), {tmpReg1}, {tmpReg1, tmpReg2}, false);\n        self:freeRegister(tmpReg2);\n        tmpReg2 = self:compileExpression(Ast.NumberExpression(innerBlock.id), funcDepth, 1)[1];\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.AndExpression(self:register(scope, tmpReg1), self:register(scope, tmpReg2))), {self.POS_REGISTER}, {tmpReg1, tmpReg2}, false);\n        self:freeRegister(tmpReg2);\n        self:freeRegister(tmpReg1);\n        tmpReg2 = self:compileExpression(Ast.NumberExpression(finalBlock.id), funcDepth, 1)[1];\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(self:register(scope, self.POS_REGISTER), self:register(scope, tmpReg2))), {self.POS_REGISTER}, {self.POS_REGISTER, tmpReg2}, false);\n        self:freeRegister(tmpReg2);\n\n        self:setActiveBlock(innerBlock);\n        scope = innerBlock.scope;\n        self.registers[self.POS_REGISTER] = posState;\n\n        local varReg = self:getVarRegister(statement.scope, statement.id, funcDepth, nil);\n\n        if(self:isUpvalue(statement.scope, statement.id)) then\n            scope:addReferenceToHigherScope(self.scope, self.allocUpvalFunction);\n            self:addStatement(self:setRegister(scope, varReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {})), {varReg}, {}, false);\n            self:addStatement(self:setUpvalueMember(scope, self:register(scope, varReg), self:register(scope, currentReg)), {}, {varReg, currentReg}, true);\n        else\n            self:addStatement(self:setRegister(scope, varReg, self:register(scope, currentReg)), {varReg}, {currentReg}, false);\n        end\n\n        \n        self:compileBlock(statement.body, funcDepth);\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(checkBlock.id)), {self.POS_REGISTER}, {}, false);\n        \n        self.registers[self.POS_REGISTER] = self.VAR_REGISTER;\n        self:freeRegister(finalReg);\n        self:freeRegister(incrementIsNegReg);\n        self:freeRegister(incrementReg);\n        self:freeRegister(currentReg, true);\n\n        self.registers[self.POS_REGISTER] = posState;\n        self:setActiveBlock(finalBlock);\n\n        return;\n    end\n\n    -- For In Statement\n    if(statement.kind == AstKind.ForInStatement) then\n        local expressionsLength = #statement.expressions;\n        local exprregs = {};\n        for i, expr in ipairs(statement.expressions) do\n            if(i == expressionsLength and expressionsLength < 3) then\n                local regs = self:compileExpression(expr, funcDepth, 4 - expressionsLength);\n                for i = 1, 4 - expressionsLength do\n                    table.insert(exprregs, regs[i]);\n                end\n            else\n                if i <= 3 then\n                    table.insert(exprregs, self:compileExpression(expr, funcDepth, 1)[1])\n                else\n                    self:freeRegister(self:compileExpression(expr, funcDepth, 1)[1], false);\n                end\n            end\n        end\n\n        for i, reg in ipairs(exprregs) do\n            if reg and self.registers[reg] ~= self.VAR_REGISTER and reg ~= self.POS_REGISTER and reg ~= self.RETURN_REGISTER then\n                self.registers[reg] = self.VAR_REGISTER;\n            else\n                exprregs[i] = self:allocRegister(true);\n                self:addStatement(self:copyRegisters(scope, {exprregs[i]}, {reg}), {exprregs[i]}, {reg}, false);\n            end\n        end\n\n        local checkBlock = self:createBlock();\n        local bodyBlock = self:createBlock();\n        local finalBlock = self:createBlock();\n\n        statement.__start_block = checkBlock;\n        statement.__final_block = finalBlock;\n\n        self:addStatement(self:setPos(scope, checkBlock.id), {self.POS_REGISTER}, {}, false);\n\n        self:setActiveBlock(checkBlock);\n        local scope = self.activeBlock.scope;\n\n        local varRegs = {};\n        for i, id in ipairs(statement.ids) do\n            varRegs[i] = self:getVarRegister(statement.scope, id, funcDepth)\n        end\n\n        self:addStatement(Ast.AssignmentStatement({\n            self:registerAssignment(scope, exprregs[3]),\n            varRegs[2] and self:registerAssignment(scope, varRegs[2]),\n        }, {\n            Ast.FunctionCallExpression(self:register(scope, exprregs[1]), {\n                self:register(scope, exprregs[2]),\n                self:register(scope, exprregs[3]),\n            })\n        }), {exprregs[3], varRegs[2]}, {exprregs[1], exprregs[2], exprregs[3]}, true);\n\n        self:addStatement(Ast.AssignmentStatement({\n            self:posAssignment(scope)\n        }, {\n            Ast.OrExpression(Ast.AndExpression(self:register(scope, exprregs[3]), Ast.NumberExpression(bodyBlock.id)), Ast.NumberExpression(finalBlock.id))\n        }), {self.POS_REGISTER}, {exprregs[3]}, false);\n\n        self:setActiveBlock(bodyBlock);\n        local scope = self.activeBlock.scope;\n        self:addStatement(self:copyRegisters(scope, {varRegs[1]}, {exprregs[3]}), {varRegs[1]}, {exprregs[3]}, false);\n        for i=3, #varRegs do\n            self:addStatement(self:setRegister(scope, varRegs[i], Ast.NilExpression()), {varRegs[i]}, {}, false);\n        end\n\n        -- Upvalue fix\n        for i, id in ipairs(statement.ids) do\n            if(self:isUpvalue(statement.scope, id)) then\n                local varreg = varRegs[i];\n                local tmpReg = self:allocRegister(false);\n                scope:addReferenceToHigherScope(self.scope, self.allocUpvalFunction);\n                self:addStatement(self:setRegister(scope, tmpReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.allocUpvalFunction), {})), {tmpReg}, {}, false);\n                self:addStatement(self:setUpvalueMember(scope, self:register(scope, tmpReg), self:register(scope, varreg)), {}, {tmpReg, varreg}, true);\n                self:addStatement(self:copyRegisters(scope, {varreg}, {tmpReg}), {varreg}, {tmpReg}, false);\n                self:freeRegister(tmpReg, false);\n            end\n        end\n\n        self:compileBlock(statement.body, funcDepth);\n        self:addStatement(self:setPos(scope, checkBlock.id), {self.POS_REGISTER}, {}, false);\n        self:setActiveBlock(finalBlock);\n\n        for i, reg in ipairs(exprregs) do\n            self:freeRegister(exprregs[i], true)\n        end\n\n        return;\n    end\n\n    -- Do Statement\n    if(statement.kind == AstKind.DoStatement) then\n        self:compileBlock(statement.body, funcDepth);\n        return;\n    end\n\n    -- Break Statement\n    if(statement.kind == AstKind.BreakStatement) then\n        local toFreeVars = {};\n        local statScope;\n        repeat\n            statScope = statScope and statScope.parentScope or statement.scope;\n            for id, name in ipairs(statScope.variables) do\n                table.insert(toFreeVars, {\n                    scope = statScope,\n                    id = id;\n                });\n            end\n        until statScope == statement.loop.body.scope;\n\n        for i, var in pairs(toFreeVars) do\n            local varScope, id = var.scope, var.id;\n            local varReg = self:getVarRegister(varScope, id, nil, nil);\n            if self:isUpvalue(varScope, id) then\n                scope:addReferenceToHigherScope(self.scope, self.freeUpvalueFunc);\n                self:addStatement(self:setRegister(scope, varReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.freeUpvalueFunc), {\n                    self:register(scope, varReg)\n                })), {varReg}, {varReg}, false);\n            else\n                self:addStatement(self:setRegister(scope, varReg, Ast.NilExpression()), {varReg}, {}, false);\n            end\n        end\n\n        self:addStatement(self:setPos(scope, statement.loop.__final_block.id), {self.POS_REGISTER}, {}, false);\n        self.activeBlock.advanceToNextBlock = false;\n        return;\n    end\n\n    -- Continue Statement\n    if(statement.kind == AstKind.ContinueStatement) then\n        local toFreeVars = {};\n        local statScope;\n        repeat\n            statScope = statScope and statScope.parentScope or statement.scope;\n            for id, name in pairs(statScope.variables) do\n                table.insert(toFreeVars, {\n                    scope = statScope,\n                    id = id;\n                });\n            end\n        until statScope == statement.loop.body.scope;\n\n        for i, var in ipairs(toFreeVars) do\n            local varScope, id = var.scope, var.id;\n            local varReg = self:getVarRegister(varScope, id, nil, nil);\n            if self:isUpvalue(varScope, id) then\n                scope:addReferenceToHigherScope(self.scope, self.freeUpvalueFunc);\n                self:addStatement(self:setRegister(scope, varReg, Ast.FunctionCallExpression(Ast.VariableExpression(self.scope, self.freeUpvalueFunc), {\n                    self:register(scope, varReg)\n                })), {varReg}, {varReg}, false);\n            else\n                self:addStatement(self:setRegister(scope, varReg, Ast.NilExpression()), {varReg}, {}, false);\n            end\n        end\n\n        self:addStatement(self:setPos(scope, statement.loop.__start_block.id), {self.POS_REGISTER}, {}, false);\n        self.activeBlock.advanceToNextBlock = false;\n        return;\n    end\n\n    -- Compound Statements\n    local compoundConstructors = {\n        [AstKind.CompoundAddStatement] = Ast.CompoundAddStatement,\n        [AstKind.CompoundSubStatement] = Ast.CompoundSubStatement,\n        [AstKind.CompoundMulStatement] = Ast.CompoundMulStatement,\n        [AstKind.CompoundDivStatement] = Ast.CompoundDivStatement,\n        [AstKind.CompoundModStatement] = Ast.CompoundModStatement,\n        [AstKind.CompoundPowStatement] = Ast.CompoundPowStatement,\n        [AstKind.CompoundConcatStatement] = Ast.CompoundConcatStatement,\n    }\n    if compoundConstructors[statement.kind] then\n        local compoundConstructor = compoundConstructors[statement.kind];\n        if statement.lhs.kind == AstKind.AssignmentIndexing then\n            local indexing = statement.lhs;\n            local baseReg = self:compileExpression(indexing.base, funcDepth, 1)[1];\n            local indexReg = self:compileExpression(indexing.index, funcDepth, 1)[1];\n            local valueReg = self:compileExpression(statement.rhs, funcDepth, 1)[1];\n\n            self:addStatement(compoundConstructor(Ast.AssignmentIndexing(self:register(scope, baseReg), self:register(scope, indexReg)), self:register(scope, valueReg)), {}, {baseReg, indexReg, valueReg}, true);\n        else\n            local valueReg = self:compileExpression(statement.rhs, funcDepth, 1)[1];\n            local primaryExpr = statement.lhs;\n            if primaryExpr.scope.isGlobal then\n                local tmpReg = self:allocRegister(false);\n                self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(primaryExpr.scope:getVariableName(primaryExpr.id))), {tmpReg}, {}, false);\n                self:addStatement(Ast.AssignmentStatement({Ast.AssignmentIndexing(self:env(scope), self:register(scope, tmpReg))},\n                 {self:register(scope, valueReg)}), {}, {tmpReg, valueReg}, true);\n                self:freeRegister(tmpReg, false);\n            else\n                if self.scopeFunctionDepths[primaryExpr.scope] == funcDepth then\n                    if self:isUpvalue(primaryExpr.scope, primaryExpr.id) then\n                        local reg = self:getVarRegister(primaryExpr.scope, primaryExpr.id, funcDepth);\n                        self:addStatement(self:setUpvalueMember(scope, self:register(scope, reg), self:register(scope, valueReg), compoundConstructor), {}, {reg, valueReg}, true);\n                    else\n                        local reg = self:getVarRegister(primaryExpr.scope, primaryExpr.id, funcDepth, valueReg);\n                        if reg ~= valueReg then\n                            self:addStatement(self:setRegister(scope, reg, self:register(scope, valueReg), compoundConstructor), {reg}, {valueReg}, false);\n                        end\n                    end\n                else\n                    local upvalId = self:getUpvalueId(primaryExpr.scope, primaryExpr.id);\n                    scope:addReferenceToHigherScope(self.containerFuncScope, self.currentUpvaluesVar);\n                    self:addStatement(self:setUpvalueMember(scope, Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar), Ast.NumberExpression(upvalId)), self:register(scope, valueReg), compoundConstructor), {}, {valueReg}, true);\n                end\n            end\n        end\n        return;\n    end\n\n    logger:error(string.format(\"%s is not a compileable statement!\", statement.kind));\nend\n\nfunction Compiler:compileExpression(expression, funcDepth, numReturns)\n    local scope = self.activeBlock.scope;\n\n    -- String Expression\n    if(expression.kind == AstKind.StringExpression) then\n        local regs = {};\n        for i=1, numReturns, 1 do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                self:addStatement(self:setRegister(scope, regs[i], Ast.StringExpression(expression.value)), {regs[i]}, {}, false);\n            else\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    -- Number Expression\n    if(expression.kind == AstKind.NumberExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NumberExpression(expression.value)), {regs[i]}, {}, false);\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    -- Boolean Expression\n    if(expression.kind == AstKind.BooleanExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n               self:addStatement(self:setRegister(scope, regs[i], Ast.BooleanExpression(expression.value)), {regs[i]}, {}, false);\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    -- Nil Expression\n    if(expression.kind == AstKind.NilExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n        end\n        return regs;\n    end\n\n    -- Variable Expression\n    if(expression.kind == AstKind.VariableExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            if(i == 1) then\n                if(expression.scope.isGlobal) then\n                    -- Global Variable\n                    regs[i] = self:allocRegister(false);\n                    local tmpReg = self:allocRegister(false);\n                    self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(expression.scope:getVariableName(expression.id))), {tmpReg}, {}, false);\n                    self:addStatement(self:setRegister(scope, regs[i], Ast.IndexExpression(self:env(scope), self:register(scope, tmpReg))), {regs[i]}, {tmpReg}, true);\n                    self:freeRegister(tmpReg, false);\n                else\n                    -- Local Variable\n                    if(self.scopeFunctionDepths[expression.scope] == funcDepth) then\n                        if self:isUpvalue(expression.scope, expression.id) then\n                            local reg = self:allocRegister(false);\n                            local varReg = self:getVarRegister(expression.scope, expression.id, funcDepth, nil);\n                            self:addStatement(self:setRegister(scope, reg, self:getUpvalueMember(scope, self:register(scope, varReg))), {reg}, {varReg}, true);\n                            regs[i] = reg;\n                        else\n                            regs[i] = self:getVarRegister(expression.scope, expression.id, funcDepth, nil);\n                        end\n                    else\n                        local reg = self:allocRegister(false);\n                        local upvalId = self:getUpvalueId(expression.scope, expression.id);\n                        scope:addReferenceToHigherScope(self.containerFuncScope, self.currentUpvaluesVar);\n                        self:addStatement(self:setRegister(scope, reg, self:getUpvalueMember(scope, Ast.IndexExpression(Ast.VariableExpression(self.containerFuncScope, self.currentUpvaluesVar), Ast.NumberExpression(upvalId)))), {reg}, {}, true);\n                        regs[i] = reg;\n                    end\n                end\n            else\n                regs[i] = self:allocRegister();\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    -- Function Call Expression\n    if(expression.kind == AstKind.FunctionCallExpression) then\n        local baseReg = self:compileExpression(expression.base, funcDepth, 1)[1];\n\n        local retRegs  = {};\n        local returnAll = numReturns == self.RETURN_ALL;\n        if returnAll then\n            retRegs[1] = self:allocRegister(false);\n        else\n            for i = 1, numReturns do\n                retRegs[i] = self:allocRegister(false);\n            end\n        end\n        \n        local regs = {};\n        local args = {};\n        for i, expr in ipairs(expression.args) do\n            if i == #expression.args and (expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression or expr.kind == AstKind.VarargExpression) then\n                local reg = self:compileExpression(expr, funcDepth, self.RETURN_ALL)[1];\n                table.insert(args, Ast.FunctionCallExpression(\n                    self:unpack(scope),\n                    {self:register(scope, reg)}));\n                table.insert(regs, reg);\n            else\n                local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                table.insert(args, self:register(scope, reg));\n                table.insert(regs, reg);\n            end\n        end\n\n        if(returnAll) then\n            self:addStatement(self:setRegister(scope, retRegs[1], Ast.TableConstructorExpression{Ast.TableEntry(Ast.FunctionCallExpression(self:register(scope, baseReg), args))}), {retRegs[1]}, {baseReg, unpack(regs)}, true);\n        else\n            if(numReturns > 1) then\n                local tmpReg = self:allocRegister(false);\n    \n                self:addStatement(self:setRegister(scope, tmpReg, Ast.TableConstructorExpression{Ast.TableEntry(Ast.FunctionCallExpression(self:register(scope, baseReg), args))}), {tmpReg}, {baseReg, unpack(regs)}, true);\n    \n                for i, reg in ipairs(retRegs) do\n                    self:addStatement(self:setRegister(scope, reg, Ast.IndexExpression(self:register(scope, tmpReg), Ast.NumberExpression(i))), {reg}, {tmpReg}, false);\n                end\n    \n                self:freeRegister(tmpReg, false);\n            else\n                self:addStatement(self:setRegister(scope, retRegs[1], Ast.FunctionCallExpression(self:register(scope, baseReg), args)), {retRegs[1]}, {baseReg, unpack(regs)}, true);\n            end\n        end\n\n        self:freeRegister(baseReg, false);\n        for i, reg in ipairs(regs) do\n            self:freeRegister(reg, false);\n        end\n        \n        return retRegs;\n    end\n\n    -- Pass Self Function Call Expression\n    if(expression.kind == AstKind.PassSelfFunctionCallExpression) then\n        local baseReg = self:compileExpression(expression.base, funcDepth, 1)[1];\n        local retRegs  = {};\n        local returnAll = numReturns == self.RETURN_ALL;\n        if returnAll then\n            retRegs[1] = self:allocRegister(false);\n        else\n            for i = 1, numReturns do\n                retRegs[i] = self:allocRegister(false);\n            end\n        end\n\n        local args = { self:register(scope, baseReg) };\n        local regs = { baseReg };\n\n        for i, expr in ipairs(expression.args) do\n            if i == #expression.args and (expr.kind == AstKind.FunctionCallExpression or expr.kind == AstKind.PassSelfFunctionCallExpression or expr.kind == AstKind.VarargExpression) then\n                local reg = self:compileExpression(expr, funcDepth, self.RETURN_ALL)[1];\n                table.insert(args, Ast.FunctionCallExpression(\n                    self:unpack(scope),\n                    {self:register(scope, reg)}));\n                table.insert(regs, reg);\n            else\n                local reg = self:compileExpression(expr, funcDepth, 1)[1];\n                table.insert(args, self:register(scope, reg));\n                table.insert(regs, reg);\n            end\n        end\n\n        if(returnAll or numReturns > 1) then\n            local tmpReg = self:allocRegister(false);\n\n            self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(expression.passSelfFunctionName)), {tmpReg}, {}, false);\n            self:addStatement(self:setRegister(scope, tmpReg, Ast.IndexExpression(self:register(scope, baseReg), self:register(scope, tmpReg))), {tmpReg}, {baseReg, tmpReg}, false);\n\n            if returnAll then\n                self:addStatement(self:setRegister(scope, retRegs[1], Ast.TableConstructorExpression{Ast.TableEntry(Ast.FunctionCallExpression(self:register(scope, tmpReg), args))}), {retRegs[1]}, {tmpReg, unpack(regs)}, true);\n            else\n                self:addStatement(self:setRegister(scope, tmpReg, Ast.TableConstructorExpression{Ast.TableEntry(Ast.FunctionCallExpression(self:register(scope, tmpReg), args))}), {tmpReg}, {tmpReg, unpack(regs)}, true);\n\n                for i, reg in ipairs(retRegs) do\n                    self:addStatement(self:setRegister(scope, reg, Ast.IndexExpression(self:register(scope, tmpReg), Ast.NumberExpression(i))), {reg}, {tmpReg}, false);\n                end\n            end\n\n            self:freeRegister(tmpReg, false);\n        else\n            local tmpReg = retRegs[1] or self:allocRegister(false);\n\n            self:addStatement(self:setRegister(scope, tmpReg, Ast.StringExpression(expression.passSelfFunctionName)), {tmpReg}, {}, false);\n            self:addStatement(self:setRegister(scope, tmpReg, Ast.IndexExpression(self:register(scope, baseReg), self:register(scope, tmpReg))), {tmpReg}, {baseReg, tmpReg}, false);\n\n            self:addStatement(self:setRegister(scope, retRegs[1], Ast.FunctionCallExpression(self:register(scope, tmpReg), args)), {retRegs[1]}, {baseReg, unpack(regs)}, true);\n        end\n\n        for i, reg in ipairs(regs) do\n            self:freeRegister(reg, false);\n        end\n        \n        return retRegs;\n    end\n\n    -- Index Expression\n    if(expression.kind == AstKind.IndexExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                local baseReg = self:compileExpression(expression.base, funcDepth, 1)[1];\n                local indexReg = self:compileExpression(expression.index, funcDepth, 1)[1];\n\n                self:addStatement(self:setRegister(scope, regs[i], Ast.IndexExpression(self:register(scope, baseReg), self:register(scope, indexReg))), {regs[i]}, {baseReg, indexReg}, true);\n                self:freeRegister(baseReg, false);\n                self:freeRegister(indexReg, false)\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    -- Binary Operations\n    if(self.BIN_OPS[expression.kind]) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                local lhsReg = self:compileExpression(expression.lhs, funcDepth, 1)[1];\n                local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n\n                self:addStatement(self:setRegister(scope, regs[i], Ast[expression.kind](self:register(scope, lhsReg), self:register(scope, rhsReg))), {regs[i]}, {lhsReg, rhsReg}, true);\n                self:freeRegister(rhsReg, false);\n                self:freeRegister(lhsReg, false)\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    if(expression.kind == AstKind.NotExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NotExpression(self:register(scope, rhsReg))), {regs[i]}, {rhsReg}, false);\n                self:freeRegister(rhsReg, false)\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    if(expression.kind == AstKind.NegateExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NegateExpression(self:register(scope, rhsReg))), {regs[i]}, {rhsReg}, true);\n                self:freeRegister(rhsReg, false)\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    if(expression.kind == AstKind.LenExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n\n                self:addStatement(self:setRegister(scope, regs[i], Ast.LenExpression(self:register(scope, rhsReg))), {regs[i]}, {rhsReg}, true);\n                self:freeRegister(rhsReg, false)\n            else\n               self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    if(expression.kind == AstKind.OrExpression) then      \n        local posState = self.registers[self.POS_REGISTER];\n        self.registers[self.POS_REGISTER] = self.VAR_REGISTER;\n\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i ~= 1) then\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n\n        local resReg = regs[1];\n        local tmpReg;\n\n        if posState then\n            tmpReg = self:allocRegister(false);\n            self:addStatement(self:copyRegisters(scope, {tmpReg}, {self.POS_REGISTER}), {tmpReg}, {self.POS_REGISTER}, false);\n        end\n\n        local lhsReg = self:compileExpression(expression.lhs, funcDepth, 1)[1];\n        if(expression.rhs.isConstant) then\n            local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n            self:addStatement(self:setRegister(scope, resReg, Ast.OrExpression(self:register(scope, lhsReg), self:register(scope, rhsReg))), {resReg}, {lhsReg, rhsReg}, false);\n            if tmpReg then\n                self:freeRegister(tmpReg, false);\n            end\n            self:freeRegister(lhsReg, false);\n            self:freeRegister(rhsReg, false);\n            return regs;\n        end\n\n        local block1, block2 = self:createBlock(), self:createBlock();\n        self:addStatement(self:copyRegisters(scope, {resReg}, {lhsReg}), {resReg}, {lhsReg}, false);\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(Ast.AndExpression(self:register(scope, lhsReg), Ast.NumberExpression(block2.id)), Ast.NumberExpression(block1.id))), {self.POS_REGISTER}, {lhsReg}, false);\n        self:freeRegister(lhsReg, false);\n\n        do\n            self:setActiveBlock(block1);\n            local scope = block1.scope;\n            local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n            self:addStatement(self:copyRegisters(scope, {resReg}, {rhsReg}), {resReg}, {rhsReg}, false);\n            self:freeRegister(rhsReg, false);\n            self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(block2.id)), {self.POS_REGISTER}, {}, false);\n        end\n\n        self.registers[self.POS_REGISTER] = posState;\n\n        self:setActiveBlock(block2);\n        scope = block2.scope;\n\n        if tmpReg then\n            self:addStatement(self:copyRegisters(scope, {self.POS_REGISTER}, {tmpReg}), {self.POS_REGISTER}, {tmpReg}, false);\n            self:freeRegister(tmpReg, false);\n        end\n\n        return regs;\n    end\n\n    if(expression.kind == AstKind.AndExpression) then      \n        local posState = self.registers[self.POS_REGISTER];\n        self.registers[self.POS_REGISTER] = self.VAR_REGISTER;\n\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i ~= 1) then\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n\n        local resReg = regs[1];\n        local tmpReg;\n\n        if posState then\n            tmpReg = self:allocRegister(false);\n            self:addStatement(self:copyRegisters(scope, {tmpReg}, {self.POS_REGISTER}), {tmpReg}, {self.POS_REGISTER}, false);\n        end\n\n       \n        local lhsReg = self:compileExpression(expression.lhs, funcDepth, 1)[1];\n        if(expression.rhs.isConstant) then\n            local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n            self:addStatement(self:setRegister(scope, resReg, Ast.AndExpression(self:register(scope, lhsReg), self:register(scope, rhsReg))), {resReg}, {lhsReg, rhsReg}, false);\n            if tmpReg then\n                self:freeRegister(tmpReg, false);\n            end\n            self:freeRegister(lhsReg, false);\n            self:freeRegister(rhsReg, false)\n            return regs;\n        end\n\n\n        local block1, block2 = self:createBlock(), self:createBlock();\n        self:addStatement(self:copyRegisters(scope, {resReg}, {lhsReg}), {resReg}, {lhsReg}, false);\n        self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.OrExpression(Ast.AndExpression(self:register(scope, lhsReg), Ast.NumberExpression(block1.id)), Ast.NumberExpression(block2.id))), {self.POS_REGISTER}, {lhsReg}, false);\n        self:freeRegister(lhsReg, false);\n        do\n            self:setActiveBlock(block1);\n            scope = block1.scope;\n            local rhsReg = self:compileExpression(expression.rhs, funcDepth, 1)[1];\n            self:addStatement(self:copyRegisters(scope, {resReg}, {rhsReg}), {resReg}, {rhsReg}, false);\n            self:freeRegister(rhsReg, false);\n            self:addStatement(self:setRegister(scope, self.POS_REGISTER, Ast.NumberExpression(block2.id)), {self.POS_REGISTER}, {}, false);\n        end\n\n        self.registers[self.POS_REGISTER] = posState;\n\n        self:setActiveBlock(block2);\n        scope = block2.scope;\n\n        if tmpReg then\n            self:addStatement(self:copyRegisters(scope, {self.POS_REGISTER}, {tmpReg}), {self.POS_REGISTER}, {tmpReg}, false);\n            self:freeRegister(tmpReg, false);\n        end\n\n        return regs;\n    end\n\n    if(expression.kind == AstKind.TableConstructorExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister();\n            if(i == 1) then\n                local entries = {};\n                local entryRegs = {};\n                for i, entry in ipairs(expression.entries) do\n                    if(entry.kind == AstKind.TableEntry) then\n                        local value = entry.value;\n                        if i == #expression.entries and (value.kind == AstKind.FunctionCallExpression or value.kind == AstKind.PassSelfFunctionCallExpression or value.kind == AstKind.VarargExpression) then\n                            local reg = self:compileExpression(entry.value, funcDepth, self.RETURN_ALL)[1];\n                            table.insert(entries, Ast.TableEntry(Ast.FunctionCallExpression(\n                                self:unpack(scope),\n                                {self:register(scope, reg)})));\n                            table.insert(entryRegs, reg);\n                        else\n                            local reg = self:compileExpression(entry.value, funcDepth, 1)[1];\n                            table.insert(entries, Ast.TableEntry(self:register(scope, reg)));\n                            table.insert(entryRegs, reg);\n                        end\n                    else\n                        local keyReg = self:compileExpression(entry.key, funcDepth, 1)[1];\n                        local valReg = self:compileExpression(entry.value, funcDepth, 1)[1];\n                        table.insert(entries, Ast.KeyedTableEntry(self:register(scope, keyReg), self:register(scope, valReg)));\n                        table.insert(entryRegs, valReg);\n                        table.insert(entryRegs, keyReg);\n                    end\n                end\n                self:addStatement(self:setRegister(scope, regs[i], Ast.TableConstructorExpression(entries)), {regs[i]}, entryRegs, false);\n                for i, reg in ipairs(entryRegs) do\n                    self:freeRegister(reg, false);\n                end\n            else\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    if(expression.kind == AstKind.FunctionLiteralExpression) then\n        local regs = {};\n        for i=1, numReturns do\n            if(i == 1) then\n                regs[i] = self:compileFunction(expression, funcDepth);\n            else\n                regs[i] = self:allocRegister();\n                self:addStatement(self:setRegister(scope, regs[i], Ast.NilExpression()), {regs[i]}, {}, false);\n            end\n        end\n        return regs;\n    end\n\n    if(expression.kind == AstKind.VarargExpression) then\n        if numReturns == self.RETURN_ALL then\n            return {self.varargReg};\n        end\n        local regs = {};\n        for i=1, numReturns do\n            regs[i] = self:allocRegister(false);\n            self:addStatement(self:setRegister(scope, regs[i], Ast.IndexExpression(self:register(scope, self.varargReg), Ast.NumberExpression(i))), {regs[i]}, {self.varargReg}, false);\n        end\n        return regs;\n    end\n\n    logger:error(string.format(\"%s is not an compliable expression!\", expression.kind));\nend\n\nreturn Compiler;\n",
  "prometheus.namegenerators.Il": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- namegenerators/il.lua\n--\n-- This Script provides a function for generation of weird names consisting of I, l and 1\n\nlocal MIN_CHARACTERS = 5;\nlocal MAX_INITIAL_CHARACTERS = 10;\n\n\nlocal util = require(\"prometheus.util\");\nlocal chararray = util.chararray;\n\nlocal offset = 0;\nlocal VarDigits = chararray(\"Il1\");\nlocal VarStartDigits = chararray(\"Il\");\n\nlocal function generateName(id, scope)\n\tlocal name = ''\n\tid = id + offset;\n\tlocal d = id % #VarStartDigits\n\tid = (id - d) / #VarStartDigits\n\tname = name..VarStartDigits[d+1]\n\twhile id > 0 do\n\t\tlocal d = id % #VarDigits\n\t\tid = (id - d) / #VarDigits\n\t\tname = name..VarDigits[d+1]\n\tend\n\treturn name\nend\n\nlocal function prepare(ast)\n\tutil.shuffle(VarDigits);\n\tutil.shuffle(VarStartDigits);\n\toffset = math.random(3 ^ MIN_CHARACTERS, 3 ^ MAX_INITIAL_CHARACTERS);\nend\n\nreturn {\n\tgenerateName = generateName, \n\tprepare = prepare\n};\n",
  "prometheus.namegenerators.confuse": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- namegenerators/confuse.lua\n--\n-- This Script provides a function for generation of confusing variable names\n\nlocal util = require(\"prometheus.util\");\nlocal chararray = util.chararray;\n\nlocal varNames = {\n    \"index\",\n    \"iterator\",\n    \"length\",\n    \"size\",\n    \"key\",\n    \"value\",\n    \"data\",\n    \"count\",\n    \"increment\",\n    \"include\",\n    \"string\",\n    \"number\",\n    \"type\",\n    \"void\",\n    \"int\",\n    \"float\",\n    \"bool\",\n    \"char\",\n    \"double\",\n    \"long\",\n    \"short\",\n    \"unsigned\",\n    \"signed\",\n    \"program\",\n    \"factory\",\n    \"Factory\",\n    \"new\",\n    \"delete\",\n    \"table\",\n    \"array\",\n    \"object\",\n    \"class\",\n    \"arr\",\n    \"obj\",\n    \"cls\",\n    \"dir\",\n    \"directory\",\n    \"isWindows\",\n    \"isLinux\",\n    \"game\",\n    \"roblox\",\n    \"gmod\",\n    \"gsub\",\n    \"gmatch\",\n    \"gfind\",\n    \"onload\",\n    \"load\",\n    \"loadstring\",\n    \"loadfile\",\n    \"dofile\",\n    \"require\",\n    \"parse\",\n    \"byte\",\n    \"code\",\n    \"bytecode\",\n    \"idx\",\n    \"const\",\n    \"loader\",\n    \"loaders\",\n    \"module\",\n    \"export\",\n    \"exports\",\n    \"import\",\n    \"imports\",\n    \"package\",\n    \"packages\",\n    \"_G\",\n    \"math\",\n    \"os\",\n    \"io\",\n    \"write\",\n    \"print\",\n    \"read\",\n    \"readline\",\n    \"readlines\",\n    \"close\",\n    \"flush\",\n    \"open\",\n    \"popen\",\n    \"tmpfile\",\n    \"tmpname\",\n    \"rename\",\n    \"remove\",\n    \"seek\",\n    \"setvbuf\",\n    \"lines\",\n    \"call\",\n    \"apply\",\n    \"raise\",\n    \"pcall\",\n    \"xpcall\",\n    \"coroutine\",\n    \"create\",\n    \"resume\",\n    \"status\",\n    \"wrap\",\n    \"yield\",\n    \"debug\",\n    \"traceback\",\n    \"getinfo\",\n    \"getlocal\",\n    \"setlocal\",\n    \"getupvalue\",\n    \"setupvalue\",\n    \"getuservalue\",\n    \"setuservalue\",\n    \"upvalueid\",\n    \"upvaluejoin\",\n    \"sethook\",\n    \"gethook\",\n    \"hookfunction\",\n    \"hooks\",\n    \"error\",\n    \"setmetatable\",\n    \"getmetatable\",\n    \"rand\",\n    \"randomseed\",\n    \"next\",\n    \"ipairs\",\n    \"hasnext\",\n    \"loadlib\",\n    \"searchpath\",\n    \"oldpath\",\n    \"newpath\",\n    \"path\",\n    \"rawequal\",\n    \"rawset\",\n    \"rawget\",\n    \"rawnew\",\n    \"rawlen\",\n    \"select\",\n    \"tonumber\",\n    \"tostring\",\n    \"assert\",\n    \"collectgarbage\",\n    \"a\", \"b\", \"c\", \"i\", \"j\", \"m\",\n}\n\nlocal function generateName(id, scope)\n    local name = {};\n    local d = id % #varNames\n\tid = (id - d) / #varNames\n\ttable.insert(name, varNames[d + 1]);\n\twhile id > 0 do\n\t\tlocal d = id % #varNames\n\t\tid = (id - d) / #varNames\n\t\ttable.insert(name, varNames[d + 1]);\n\tend\n\treturn table.concat(name, \"_\");\nend\n\nlocal function prepare(ast)\n    util.shuffle(varNames);\nend\n\nreturn {\n\tgenerateName = generateName, \n\tprepare = prepare\n};\n",
  "prometheus.namegenerators.mangled": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- namegenerators/mangled.lua\n--\n-- This Script provides a function for generation of mangled names\n\n\nlocal util = require(\"prometheus.util\");\nlocal chararray = util.chararray;\n\nlocal idGen = 0\nlocal VarDigits = chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\");\nlocal VarStartDigits = chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\nreturn function(id, scope)\n\tlocal name = ''\n\tlocal d = id % #VarStartDigits\n\tid = (id - d) / #VarStartDigits\n\tname = name..VarStartDigits[d+1]\n\twhile id > 0 do\n\t\tlocal d = id % #VarDigits\n\t\tid = (id - d) / #VarDigits\n\t\tname = name..VarDigits[d+1]\n\tend\n\treturn name\nend",
  "prometheus.namegenerators.mangled_shuffled": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- namegenerators/mangled_shuffled.lua\n--\n-- This Script provides a function for generation of mangled names with shuffled character order\n\n\nlocal util = require(\"prometheus.util\");\nlocal chararray = util.chararray;\n\nlocal VarDigits = chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\");\nlocal VarStartDigits = chararray(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\nlocal function generateName(id, scope)\n\tlocal name = ''\n\tlocal d = id % #VarStartDigits\n\tid = (id - d) / #VarStartDigits\n\tname = name..VarStartDigits[d+1]\n\twhile id > 0 do\n\t\tlocal d = id % #VarDigits\n\t\tid = (id - d) / #VarDigits\n\t\tname = name..VarDigits[d+1]\n\tend\n\treturn name\nend\n\nlocal function prepare(ast)\n\tutil.shuffle(VarDigits);\n\tutil.shuffle(VarStartDigits);\nend\n\nreturn {\n\tgenerateName = generateName, \n\tprepare = prepare\n};",
  "prometheus.namegenerators.number": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- namegenerators/number.lua\n--\n-- This Script provides a function for generation of simple up counting names but with hex numbers\n\nlocal PREFIX = \"_\";\n\nreturn function(id, scope)\n\treturn PREFIX .. tostring(id);\nend\n",
  "prometheus.steps.AddVararg": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- AddVararg.lua\n--\n-- This Script provides a Simple Obfuscation Step that wraps the entire Script into a function\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal visitast = require(\"prometheus.visitast\");\nlocal AstKind = Ast.AstKind;\n\nlocal AddVararg = Step:extend();\nAddVararg.Description = \"This Step Adds Vararg to all Functions\";\nAddVararg.Name = \"Add Vararg\";\n\nAddVararg.SettingsDescriptor = {\n}\n\nfunction AddVararg:init(settings)\n\t\nend\n\nfunction AddVararg:apply(ast)\n\tvisitast(ast, nil, function(node)\n        if node.kind == AstKind.FunctionDeclaration or node.kind == AstKind.LocalFunctionDeclaration or node.kind == AstKind.FunctionLiteralExpression then\n            if #node.args < 1 or node.args[#node.args].kind ~= AstKind.VarargExpression then\n                node.args[#node.args + 1] = Ast.VarargExpression();\n            end\n        end\n    end)\nend\n\nreturn AddVararg;",
  "prometheus.steps.AntiTamper": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- AntiTamper.lua\n--\n-- This Script provides an Obfuscation Step, that breaks the script, when someone tries to tamper with it.\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal RandomStrings = require(\"prometheus.randomStrings\")\nlocal Parser = require(\"prometheus.parser\");\nlocal Enums = require(\"prometheus.enums\");\nlocal logger = require(\"logger\");\n\nlocal AntiTamper = Step:extend();\nAntiTamper.Description = \"This Step Breaks your Script when it is modified. This is only effective when using the new VM.\";\nAntiTamper.Name = \"Anti Tamper\";\n\nAntiTamper.SettingsDescriptor = {\n    UseDebug = {\n        type = \"boolean\",\n        default = true,\n        description = \"Use debug library. (Recommended, however scripts will not work without debug library.)\"\n    }\n}\n\nfunction AntiTamper:init(settings)\n\t\nend\n\nfunction AntiTamper:apply(ast, pipeline)\n    if pipeline.PrettyPrint then\n        logger:warn(string.format(\"\\\"%s\\\" cannot be used with PrettyPrint, ignoring \\\"%s\\\"\", self.Name, self.Name));\n        return ast;\n    end\n\tlocal code = \"do local valid = true;\";\n    if self.UseDebug then\n        local string = RandomStrings.randomString();\n        code = code .. [[\n            -- Anti Beautify\n\t\t\tlocal sethook = debug and debug.sethook or function() end;\n\t\t\tlocal allowedLine = nil;\n\t\t\tlocal called = 0;\n\t\t\tsethook(function(s, line)\n\t\t\t\tif not line then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\tcalled = called + 1;\n\t\t\t\tif allowedLine then\n\t\t\t\t\tif allowedLine ~= line then\n\t\t\t\t\t\tsethook(error, \"l\", 5);\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tallowedLine = line;\n\t\t\t\tend\n\t\t\tend, \"l\", 5);\n\t\t\t(function() end)();\n\t\t\t(function() end)();\n\t\t\tsethook();\n\t\t\tif called < 2 then\n\t\t\t\tvalid = false;\n\t\t\tend\n            if called < 2 then\n                valid = false;\n            end\n\n            -- Anti Function Hook\n            local funcs = {pcall, string.char, debug.getinfo, string.dump}\n            for i = 1, #funcs do\n                if debug.getinfo(funcs[i]).what ~= \"C\" then\n                    valid = false;\n                end\n\n                if debug.getlocal(funcs[i], 1) then\n                    valid = false;\n                end\n\n                if debug.getupvalue(funcs[i], 1) then\n                    valid = false;\n                end\n\n                if pcall(string.dump, funcs[i]) then\n                    valid = false;\n                end\n            end\n\n            -- Anti Beautify\n            local function getTraceback()\n                local str = (function(arg)\n                    return debug.traceback(arg)\n                end)(\"]] .. string .. [[\");\n                return str;\n            end\n    \n            local traceback = getTraceback();\n            valid = valid and traceback:sub(1, traceback:find(\"\\n\") - 1) == \"]] .. string .. [[\";\n            local iter = traceback:gmatch(\":(%d*):\");\n            local v, c = iter(), 1;\n            for i in iter do\n                valid = valid and i == v;\n                c = c + 1;\n            end\n            valid = valid and c >= 2;\n        ]]\n    end\n    code = code .. [[\n    local gmatch = string.gmatch;\n    local err = function() error(\"Tamper Detected!\") end;\n\n    local pcallIntact2 = false;\n    local pcallIntact = pcall(function()\n        pcallIntact2 = true;\n    end) and pcallIntact2;\n\n    local random = math.random;\n    local tblconcat = table.concat;\n    local unpkg = table and table.unpack or unpack;\n    local n = random(3, 65);\n    local acc1 = 0;\n    local acc2 = 0;\n    local pcallRet = {pcall(function() local a = ]] .. tostring(math.random(1, 2^24)) .. [[ - \"]] .. RandomStrings.randomString() .. [[\" ^ ]] .. tostring(math.random(1, 2^24)) .. [[ return \"]] .. RandomStrings.randomString() .. [[\" / a; end)};\n    local origMsg = pcallRet[2];\n    local line = tonumber(gmatch(tostring(origMsg), ':(%d*):')());\n    for i = 1, n do\n        local len = math.random(1, 100);\n        local n2 = random(0, 255);\n        local pos = random(1, len);\n        local shouldErr = random(1, 2) == 1;\n        local msg = origMsg:gsub(':(%d*):', ':' .. tostring(random(0, 10000)) .. ':');\n        local arr = {pcall(function()\n            if random(1, 2) == 1 or i == n then\n                local line2 = tonumber(gmatch(tostring(({pcall(function() local a = ]] .. tostring(math.random(1, 2^24)) .. [[ - \"]] .. RandomStrings.randomString() .. [[\" ^ ]] .. tostring(math.random(1, 2^24)) .. [[ return \"]] .. RandomStrings.randomString() .. [[\" / a; end)})[2]), ':(%d*):')());\n                valid = valid and line == line2;\n            end\n            if shouldErr then\n                error(msg, 0);\n            end\n            local arr = {};\n            for i = 1, len do\n                arr[i] = random(0, 255);\n            end\n            arr[pos] = n2;\n            return unpkg(arr);\n        end)};\n        if shouldErr then\n            valid = valid and arr[1] == false and arr[2] == msg;\n        else\n            valid = valid and arr[1];\n            acc1 = (acc1 + arr[pos + 1]) % 256;\n            acc2 = (acc2 + n2) % 256;\n        end\n    end\n    valid = valid and acc1 == acc2;\n\n    if valid then else\n        repeat \n            return (function()\n                while true do\n                    l1, l2 = l2, l1;\n                    err();\n                end\n            end)(); \n        until true;\n        while true do\n            l2 = random(1, 6);\n            if l2 > 2 then\n                l2 = tostring(l1);\n            else\n                l1 = l2;\n            end\n        end\n        return;\n    end\nend\n\n    -- Anti Function Arg Hook\n    local obj = setmetatable({}, {\n        __tostring = err,\n    });\n    obj[math.random(1, 100)] = obj;\n    (function() end)(obj);\n\n    repeat until valid;\n    ]]\n\n    local parsed = Parser:new({LuaVersion = Enums.LuaVersion.Lua51}):parse(code);\n    local doStat = parsed.body.statements[1];\n    doStat.body.scope:setParent(ast.body.scope);\n    table.insert(ast.body.statements, 1, doStat);\n\n    return ast;\nend\n\nreturn AntiTamper;\n",
  "prometheus.steps.ConstantArray": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- ConstantArray.lua\n--\n-- This Script provides a Simple Obfuscation Step that wraps the entire Script into a function\n\n-- TODO: Wrapper Functions\n-- TODO: Proxy Object for indexing: e.g: ARR[X] becomes ARR + X\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal visitast = require(\"prometheus.visitast\");\nlocal util     = require(\"prometheus.util\")\nlocal Parser   = require(\"prometheus.parser\");\nlocal enums = require(\"prometheus.enums\")\n\nlocal LuaVersion = enums.LuaVersion;\nlocal AstKind = Ast.AstKind;\n\nlocal ConstantArray = Step:extend();\nConstantArray.Description = \"This Step will Extract all Constants and put them into an Array at the beginning of the script\";\nConstantArray.Name = \"Constant Array\";\n\nConstantArray.SettingsDescriptor = {\n\tTreshold = {\n\t\tname = \"Treshold\",\n\t\tdescription = \"The relative amount of nodes that will be affected\",\n\t\ttype = \"number\",\n\t\tdefault = 1,\n\t\tmin = 0,\n\t\tmax = 1,\n\t},\n\tStringsOnly = {\n\t\tname = \"StringsOnly\",\n\t\tdescription = \"Wether to only Extract Strings\",\n\t\ttype = \"boolean\",\n\t\tdefault = false,\n\t},\n\tShuffle = {\n\t\tname = \"Shuffle\",\n\t\tdescription = \"Wether to shuffle the order of Elements in the Array\",\n\t\ttype = \"boolean\",\n\t\tdefault = true,\n\t},\n\tRotate = {\n\t\tname = \"Rotate\",\n\t\tdescription = \"Wether to rotate the String Array by a specific (random) amount. This will be undone on runtime.\",\n\t\ttype = \"boolean\",\n\t\tdefault = true,\n\t},\n\tLocalWrapperTreshold = {\n\t\tname = \"LocalWrapperTreshold\",\n\t\tdescription = \"The relative amount of nodes functions, that will get local wrappers\",\n\t\ttype = \"number\",\n\t\tdefault = 1,\n\t\tmin = 0,\n\t\tmax = 1,\n\t},\n\tLocalWrapperCount = {\n\t\tname = \"LocalWrapperCount\",\n\t\tdescription = \"The number of Local wrapper Functions per scope. This only applies if LocalWrapperTreshold is greater than 0\",\n\t\ttype = \"number\",\n\t\tmin = 0,\n\t\tmax = 512,\n\t\tdefault = 0,\n\t},\n\tLocalWrapperArgCount = {\n\t\tname = \"LocalWrapperArgCount\",\n\t\tdescription = \"The number of Arguments to the Local wrapper Functions\",\n\t\ttype = \"number\",\n\t\tmin = 1,\n\t\tdefault = 10,\n\t\tmax = 200,\n\t};\n\tMaxWrapperOffset = {\n\t\tname = \"MaxWrapperOffset\",\n\t\tdescription = \"The Max Offset for the Wrapper Functions\",\n\t\ttype = \"number\",\n\t\tmin = 0,\n\t\tdefault = 65535,\n\t};\n\tEncoding = {\n\t\tname = \"Encoding\",\n\t\tdescription = \"The Encoding to use for the Strings\",\n\t\ttype = \"enum\",\n\t\tdefault = \"base64\",\n\t\tvalues = {\n\t\t\t\"none\",\n\t\t\t\"base64\",\n\t\t},\n\t}\n}\n\nlocal function callNameGenerator(generatorFunction, ...)\n\tif(type(generatorFunction) == \"table\") then\n\t\tgeneratorFunction = generatorFunction.generateName;\n\tend\n\treturn generatorFunction(...);\nend\n\nfunction ConstantArray:init(settings)\n\t\nend\n\nfunction ConstantArray:createArray()\n\tlocal entries = {};\n\tfor i, v in ipairs(self.constants) do\n\t\tif type(v) == \"string\" then\n\t\t\tv = self:encode(v);\n\t\tend\n\t\tentries[i] = Ast.TableEntry(Ast.ConstantNode(v));\n\tend\n\treturn Ast.TableConstructorExpression(entries);\nend\n\nfunction ConstantArray:indexing(index, data)\n\tif self.LocalWrapperCount > 0 and data.functionData.local_wrappers then\n\t\tlocal wrappers = data.functionData.local_wrappers;\n\t\tlocal wrapper = wrappers[math.random(#wrappers)];\n\n\t\tlocal args = {};\n\t\tlocal ofs = index - self.wrapperOffset - wrapper.offset;\n\t\tfor i = 1, self.LocalWrapperArgCount, 1 do\n\t\t\tif i == wrapper.arg then\n\t\t\t\targs[i] = Ast.NumberExpression(ofs);\n\t\t\telse\n\t\t\t\targs[i] = Ast.NumberExpression(math.random(ofs - 1024, ofs + 1024));\n\t\t\tend\n\t\tend\n\n\t\tdata.scope:addReferenceToHigherScope(wrappers.scope, wrappers.id);\n\t\treturn Ast.FunctionCallExpression(Ast.IndexExpression(\n\t\t\tAst.VariableExpression(wrappers.scope, wrappers.id),\n\t\t\tAst.StringExpression(wrapper.index)\n\t\t), args);\n\telse\n\t\tdata.scope:addReferenceToHigherScope(self.rootScope,  self.wrapperId);\n\t\treturn Ast.FunctionCallExpression(Ast.VariableExpression(self.rootScope, self.wrapperId), {\n\t\t\tAst.NumberExpression(index - self.wrapperOffset);\n\t\t});\n\tend\nend\n\nfunction ConstantArray:getConstant(value, data)\n\tif(self.lookup[value]) then\n\t\treturn self:indexing(self.lookup[value], data)\n\tend\n\tlocal idx = #self.constants + 1;\n\tself.constants[idx] = value;\n\tself.lookup[value] = idx;\n\treturn self:indexing(idx, data);\nend\n\nfunction ConstantArray:addConstant(value)\n\tif(self.lookup[value]) then\n\t\treturn\n\tend\n\tlocal idx = #self.constants + 1;\n\tself.constants[idx] = value;\n\tself.lookup[value] = idx;\nend\n\nlocal function reverse(t, i, j)\n\twhile i < j do\n\t  t[i], t[j] = t[j], t[i]\n\t  i, j = i+1, j-1\n\tend\nend\n  \nlocal function rotate(t, d, n)\n\tn = n or #t\n\td = (d or 1) % n\n\treverse(t, 1, n)\n\treverse(t, 1, d)\n\treverse(t, d+1, n)\nend\n\nlocal rotateCode = [=[\n\tfor i, v in ipairs({{1, LEN}, {1, SHIFT}, {SHIFT + 1, LEN}}) do\n\t\twhile v[1] < v[2] do\n\t\t\tARR[v[1]], ARR[v[2]], v[1], v[2] = ARR[v[2]], ARR[v[1]], v[1] + 1, v[2] - 1\n\t\tend\n\tend\n]=];\n\nfunction ConstantArray:addRotateCode(ast, shift)\n\tlocal parser = Parser:new({\n\t\tLuaVersion = LuaVersion.Lua51;\n\t});\n\n\tlocal newAst = parser:parse(string.gsub(string.gsub(rotateCode, \"SHIFT\", tostring(shift)), \"LEN\", tostring(#self.constants)));\n\tlocal forStat = newAst.body.statements[1];\n\tforStat.body.scope:setParent(ast.body.scope);\n\tvisitast(newAst, nil, function(node, data)\n\t\tif(node.kind == AstKind.VariableExpression) then\n\t\t\tif(node.scope:getVariableName(node.id) == \"ARR\") then\n\t\t\t\tdata.scope:removeReferenceToHigherScope(node.scope, node.id);\n\t\t\t\tdata.scope:addReferenceToHigherScope(self.rootScope, self.arrId);\n\t\t\t\tnode.scope = self.rootScope;\n\t\t\t\tnode.id    = self.arrId;\n\t\t\tend\n\t\tend\n\tend)\n\n\ttable.insert(ast.body.statements, 1, forStat);\nend\n\nfunction ConstantArray:addDecodeCode(ast)\n\tif self.Encoding == \"base64\" then\n\t\tlocal base64DecodeCode = [[\n\tdo ]] .. table.concat(util.shuffle{\n\t\t\"local lookup = LOOKUP_TABLE;\",\n\t\t\"local len = string.len;\",\n\t\t\"local sub = string.sub;\",\n\t\t\"local floor = math.floor;\",\n\t\t\"local strchar = string.char;\",\n\t\t\"local insert = table.insert;\",\n\t\t\"local concat = table.concat;\",\n\t\t\"local type = type;\",\n\t\t\"local arr = ARR;\",\n\t}) .. [[\n\t\tfor i = 1, #arr do\n\t\t\tlocal data = arr[i];\n\t\t\tif type(data) == \"string\" then\n\t\t\t\tlocal length = len(data)\n\t\t\t\tlocal parts = {}\n\t\t\t\tlocal index = 1\n\t\t\t\tlocal value = 0\n\t\t\t\tlocal count = 0\n\t\t\t\twhile index <= length do\n\t\t\t\t\tlocal char = sub(data, index, index)\n\t\t\t\t\tlocal code = lookup[char]\n\t\t\t\t\tif code then\n\t\t\t\t\t\tvalue = value + code * (64 ^ (3 - count))\n\t\t\t\t\t\tcount = count + 1\n\t\t\t\t\t\tif count == 4 then\n\t\t\t\t\t\t\tcount = 0\n\t\t\t\t\t\t\tlocal c1 = floor(value / 65536)\n\t\t\t\t\t\t\tlocal c2 = floor(value % 65536 / 256)\n\t\t\t\t\t\t\tlocal c3 = value % 256\n\t\t\t\t\t\t\tinsert(parts, strchar(c1, c2, c3))\n\t\t\t\t\t\t\tvalue = 0\n\t\t\t\t\t\tend\n\t\t\t\t\telseif char == \"=\" then\n\t\t\t\t\t\tinsert(parts, strchar(floor(value / 65536)));\n\t\t\t\t\t\tif index >= length or sub(data, index + 1, index + 1) ~= \"=\" then\n\t\t\t\t\t\t\tinsert(parts, strchar(floor(value % 65536 / 256)));\n\t\t\t\t\t\tend\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tindex = index + 1\n\t\t\t\tend\n\t\t\t\tarr[i] = concat(parts)\n\t\t\tend\n\t\tend\n\tend\n]];\n\n\t\tlocal parser = Parser:new({\n\t\t\tLuaVersion = LuaVersion.Lua51;\n\t\t});\n\n\t\tlocal newAst = parser:parse(base64DecodeCode);\n\t\tlocal forStat = newAst.body.statements[1];\n\t\tforStat.body.scope:setParent(ast.body.scope);\n\n\t\tvisitast(newAst, nil, function(node, data)\n\t\t\tif(node.kind == AstKind.VariableExpression) then\n\t\t\t\tif(node.scope:getVariableName(node.id) == \"ARR\") then\n\t\t\t\t\tdata.scope:removeReferenceToHigherScope(node.scope, node.id);\n\t\t\t\t\tdata.scope:addReferenceToHigherScope(self.rootScope, self.arrId);\n\t\t\t\t\tnode.scope = self.rootScope;\n\t\t\t\t\tnode.id    = self.arrId;\n\t\t\t\tend\n\n\t\t\t\tif(node.scope:getVariableName(node.id) == \"LOOKUP_TABLE\") then\n\t\t\t\t\tdata.scope:removeReferenceToHigherScope(node.scope, node.id);\n\t\t\t\t\treturn self:createBase64Lookup();\n\t\t\t\tend\n\t\t\tend\n\t\tend)\n\t\n\t\ttable.insert(ast.body.statements, 1, forStat);\n\tend\nend\n\nfunction ConstantArray:createBase64Lookup()\n\tlocal entries = {};\n\tlocal i = 0;\n\tfor char in string.gmatch(self.base64chars, \".\") do\n\t\ttable.insert(entries, Ast.KeyedTableEntry(Ast.StringExpression(char), Ast.NumberExpression(i)));\n\t\ti = i + 1;\n\tend\n\tutil.shuffle(entries);\n\treturn Ast.TableConstructorExpression(entries);\nend\n\nfunction ConstantArray:encode(str)\n\tif self.Encoding == \"base64\" then\n\t\treturn ((str:gsub('.', function(x) \n\t\t\tlocal r,b='',x:byte()\n\t\t\tfor i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n\t\t\treturn r;\n\t\tend)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n\t\t\tif (#x < 6) then return '' end\n\t\t\tlocal c=0\n\t\t\tfor i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n\t\t\treturn self.base64chars:sub(c+1,c+1)\n\t\tend)..({ '', '==', '=' })[#str%3+1]);\n\tend\nend\n\nfunction ConstantArray:apply(ast, pipeline)\n\tself.rootScope = ast.body.scope;\n\tself.arrId     = self.rootScope:addVariable();\n\n\tself.base64chars = table.concat(util.shuffle{\n\t\t\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n\t\t\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n\t\t\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n\t\t\"+\", \"/\",\n\t});\n\n\tself.constants = {};\n\tself.lookup    = {};\n\n\t-- Extract Constants\n\tvisitast(ast, nil, function(node, data)\n\t\t-- Apply only to some nodes\n\t\tif math.random() <= self.Treshold then\n\t\t\tnode.__apply_constant_array = true;\n\t\t\tif node.kind == AstKind.StringExpression then\n\t\t\t\tself:addConstant(node.value);\n\t\t\telseif not self.StringsOnly then\n\t\t\t\tif node.isConstant then\n\t\t\t\t\tif node.value ~= nil then\n\t\t\t\t\t\tself:addConstant(node.value);\n\t\t\t\t\tend \n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend);\n\n\t-- Shuffle Array\n\tif self.Shuffle then\n\t\tself.constants = util.shuffle(self.constants);\n\t\tself.lookup    = {};\n\t\tfor i, v in ipairs(self.constants) do\n\t\t\tself.lookup[v] = i;\n\t\tend\n\tend\n\n\t-- Set Wrapper Function Offset\n\tself.wrapperOffset = math.random(-self.MaxWrapperOffset, self.MaxWrapperOffset);\n\tself.wrapperId     = self.rootScope:addVariable();\n\n\tvisitast(ast, function(node, data)\n\t\t-- Add Local Wrapper Functions\n\t\tif self.LocalWrapperCount > 0 and node.kind == AstKind.Block and node.isFunctionBlock and math.random() <= self.LocalWrapperTreshold then\n\t\t\tlocal id = node.scope:addVariable()\n\t\t\tdata.functionData.local_wrappers = {\n\t\t\t\tid = id;\n\t\t\t\tscope = node.scope,\n\t\t\t};\n\t\t\tlocal nameLookup = {};\n\t\t\tfor i = 1, self.LocalWrapperCount, 1 do\n\t\t\t\tlocal name;\n\t\t\t\trepeat\n\t\t\t\t\tname = callNameGenerator(pipeline.namegenerator, math.random(1, self.LocalWrapperArgCount * 16));\n\t\t\t\tuntil not nameLookup[name];\n\t\t\t\tnameLookup[name] = true;\n\n\t\t\t\tlocal offset = math.random(-self.MaxWrapperOffset, self.MaxWrapperOffset);\n\t\t\t\tlocal argPos = math.random(1, self.LocalWrapperArgCount);\n\n\t\t\t\tdata.functionData.local_wrappers[i] = {\n\t\t\t\t\targ   = argPos,\n\t\t\t\t\tindex = name,\n\t\t\t\t\toffset =  offset,\n\t\t\t\t};\n\t\t\t\tdata.functionData.__used = false;\n\t\t\tend\n\t\tend\n\t\tif node.__apply_constant_array then\n\t\t\tdata.functionData.__used = true;\n\t\tend\n\tend, function(node, data)\n\t\t-- Actually insert Statements to get the Constant Values\n\t\tif node.__apply_constant_array then\n\t\t\tif node.kind == AstKind.StringExpression then\n\t\t\t\treturn self:getConstant(node.value, data);\n\t\t\telseif not self.StringsOnly then\n\t\t\t\tif node.isConstant then\n\t\t\t\t\treturn node.value ~= nil and self:getConstant(node.value, data);\n\t\t\t\tend\n\t\t\tend\n\t\t\tnode.__apply_constant_array = nil;\n\t\tend\n\n\t\t-- Insert Local Wrapper Declarations\n\t\tif self.LocalWrapperCount > 0 and node.kind == AstKind.Block and node.isFunctionBlock and data.functionData.local_wrappers and data.functionData.__used then\n\t\t\tdata.functionData.__used = nil;\n\t\t\tlocal elems = {};\n\t\t\tlocal wrappers = data.functionData.local_wrappers;\n\t\t\tfor i = 1, self.LocalWrapperCount, 1 do\n\t\t\t\tlocal wrapper = wrappers[i];\n\t\t\t\tlocal argPos = wrapper.arg;\n\t\t\t\tlocal offset = wrapper.offset;\n\t\t\t\tlocal name   = wrapper.index;\n\n\t\t\t\tlocal funcScope = Scope:new(node.scope);\n\n\t\t\t\tlocal arg = nil;\n\t\t\t\tlocal args = {};\n\n\t\t\t\tfor i = 1, self.LocalWrapperArgCount, 1 do\n\t\t\t\t\targs[i] = funcScope:addVariable();\n\t\t\t\t\tif i == argPos then\n\t\t\t\t\t\targ = args[i];\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tlocal addSubArg;\n\n\t\t\t\t-- Create add and Subtract code\n\t\t\t\tif offset < 0 then\n\t\t\t\t\taddSubArg = Ast.SubExpression(Ast.VariableExpression(funcScope, arg), Ast.NumberExpression(-offset));\n\t\t\t\telse\n\t\t\t\t\taddSubArg = Ast.AddExpression(Ast.VariableExpression(funcScope, arg), Ast.NumberExpression(offset));\n\t\t\t\tend\n\n\t\t\t\tfuncScope:addReferenceToHigherScope(self.rootScope, self.wrapperId);\n\t\t\t\tlocal callArg = Ast.FunctionCallExpression(Ast.VariableExpression(self.rootScope, self.wrapperId), {\n\t\t\t\t\taddSubArg\n\t\t\t\t});\n\n\t\t\t\tlocal fargs = {};\n\t\t\t\tfor i, v in ipairs(args) do\n\t\t\t\t\tfargs[i] = Ast.VariableExpression(funcScope, v);\n\t\t\t\tend\n\n\t\t\t\telems[i] = Ast.KeyedTableEntry(\n\t\t\t\t\tAst.StringExpression(name),\n\t\t\t\t\tAst.FunctionLiteralExpression(fargs, Ast.Block({\n\t\t\t\t\t\tAst.ReturnStatement({\n\t\t\t\t\t\t\tcallArg\n\t\t\t\t\t\t});\n\t\t\t\t\t}, funcScope))\n\t\t\t\t)\n\t\t\tend\n\t\t\ttable.insert(node.statements, 1, Ast.LocalVariableDeclaration(node.scope, {\n\t\t\t\twrappers.id\n\t\t\t}, {\n\t\t\t\tAst.TableConstructorExpression(elems)\n\t\t\t}));\n\t\tend\n\tend);\n\n\tself:addDecodeCode(ast);\n\n\tlocal steps = util.shuffle({\n\t\t-- Add Wrapper Function Code\n\t\tfunction() \n\t\t\tlocal funcScope = Scope:new(self.rootScope);\n\t\t\t-- Add Reference to Array\n\t\t\tfuncScope:addReferenceToHigherScope(self.rootScope, self.arrId);\n\n\t\t\tlocal arg = funcScope:addVariable();\n\t\t\tlocal addSubArg;\n\n\t\t\t-- Create add and Subtract code\n\t\t\tif self.wrapperOffset < 0 then\n\t\t\t\taddSubArg = Ast.SubExpression(Ast.VariableExpression(funcScope, arg), Ast.NumberExpression(-self.wrapperOffset));\n\t\t\telse\n\t\t\t\taddSubArg = Ast.AddExpression(Ast.VariableExpression(funcScope, arg), Ast.NumberExpression(self.wrapperOffset));\n\t\t\tend\n\n\t\t\t-- Create and Add the Function Declaration\n\t\t\ttable.insert(ast.body.statements, 1, Ast.LocalFunctionDeclaration(self.rootScope, self.wrapperId, {\n\t\t\t\tAst.VariableExpression(funcScope, arg)\n\t\t\t}, Ast.Block({\n\t\t\t\tAst.ReturnStatement({\n\t\t\t\t\tAst.IndexExpression(\n\t\t\t\t\t\tAst.VariableExpression(self.rootScope, self.arrId),\n\t\t\t\t\t\taddSubArg\n\t\t\t\t\t)\n\t\t\t\t});\n\t\t\t}, funcScope)));\n\n\t\t\t-- Resulting Code:\n\t\t\t-- function xy(a)\n\t\t\t-- \t\treturn ARR[a - 10]\n\t\t\t-- end\n\t\tend,\n\t\t-- Rotate Array and Add unrotate code\n\t\tfunction()\n\t\t\tif self.Rotate and #self.constants > 1 then\n\t\t\t\tlocal shift = math.random(1, #self.constants - 1);\n\n\t\t\t\trotate(self.constants, -shift);\n\t\t\t\tself:addRotateCode(ast, shift);\n\t\t\tend\n\t\tend,\n\t});\n\n\tfor i, f in ipairs(steps) do\n\t\tf();\n\tend\n\n\t-- Add the Array Declaration\n\ttable.insert(ast.body.statements, 1, Ast.LocalVariableDeclaration(self.rootScope, {self.arrId}, {self:createArray()}));\n\n\tself.rootScope = nil;\n\tself.arrId     = nil;\n\n\tself.constants = nil;\n\tself.lookup    = nil;\nend\n\nreturn ConstantArray;",
  "prometheus.steps.EncryptStrings": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- EncryptStrings.lua\n--\n-- This Script provides a Simple Obfuscation Step that encrypts strings\n\nlocal Step = require(\"prometheus.step\")\nlocal Ast = require(\"prometheus.ast\")\nlocal Scope = require(\"prometheus.scope\")\nlocal RandomStrings = require(\"prometheus.randomStrings\")\nlocal Parser = require(\"prometheus.parser\")\nlocal Enums = require(\"prometheus.enums\")\nlocal logger = require(\"logger\")\nlocal visitast = require(\"prometheus.visitast\");\nlocal util     = require(\"prometheus.util\")\nlocal AstKind = Ast.AstKind;\n\nlocal EncryptStrings = Step:extend()\nEncryptStrings.Description = \"This Step will encrypt strings within your Program.\"\nEncryptStrings.Name = \"Encrypt Strings\"\n\nEncryptStrings.SettingsDescriptor = {}\n\nfunction EncryptStrings:init(settings) end\n\n\nfunction EncryptStrings:CreateEncrypionService()\n\tlocal usedSeeds = {};\n\n\tlocal secret_key_6 = math.random(0, 63) -- 6-bit  arbitrary integer (0..63)\n\tlocal secret_key_7 = math.random(0, 127) -- 7-bit  arbitrary integer (0..127)\n\tlocal secret_key_44 = math.random(0, 17592186044415) -- 44-bit arbitrary integer (0..17592186044415)\n\tlocal secret_key_8 = math.random(0, 255); -- 8-bit  arbitrary integer (0..255)\n\n\tlocal floor = math.floor\n\n\tlocal function primitive_root_257(idx)\n\t\tlocal g, m, d = 1, 128, 2 * idx + 1\n\t\trepeat\n\t\t\tg, m, d = g * g * (d >= m and 3 or 1) % 257, m / 2, d % m\n\t\tuntil m < 1\n\t\treturn g\n\tend\n\n\tlocal param_mul_8 = primitive_root_257(secret_key_7)\n\tlocal param_mul_45 = secret_key_6 * 4 + 1\n\tlocal param_add_45 = secret_key_44 * 2 + 1\n\n\tlocal state_45 = 0\n\tlocal state_8 = 2\n\n\tlocal prev_values = {}\n\tlocal function set_seed(seed_53)\n\t\tstate_45 = seed_53 % 35184372088832\n\t\tstate_8 = seed_53 % 255 + 2\n\t\tprev_values = {}\n\tend\n\n\tlocal function gen_seed()\n\t\tlocal seed;\n\t\trepeat\n\t\t\tseed = math.random(0, 35184372088832);\n\t\tuntil not usedSeeds[seed];\n\t\tusedSeeds[seed] = true;\n\t\treturn seed;\n\tend\n\n\tlocal function get_random_32()\n\t\tstate_45 = (state_45 * param_mul_45 + param_add_45) % 35184372088832\n\t\trepeat\n\t\t\tstate_8 = state_8 * param_mul_8 % 257\n\t\tuntil state_8 ~= 1\n\t\tlocal r = state_8 % 32\n\t\tlocal n = floor(state_45 / 2 ^ (13 - (state_8 - r) / 32)) % 2 ^ 32 / 2 ^ r\n\t\treturn floor(n % 1 * 2 ^ 32) + floor(n)\n\tend\n\n\tlocal function get_next_pseudo_random_byte()\n\t\tif #prev_values == 0 then\n\t\t\tlocal rnd = get_random_32() -- value 0..4294967295\n\t\t\tlocal low_16 = rnd % 65536\n\t\t\tlocal high_16 = (rnd - low_16) / 65536\n\t\t\tlocal b1 = low_16 % 256\n\t\t\tlocal b2 = (low_16 - b1) / 256\n\t\t\tlocal b3 = high_16 % 256\n\t\t\tlocal b4 = (high_16 - b3) / 256\n\t\t\tprev_values = { b1, b2, b3, b4 }\n\t\tend\n\t\t--print(unpack(prev_values))\n\t\treturn table.remove(prev_values)\n\tend\n\n\tlocal function encrypt(str)\n\t\tlocal seed = gen_seed();\n\t\tset_seed(seed)\n\t\tlocal len = string.len(str)\n\t\tlocal out = {}\n\t\tlocal prevVal = secret_key_8;\n\t\tfor i = 1, len do\n\t\t\tlocal byte = string.byte(str, i);\n\t\t\tout[i] = string.char((byte - (get_next_pseudo_random_byte() + prevVal)) % 256);\n\t\t\tprevVal = byte;\n\t\tend\n\t\treturn table.concat(out), seed;\n\tend\n\n    local function genCode()\n        local code = [[\ndo\n\tlocal floor = math.floor\n\tlocal random = math.random;\n\tlocal remove = table.remove;\n\tlocal char = string.char;\n\tlocal state_45 = 0\n\tlocal state_8 = 2\n\tlocal digits = {}\n\tlocal charmap = {};\n\tlocal i = 0;\n\n\tlocal nums = {};\n\tfor i = 1, 256 do\n\t\tnums[i] = i;\n\tend\n\n\trepeat\n\t\tlocal idx = random(1, #nums);\n\t\tlocal n = remove(nums, idx);\n\t\tcharmap[n] = char(n - 1);\n\tuntil #nums == 0;\n\n\tlocal prev_values = {}\n\tlocal function get_next_pseudo_random_byte()\n\t\tif #prev_values == 0 then\n\t\t\tstate_45 = (state_45 * ]] .. tostring(param_mul_45) .. [[ + ]] .. tostring(param_add_45) .. [[) % 35184372088832\n\t\t\trepeat\n\t\t\t\tstate_8 = state_8 * ]] .. tostring(param_mul_8) .. [[ % 257\n\t\t\tuntil state_8 ~= 1\n\t\t\tlocal r = state_8 % 32\n\t\t\tlocal n = floor(state_45 / 2 ^ (13 - (state_8 - r) / 32)) % 2 ^ 32 / 2 ^ r\n\t\t\tlocal rnd = floor(n % 1 * 2 ^ 32) + floor(n)\n\t\t\tlocal low_16 = rnd % 65536\n\t\t\tlocal high_16 = (rnd - low_16) / 65536\n\t\t\tlocal b1 = low_16 % 256\n\t\t\tlocal b2 = (low_16 - b1) / 256\n\t\t\tlocal b3 = high_16 % 256\n\t\t\tlocal b4 = (high_16 - b3) / 256\n\t\t\tprev_values = { b1, b2, b3, b4 }\n\t\tend\n\t\treturn table.remove(prev_values)\n\tend\n\n\tlocal realStrings = {};\n\tSTRINGS = setmetatable({}, {\n\t\t__index = realStrings;\n\t\t__metatable = nil;\n\t});\n  \tfunction DECRYPT(str, seed)\n\t\tlocal realStringsLocal = realStrings;\n\t\tif(realStringsLocal[seed]) then else\n\t\t\tprev_values = {};\n\t\t\tlocal chars = charmap;\n\t\t\tstate_45 = seed % 35184372088832\n\t\t\tstate_8 = seed % 255 + 2\n\t\t\tlocal len = string.len(str);\n\t\t\trealStringsLocal[seed] = \"\";\n\t\t\tlocal prevVal = ]] .. tostring(secret_key_8) .. [[;\n\t\t\tfor i=1, len do\n\t\t\t\tprevVal = (string.byte(str, i) + get_next_pseudo_random_byte() + prevVal) % 256\n\t\t\t\trealStringsLocal[seed] = realStringsLocal[seed] .. chars[prevVal + 1];\n\t\t\tend\n\t\tend\n\t\treturn seed;\n\tend\nend]]\n\n\t\treturn code;\n    end\n\n    return {\n        encrypt = encrypt,\n        param_mul_45 = param_mul_45,\n        param_mul_8 = param_mul_8,\n        param_add_45 = param_add_45,\n\t\tsecret_key_8 = secret_key_8,\n        genCode = genCode,\n    }\nend\n\nfunction EncryptStrings:apply(ast, pipeline)\n    local Encryptor = self:CreateEncrypionService();\n\n\tlocal code = Encryptor.genCode();\n\tlocal newAst = Parser:new({ LuaVersion = Enums.LuaVersion.Lua51 }):parse(code);\n\tlocal doStat = newAst.body.statements[1];\n\n\tlocal scope = ast.body.scope;\n\tlocal decryptVar = scope:addVariable();\n\tlocal stringsVar = scope:addVariable();\n\t\n\tdoStat.body.scope:setParent(ast.body.scope);\n\n\tvisitast(newAst, nil, function(node, data)\n\t\tif(node.kind == AstKind.FunctionDeclaration) then\n\t\t\tif(node.scope:getVariableName(node.id) == \"DECRYPT\") then\n\t\t\t\tdata.scope:removeReferenceToHigherScope(node.scope, node.id);\n\t\t\t\tdata.scope:addReferenceToHigherScope(scope, decryptVar);\n\t\t\t\tnode.scope = scope;\n\t\t\t\tnode.id    = decryptVar;\n\t\t\tend\n\t\tend\n\t\tif(node.kind == AstKind.AssignmentVariable or node.kind == AstKind.VariableExpression) then\n\t\t\tif(node.scope:getVariableName(node.id) == \"STRINGS\") then\n\t\t\t\tdata.scope:removeReferenceToHigherScope(node.scope, node.id);\n\t\t\t\tdata.scope:addReferenceToHigherScope(scope, stringsVar);\n\t\t\t\tnode.scope = scope;\n\t\t\t\tnode.id    = stringsVar;\n\t\t\tend\n\t\tend\n\tend)\n\n\tvisitast(ast, nil, function(node, data)\n\t\tif(node.kind == AstKind.StringExpression) then\n\t\t\tdata.scope:addReferenceToHigherScope(scope, stringsVar);\n\t\t\tdata.scope:addReferenceToHigherScope(scope, decryptVar);\n\t\t\tlocal encrypted, seed = Encryptor.encrypt(node.value);\n\t\t\treturn Ast.IndexExpression(Ast.VariableExpression(scope, stringsVar), Ast.FunctionCallExpression(Ast.VariableExpression(scope, decryptVar), {\n\t\t\t\tAst.StringExpression(encrypted), Ast.NumberExpression(seed),\n\t\t\t}));\n\t\tend\n\tend)\n\n\n\t-- Insert to Main Ast\n\ttable.insert(ast.body.statements, 1, doStat);\n\ttable.insert(ast.body.statements, 1, Ast.LocalVariableDeclaration(scope, util.shuffle{ decryptVar, stringsVar }, {}));\n\treturn ast\nend\n\nreturn EncryptStrings\n",
  "prometheus.steps.NumbersToExpressions": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- NumbersToExpressions.lua\n--\n-- This Script provides an Obfuscation Step, that converts Number Literals to expressions\nunpack = unpack or table.unpack;\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal visitast = require(\"prometheus.visitast\");\nlocal util     = require(\"prometheus.util\")\n\nlocal AstKind = Ast.AstKind;\n\nlocal NumbersToExpressions = Step:extend();\nNumbersToExpressions.Description = \"This Step Converts number Literals to Expressions\";\nNumbersToExpressions.Name = \"Numbers To Expressions\";\n\nNumbersToExpressions.SettingsDescriptor = {\n\tTreshold = {\n        type = \"number\",\n        default = 1,\n        min = 0,\n        max = 1,\n    },\n    InternalTreshold = {\n        type = \"number\",\n        default = 0.2,\n        min = 0,\n        max = 0.8,\n    }\n}\n\nfunction NumbersToExpressions:init(settings)\n\tself.ExpressionGenerators = {\n        function(val, depth) -- Addition\n            local val2 = math.random(-2^20, 2^20);\n            local diff = val - val2;\n            if tonumber(tostring(diff)) + tonumber(tostring(val2)) ~= val then\n                return false;\n            end\n            return Ast.AddExpression(self:CreateNumberExpression(val2, depth), self:CreateNumberExpression(diff, depth), false);\n        end, \n        function(val, depth) -- Subtraction\n            local val2 = math.random(-2^20, 2^20);\n            local diff = val + val2;\n            if tonumber(tostring(diff)) - tonumber(tostring(val2)) ~= val then\n                return false;\n            end\n            return Ast.SubExpression(self:CreateNumberExpression(diff, depth), self:CreateNumberExpression(val2, depth), false);\n        end\n    }\nend\n\nfunction NumbersToExpressions:CreateNumberExpression(val, depth)\n    if depth > 0 and math.random() >= self.InternalTreshold or depth > 15 then\n        return Ast.NumberExpression(val)\n    end\n\n    local generators = util.shuffle({unpack(self.ExpressionGenerators)});\n    for i, generator in ipairs(generators) do\n        local node = generator(val, depth + 1);\n        if node then\n            return node;\n        end\n    end\n\n    return Ast.NumberExpression(val)\nend\n\nfunction NumbersToExpressions:apply(ast)\n\tvisitast(ast, nil, function(node, data)\n        if node.kind == AstKind.NumberExpression then\n            if math.random() <= self.Treshold then\n                return self:CreateNumberExpression(node.value, 0);\n            end\n        end\n    end)\nend\n\nreturn NumbersToExpressions;",
  "prometheus.steps.ProxifyLocals": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- ProxifyLocals.lua\n--\n-- This Script provides a Obfuscation Step for putting all Locals into Proxy Objects\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal visitast = require(\"prometheus.visitast\");\nlocal RandomLiterals = require(\"prometheus.randomLiterals\")\n\nlocal AstKind = Ast.AstKind;\n\nlocal ProifyLocals = Step:extend();\nProifyLocals.Description = \"This Step wraps all locals into Proxy Objects\";\nProifyLocals.Name = \"Proxify Locals\";\n\nProifyLocals.SettingsDescriptor = {\n\tLiteralType = {\n\t\tname = \"LiteralType\",\n\t\tdescription = \"The type of the randomly generated literals\",\n\t\ttype = \"enum\",\n\t\tvalues = {\n\t\t\t\"dictionary\",\n\t\t\t\"number\",\n\t\t\t\"string\",\n            \"any\",\n\t\t},\n\t\tdefault = \"string\",\n\t},\n}\n\nlocal function shallowcopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == 'table' then\n        copy = {}\n        for orig_key, orig_value in pairs(orig) do\n            copy[orig_key] = orig_value\n        end\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\n\nlocal function callNameGenerator(generatorFunction, ...)\n\tif(type(generatorFunction) == \"table\") then\n\t\tgeneratorFunction = generatorFunction.generateName;\n\tend\n\treturn generatorFunction(...);\nend\n\nlocal MetatableExpressions = {\n    {\n        constructor = Ast.AddExpression,\n        key = \"__add\";\n    },\n    {\n        constructor = Ast.SubExpression,\n        key = \"__sub\";\n    },\n    {\n        constructor = Ast.IndexExpression,\n        key = \"__index\";\n    },\n    {\n        constructor = Ast.MulExpression,\n        key = \"__mul\";\n    },\n    {\n        constructor = Ast.DivExpression,\n        key = \"__div\";\n    },\n    {\n        constructor = Ast.PowExpression,\n        key = \"__pow\";\n    },\n    {\n        constructor = Ast.StrCatExpression,\n        key = \"__concat\";\n    }\n}\n\nfunction ProifyLocals:init(settings)\n\t\nend\n\nlocal function generateLocalMetatableInfo(pipeline)\n    local usedOps = {};\n    local info = {};\n    for i, v in ipairs({\"setValue\",\"getValue\", \"index\"}) do\n        local rop;\n        repeat\n            rop = MetatableExpressions[math.random(#MetatableExpressions)];\n        until not usedOps[rop];\n        usedOps[rop] = true;\n        info[v] = rop;\n    end\n\n    info.valueName = callNameGenerator(pipeline.namegenerator, math.random(1, 4096));\n\n    return info;\nend\n\nfunction ProifyLocals:CreateAssignmentExpression(info, expr, parentScope)\n    local metatableVals = {};\n\n    -- Setvalue Entry\n    local setValueFunctionScope = Scope:new(parentScope);\n    local setValueSelf = setValueFunctionScope:addVariable();\n    local setValueArg = setValueFunctionScope:addVariable();\n    local setvalueFunctionLiteral = Ast.FunctionLiteralExpression(\n        {\n            Ast.VariableExpression(setValueFunctionScope, setValueSelf), -- Argument 1\n            Ast.VariableExpression(setValueFunctionScope, setValueArg), -- Argument 2\n        },\n        Ast.Block({ -- Create Function Body\n            Ast.AssignmentStatement({\n                Ast.AssignmentIndexing(Ast.VariableExpression(setValueFunctionScope, setValueSelf), Ast.StringExpression(info.valueName));\n            }, {\n                Ast.VariableExpression(setValueFunctionScope, setValueArg)\n            })\n        }, setValueFunctionScope)\n    );\n    table.insert(metatableVals, Ast.KeyedTableEntry(Ast.StringExpression(info.setValue.key), setvalueFunctionLiteral));\n\n    -- Getvalue Entry\n    local getValueFunctionScope = Scope:new(parentScope);\n    local getValueSelf = getValueFunctionScope:addVariable();\n    local getValueArg = getValueFunctionScope:addVariable();\n    local getValueIdxExpr;\n    if(info.getValue.key == \"__index\" or info.setValue.key == \"__index\") then\n        getValueIdxExpr = Ast.FunctionCallExpression(Ast.VariableExpression(getValueFunctionScope:resolveGlobal(\"rawget\")), {\n            Ast.VariableExpression(getValueFunctionScope, getValueSelf),\n            Ast.StringExpression(info.valueName),\n        });\n    else\n        getValueIdxExpr = Ast.IndexExpression(Ast.VariableExpression(getValueFunctionScope, getValueSelf), Ast.StringExpression(info.valueName));\n    end\n    local getvalueFunctionLiteral = Ast.FunctionLiteralExpression(\n        {\n            Ast.VariableExpression(getValueFunctionScope, getValueSelf), -- Argument 1\n            Ast.VariableExpression(getValueFunctionScope, getValueArg), -- Argument 2\n        },\n        Ast.Block({ -- Create Function Body\n            Ast.ReturnStatement({\n                getValueIdxExpr;\n            });\n        }, getValueFunctionScope)\n    );\n    table.insert(metatableVals, Ast.KeyedTableEntry(Ast.StringExpression(info.getValue.key), getvalueFunctionLiteral));\n\n    parentScope:addReferenceToHigherScope(self.setMetatableVarScope, self.setMetatableVarId);\n    return Ast.FunctionCallExpression(\n        Ast.VariableExpression(self.setMetatableVarScope, self.setMetatableVarId),\n        {\n            Ast.TableConstructorExpression({\n                Ast.KeyedTableEntry(Ast.StringExpression(info.valueName), expr)\n            }),\n            Ast.TableConstructorExpression(metatableVals)\n        }\n    );\nend\n\nfunction ProifyLocals:apply(ast, pipeline)\n    local localMetatableInfos = {};\n    local function getLocalMetatableInfo(scope, id)\n        -- Global Variables should not be transformed\n        if(scope.isGlobal) then return nil end;\n\n        localMetatableInfos[scope] = localMetatableInfos[scope] or {};\n        if localMetatableInfos[scope][id] then\n            -- If locked, return no Metatable\n            if localMetatableInfos[scope][id].locked then\n                return nil\n            end\n            return localMetatableInfos[scope][id];\n        end\n        local localMetatableInfo = generateLocalMetatableInfo(pipeline);\n        localMetatableInfos[scope][id] = localMetatableInfo;\n        return localMetatableInfo;\n    end\n\n    local function disableMetatableInfo(scope, id)\n        -- Global Variables should not be transformed\n        if(scope.isGlobal) then return nil end;\n\n        localMetatableInfos[scope] = localMetatableInfos[scope] or {};\n        localMetatableInfos[scope][id] = {locked = true}\n    end\n\n    -- Create Setmetatable Variable\n    self.setMetatableVarScope = ast.body.scope;\n    self.setMetatableVarId    = ast.body.scope:addVariable();\n\n    -- Create Empty Function Variable\n    self.emptyFunctionScope   = ast.body.scope;\n    self.emptyFunctionId      = ast.body.scope:addVariable();\n    self.emptyFunctionUsed    = false;\n\n    -- Add Empty Function Declaration\n    table.insert(ast.body.statements, 1, Ast.LocalVariableDeclaration(self.emptyFunctionScope, {self.emptyFunctionId}, {\n        Ast.FunctionLiteralExpression({}, Ast.Block({}, Scope:new(ast.body.scope)));\n    }));\n\n\n    visitast(ast, function(node, data)\n        -- Lock for loop variables\n        if(node.kind == AstKind.ForStatement) then\n            disableMetatableInfo(node.scope, node.id)\n        end\n        if(node.kind == AstKind.ForInStatement) then\n            for i, id in ipairs(node.ids) do\n                disableMetatableInfo(node.scope, id);\n            end\n        end\n\n        -- Lock Function Arguments\n        if(node.kind == AstKind.FunctionDeclaration or node.kind == AstKind.LocalFunctionDeclaration or node.kind == AstKind.FunctionLiteralExpression) then\n            for i, expr in ipairs(node.args) do\n                if expr.kind == AstKind.VariableExpression then\n                    disableMetatableInfo(expr.scope, expr.id);\n                end\n            end\n        end\n\n        -- Assignment Statements may be Obfuscated Differently\n        if(node.kind == AstKind.AssignmentStatement) then\n            if(#node.lhs == 1 and node.lhs[1].kind == AstKind.AssignmentVariable) then\n                local variable = node.lhs[1];\n                local localMetatableInfo = getLocalMetatableInfo(variable.scope, variable.id);\n                if localMetatableInfo then\n                    local args = shallowcopy(node.rhs);\n                    local vexp = Ast.VariableExpression(variable.scope, variable.id);\n                    vexp.__ignoreProxifyLocals = true;\n                    args[1] = localMetatableInfo.setValue.constructor(vexp, args[1]);\n                    self.emptyFunctionUsed = true;\n                    data.scope:addReferenceToHigherScope(self.emptyFunctionScope, self.emptyFunctionId);\n                    return Ast.FunctionCallStatement(Ast.VariableExpression(self.emptyFunctionScope, self.emptyFunctionId), args);\n                end\n            end\n        end\n    end, function(node, data)\n        -- Local Variable Declaration\n        if(node.kind == AstKind.LocalVariableDeclaration) then\n            for i, id in ipairs(node.ids) do\n                local expr = node.expressions[i] or Ast.NilExpression();\n                local localMetatableInfo = getLocalMetatableInfo(node.scope, id);\n                -- Apply Only to Some Variables if Treshold is non 1\n                if localMetatableInfo then\n                    local newExpr = self:CreateAssignmentExpression(localMetatableInfo, expr, node.scope);\n                    node.expressions[i] = newExpr;\n                end\n            end\n        end\n\n        -- Variable Expression\n        if(node.kind == AstKind.VariableExpression and not node.__ignoreProxifyLocals) then\n            local localMetatableInfo = getLocalMetatableInfo(node.scope, node.id);\n            -- Apply Only to Some Variables if Treshold is non 1\n            if localMetatableInfo then\n                local literal;\n                if self.LiteralType == \"dictionary\" then\n                    literal = RandomLiterals.Dictionary();\n                elseif self.LiteralType == \"number\" then\n                    literal = RandomLiterals.Number();\n                elseif self.LiteralType == \"string\" then\n                    literal = RandomLiterals.String(pipeline);\n                else\n                    literal = RandomLiterals.Any(pipeline);\n                end\n                return localMetatableInfo.getValue.constructor(node, literal);\n            end\n        end\n\n        -- Assignment Variable for Assignment Statement\n        if(node.kind == AstKind.AssignmentVariable) then\n            local localMetatableInfo = getLocalMetatableInfo(node.scope, node.id);\n            -- Apply Only to Some Variables if Treshold is non 1\n            if localMetatableInfo then\n                return Ast.AssignmentIndexing(node, Ast.StringExpression(localMetatableInfo.valueName));\n            end\n        end\n\n        -- Local Function Declaration\n        if(node.kind == AstKind.LocalFunctionDeclaration) then\n            local localMetatableInfo = getLocalMetatableInfo(node.scope, node.id);\n            -- Apply Only to Some Variables if Treshold is non 1\n            if localMetatableInfo then\n                local funcLiteral = Ast.FunctionLiteralExpression(node.args, node.body);\n                local newExpr = self:CreateAssignmentExpression(localMetatableInfo, funcLiteral, node.scope);\n                return Ast.LocalVariableDeclaration(node.scope, {node.id}, {newExpr});\n            end\n        end\n\n        -- Function Declaration\n        if(node.kind == AstKind.FunctionDeclaration) then\n            local localMetatableInfo = getLocalMetatableInfo(node.scope, node.id);\n            if(localMetatableInfo) then\n                table.insert(node.indices, 1, localMetatableInfo.valueName);\n            end\n        end\n    end)\n\n    -- Add Setmetatable Variable Declaration\n    table.insert(ast.body.statements, 1, Ast.LocalVariableDeclaration(self.setMetatableVarScope, {self.setMetatableVarId}, {\n        Ast.VariableExpression(self.setMetatableVarScope:resolveGlobal(\"setmetatable\"))\n    }));\nend\n\nreturn ProifyLocals;",
  "prometheus.steps.SplitStrings": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- SplitStrings.lua\n--\n-- This Script provides a Simple Obfuscation Step for splitting Strings\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal visitAst = require(\"prometheus.visitast\");\nlocal Parser = require(\"prometheus.parser\");\nlocal util = require(\"prometheus.util\");\nlocal enums = require(\"prometheus.enums\")\n\nlocal LuaVersion = enums.LuaVersion;\n\nlocal SplitStrings = Step:extend();\nSplitStrings.Description = \"This Step splits Strings to a specific or random length\";\nSplitStrings.Name = \"Split Strings\";\n\nSplitStrings.SettingsDescriptor = {\n\tTreshold = {\n\t\tname = \"Treshold\",\n\t\tdescription = \"The relative amount of nodes that will be affected\",\n\t\ttype = \"number\",\n\t\tdefault = 1,\n\t\tmin = 0,\n\t\tmax = 1,\n\t},\n\tMinLength = {\n\t\tname = \"MinLength\",\n\t\tdescription = \"The minimal length for the chunks in that the Strings are splitted\",\n\t\ttype = \"number\",\n\t\tdefault = 5,\n\t\tmin = 1,\n\t\tmax = nil,\n\t},\n\tMaxLength = {\n\t\tname = \"MaxLength\",\n\t\tdescription = \"The maximal length for the chunks in that the Strings are splitted\",\n\t\ttype = \"number\",\n\t\tdefault = 5,\n\t\tmin = 1,\n\t\tmax = nil,\n\t},\n\tConcatenationType = {\n\t\tname = \"ConcatenationType\",\n\t\tdescription = \"The Functions used for Concatenation. Note that when using custom, the String Array will also be Shuffled\",\n\t\ttype = \"enum\",\n\t\tvalues = {\n\t\t\t\"strcat\",\n\t\t\t\"table\",\n\t\t\t\"custom\",\n\t\t},\n\t\tdefault = \"custom\",\n\t},\n\tCustomFunctionType = {\n\t\tname = \"CustomFunctionType\",\n\t\tdescription = \"The Type of Function code injection This Option only applies when custom Concatenation is selected.\\\nNote that when chosing inline, the code size may increase significantly!\",\n\t\ttype = \"enum\",\n\t\tvalues = {\n\t\t\t\"global\",\n\t\t\t\"local\",\n\t\t\t\"inline\",\n\t\t},\n\t\tdefault = \"global\",\n\t},\n\tCustomLocalFunctionsCount = {\n\t\tname = \"CustomLocalFunctionsCount\",\n\t\tdescription = \"The number of local functions per scope. This option only applies when CustomFunctionType = local\",\n\t\ttype = \"number\",\n\t\tdefault = 2,\n\t\tmin = 1,\n\t}\n}\n\nfunction SplitStrings:init(settings) end\n\nlocal function generateTableConcatNode(chunks, data)\n\tlocal chunkNodes = {};\n\tfor i, chunk in ipairs(chunks) do\n\t\ttable.insert(chunkNodes, Ast.TableEntry(Ast.StringExpression(chunk)));\n\tend\n\tlocal tb = Ast.TableConstructorExpression(chunkNodes);\n\tdata.scope:addReferenceToHigherScope(data.tableConcatScope, data.tableConcatId);\n\treturn Ast.FunctionCallExpression(Ast.VariableExpression(data.tableConcatScope, data.tableConcatId), {tb});\t\nend\n\nlocal function generateStrCatNode(chunks)\n\t-- Put Together Expression for Concatenating String\n\tlocal generatedNode = nil;\n\tfor i, chunk in ipairs(chunks) do\n\t\tif generatedNode then\n\t\t\tgeneratedNode = Ast.StrCatExpression(generatedNode, Ast.StringExpression(chunk));\n\t\telse\n\t\t\tgeneratedNode = Ast.StringExpression(chunk);\n\t\tend\n\tend\n\treturn generatedNode\nend\n\nlocal customVariants = 2;\nlocal custom1Code = [=[\nfunction custom(table)\n    local stringTable, str = table[#table], \"\";\n    for i=1,#stringTable, 1 do\n        str = str .. stringTable[table[i]];\n\tend\n\treturn str\nend\n]=];\n\nlocal custom2Code = [=[\nfunction custom(tb)\n\tlocal str = \"\";\n\tfor i=1, #tb / 2, 1 do\n\t\tstr = str .. tb[#tb / 2 + tb[i]];\n\tend\n\treturn str\nend\n]=];\n\nlocal function generateCustomNodeArgs(chunks, data, variant)\n\tlocal shuffled = {};\n\tlocal shuffledIndices = {};\n\tfor i = 1, #chunks, 1 do\n\t\tshuffledIndices[i] = i;\n\tend\n\tutil.shuffle(shuffledIndices);\n\t\n\tfor i, v in ipairs(shuffledIndices) do\n\t\tshuffled[v] = chunks[i];\n\tend\n\t\n\t-- Custom Function Type 1\n\tif variant == 1 then\n\t\tlocal args = {};\n\t\tlocal tbNodes = {};\n\t\t\n\t\tfor i, v in ipairs(shuffledIndices) do\n\t\t\ttable.insert(args, Ast.TableEntry(Ast.NumberExpression(v)));\n\t\tend\n\t\t\n\t\tfor i, chunk in ipairs(shuffled) do\n\t\t\ttable.insert(tbNodes, Ast.TableEntry(Ast.StringExpression(chunk)));\n\t\tend\n\t\t\n\t\tlocal tb = Ast.TableConstructorExpression(tbNodes);\n\t\t\n\t\ttable.insert(args, Ast.TableEntry(tb));\n\t\treturn {Ast.TableConstructorExpression(args)};\n\t\t\n\t-- Custom Function Type 2\n\telse\n\t\t\n\t\tlocal args = {};\n\t\tfor i, v in ipairs(shuffledIndices) do\n\t\t\ttable.insert(args, Ast.TableEntry(Ast.NumberExpression(v)));\n\t\tend\n\t\tfor i, chunk in ipairs(shuffled) do\n\t\t\ttable.insert(args, Ast.TableEntry(Ast.StringExpression(chunk)));\n\t\tend\n\t\treturn {Ast.TableConstructorExpression(args)};\n\tend\n\t\nend\n\nlocal function generateCustomFunctionLiteral(parentScope, variant)\n\tlocal parser = Parser:new({\n\t\tLuaVersion = LuaVersion.Lua52;\n\t});\n\n\t-- Custom Function Type 1\n\tif variant == 1 then\n\t\tlocal funcDeclNode = parser:parse(custom1Code).body.statements[1];\n\t\tlocal funcBody = funcDeclNode.body;\n\t\tlocal funcArgs = funcDeclNode.args;\n\t\tfuncBody.scope:setParent(parentScope);\n\t\treturn Ast.FunctionLiteralExpression(funcArgs, funcBody);\n\t\t\n\t\t-- Custom Function Type 2\n\telse\n\t\tlocal funcDeclNode = parser:parse(custom2Code).body.statements[1];\n\t\tlocal funcBody = funcDeclNode.body;\n\t\tlocal funcArgs = funcDeclNode.args;\n\t\tfuncBody.scope:setParent(parentScope);\n\t\treturn Ast.FunctionLiteralExpression(funcArgs, funcBody);\n\tend\nend\n\nlocal function generateGlobalCustomFunctionDeclaration(ast, data)\n\tlocal parser = Parser:new({\n\t\tLuaVersion = LuaVersion.Lua52;\n\t});\n\t\n\t-- Custom Function Type 1\n\tif data.customFunctionVariant == 1 then\n\t\tlocal astScope = ast.body.scope;\n\t\tlocal funcDeclNode = parser:parse(custom1Code).body.statements[1];\n\t\tlocal funcBody = funcDeclNode.body;\n\t\tlocal funcArgs = funcDeclNode.args;\n\t\tfuncBody.scope:setParent(astScope);\n\t\treturn Ast.LocalVariableDeclaration(astScope, {data.customFuncId},\n\t\t{Ast.FunctionLiteralExpression(funcArgs, funcBody)});\n\t-- Custom Function Type 2\n\telse\n\t\tlocal astScope = ast.body.scope;\n\t\tlocal funcDeclNode = parser:parse(custom2Code).body.statements[1];\n\t\tlocal funcBody = funcDeclNode.body;\n\t\tlocal funcArgs = funcDeclNode.args;\n\t\tfuncBody.scope:setParent(astScope);\n\t\treturn Ast.LocalVariableDeclaration(data.customFuncScope, {data.customFuncId},\n\t\t{Ast.FunctionLiteralExpression(funcArgs, funcBody)});\n\tend\nend\n\nfunction SplitStrings:variant()\n\treturn math.random(1, customVariants);\nend\n\nfunction SplitStrings:apply(ast, pipeline)\n\tlocal data = {};\n\t\n\t\n\tif(self.ConcatenationType == \"table\") then\n\t\tlocal scope = ast.body.scope;\n\t\tlocal id = scope:addVariable();\n\t\tdata.tableConcatScope = scope;\n\t\tdata.tableConcatId = id;\n\telseif(self.ConcatenationType == \"custom\") then\n\t\tdata.customFunctionType = self.CustomFunctionType;\n\t\tif data.customFunctionType == \"global\" then\n\t\t\tlocal scope = ast.body.scope;\n\t\t\tlocal id = scope:addVariable();\n\t\t\tdata.customFuncScope = scope;\n\t\t\tdata.customFuncId = id;\n\t\t\tdata.customFunctionVariant = self:variant();\n\t\tend\n\tend\n\t\n\t\n\tlocal customLocalFunctionsCount = self.CustomLocalFunctionsCount;\n\tlocal self2 = self;\n\t\n\tvisitAst(ast, function(node, data) \n\t\t-- Previsit Function\n\t\t\n\t\t-- Create Local Function declarations\n\t\tif(self.ConcatenationType == \"custom\" and data.customFunctionType == \"local\" and node.kind == Ast.AstKind.Block and node.isFunctionBlock) then\n\t\t\tdata.functionData.localFunctions = {};\n\t\t\tfor i = 1, customLocalFunctionsCount, 1 do\n\t\t\t\tlocal scope = data.scope;\n\t\t\t\tlocal id = scope:addVariable();\n\t\t\t\tlocal variant = self:variant();\n\t\t\t\ttable.insert(data.functionData.localFunctions, {\n\t\t\t\t\tscope = scope,\n\t\t\t\t\tid = id,\n\t\t\t\t\tvariant = variant,\n\t\t\t\t\tused = false,\n\t\t\t\t});\n\t\t\tend\n\t\tend\n\t\t\n\tend, function(node, data)\n\t\t-- PostVisit Function\n\t\t\n\t\t-- Create actual function literals for local customFunctionType\n\t\tif(self.ConcatenationType == \"custom\" and data.customFunctionType == \"local\" and node.kind == Ast.AstKind.Block and node.isFunctionBlock) then\n\t\t\tfor i, func in ipairs(data.functionData.localFunctions) do\n\t\t\t\tif func.used then\n\t\t\t\t\tlocal literal = generateCustomFunctionLiteral(func.scope, func.variant);\n\t\t\t\t\ttable.insert(node.statements, 1, Ast.LocalVariableDeclaration(func.scope, {func.id}, {literal}));\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\t\n\t\t-- Apply Only to String nodes\n\t\tif(node.kind == Ast.AstKind.StringExpression) then\n\t\t\tlocal str = node.value;\n\t\t\tlocal chunks = {};\n\t\t\tlocal i = 1;\n\t\t\t\n\t\t\t-- Split String into Parts of length between MinLength and MaxLength\n\t\t\twhile i <= string.len(str) do\n\t\t\t\tlocal len = math.random(self.MinLength, self.MaxLength);\n\t\t\t\ttable.insert(chunks, string.sub(str, i, i + len - 1));\n\t\t\t\ti = i + len;\n\t\t\tend\n\t\t\t\n\t\t\tif(#chunks > 1) then\n\t\t\t\tif math.random() < self.Treshold then\n\t\t\t\t\tif self.ConcatenationType == \"strcat\" then\n\t\t\t\t\t\tnode = generateStrCatNode(chunks);\n\t\t\t\t\telseif self.ConcatenationType == \"table\" then\n\t\t\t\t\t\tnode = generateTableConcatNode(chunks, data);\n\t\t\t\t\telseif self.ConcatenationType == \"custom\" then\n\t\t\t\t\t\tif self.CustomFunctionType == \"global\" then\n\t\t\t\t\t\t\tlocal args = generateCustomNodeArgs(chunks, data, data.customFunctionVariant);\n\t\t\t\t\t\t\t-- Add Reference for Variable Renaming\n\t\t\t\t\t\t\tdata.scope:addReferenceToHigherScope(data.customFuncScope, data.customFuncId);\n\t\t\t\t\t\t\tnode = Ast.FunctionCallExpression(Ast.VariableExpression(data.customFuncScope, data.customFuncId), args);\n\t\t\t\t\t\telseif self.CustomFunctionType == \"local\" then\n\t\t\t\t\t\t\tlocal lfuncs = data.functionData.localFunctions;\n\t\t\t\t\t\t\tlocal idx = math.random(1, #lfuncs);\n\t\t\t\t\t\t\tlocal func = lfuncs[idx];\n\t\t\t\t\t\t\tlocal args = generateCustomNodeArgs(chunks, data, func.variant);\n\t\t\t\t\t\t\tfunc.used = true;\n\t\t\t\t\t\t\t-- Add Reference for Variable Renaming\n\t\t\t\t\t\t\tdata.scope:addReferenceToHigherScope(func.scope, func.id);\n\t\t\t\t\t\t\tnode = Ast.FunctionCallExpression(Ast.VariableExpression(func.scope, func.id), args);\n\t\t\t\t\t\telseif self.CustomFunctionType == \"inline\" then\n\t\t\t\t\t\t\tlocal variant = self:variant();\n\t\t\t\t\t\t\tlocal args = generateCustomNodeArgs(chunks, data, variant);\n\t\t\t\t\t\t\tlocal literal = generateCustomFunctionLiteral(data.scope, variant);\n\t\t\t\t\t\t\tnode = Ast.FunctionCallExpression(literal, args);\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\treturn node, true;\n\t\tend\n\tend, data)\n\t\n\t\n\tif(self.ConcatenationType == \"table\") then\n\t\tlocal globalScope = data.globalScope;\n\t\tlocal tableScope, tableId = globalScope:resolve(\"table\")\n\t\tast.body.scope:addReferenceToHigherScope(globalScope, tableId);\n\t\ttable.insert(ast.body.statements, 1, Ast.LocalVariableDeclaration(data.tableConcatScope, {data.tableConcatId}, \n\t\t{Ast.IndexExpression(Ast.VariableExpression(tableScope, tableId), Ast.StringExpression(\"concat\"))}));\n\telseif(self.ConcatenationType == \"custom\" and self.CustomFunctionType == \"global\") then\n\t\ttable.insert(ast.body.statements, 1, generateGlobalCustomFunctionDeclaration(ast, data));\n\tend\nend\n\nreturn SplitStrings;",
  "prometheus.steps.Vmify": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- Vmify.lua\n--\n-- This Script provides a Complex Obfuscation Step that will compile the entire Script to  a fully custom bytecode that does not share it's instructions\n-- with lua, making it much harder to crack than other lua obfuscators\n\nlocal Step = require(\"prometheus.step\");\nlocal Compiler = require(\"prometheus.compiler.compiler\");\n\nlocal Vmify = Step:extend();\nVmify.Description = \"This Step will Compile your script into a fully-custom (not a half custom like other lua obfuscators) Bytecode Format and emit a vm for executing it.\";\nVmify.Name = \"Vmify\";\n\nVmify.SettingsDescriptor = {\n}\n\nfunction Vmify:init(settings)\n\t\nend\n\nfunction Vmify:apply(ast)\n    -- Create Compiler\n\tlocal compiler = Compiler:new();\n    \n    -- Compile the Script into a bytecode vm\n    return compiler:compile(ast);\nend\n\nreturn Vmify;",
  "prometheus.steps.Watermark": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- Watermark.lua\n--\n-- This Script provides a Step that will add a watermark to the script\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\n\nlocal Watermark = Step:extend();\nWatermark.Description = \"This Step will add a watermark to the script\";\nWatermark.Name = \"Watermark\";\n\nWatermark.SettingsDescriptor = {\n  Content = {\n    name = \"Content\",\n    description = \"The Content of the Watermark\",\n    type = \"string\",\n    default = \"This Script is Part of the Prometheus Obfuscator by Levno_710\",\n  },\n  CustomVariable = {\n    name = \"Custom Variable\",\n    description = \"The Variable that will be used for the Watermark\",\n    type = \"string\",\n    default = \"_WATERMARK\",\n  }\n}\n\nfunction Watermark:init(settings)\n\t\nend\n\nfunction Watermark:apply(ast)\n  local body = ast.body;\n  if string.len(self.Content) > 0 then\n    local scope, variable = ast.globalScope:resolve(self.CustomVariable);\n    local watermark = Ast.AssignmentVariable(ast.globalScope, variable);\n\n    local functionScope = Scope:new(body.scope);\n    functionScope:addReferenceToHigherScope(ast.globalScope, variable);\n    \n    local arg = functionScope:addVariable();\n    local statement = Ast.PassSelfFunctionCallStatement(Ast.StringExpression(self.Content), \"gsub\", {\n      Ast.StringExpression(\".+\"),\n      Ast.FunctionLiteralExpression({\n        Ast.VariableExpression(functionScope, arg)\n      }, Ast.Block({\n        Ast.AssignmentStatement({\n          watermark\n        }, {\n          Ast.VariableExpression(functionScope, arg)\n        })\n      }, functionScope))\n    });\n\n    table.insert(ast.body.statements, 1, statement)\n  end\nend\n\nreturn Watermark;",
  "prometheus.steps.WatermarkCheck": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- WatermarkCheck.lua\n--\n-- This Script provides a Step that will add a watermark to the script\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\nlocal Watermark = require(\"prometheus.steps.Watermark\");\n\nlocal WatermarkCheck = Step:extend();\nWatermarkCheck.Description = \"This Step will add a watermark to the script\";\nWatermarkCheck.Name = \"WatermarkCheck\";\n\nWatermarkCheck.SettingsDescriptor = {\n  Content = {\n    name = \"Content\",\n    description = \"The Content of the WatermarkCheck\",\n    type = \"string\",\n    default = \"This Script is Part of the Prometheus Obfuscator by Levno_710\",\n  },\n}\n\nlocal function callNameGenerator(generatorFunction, ...)\n\tif(type(generatorFunction) == \"table\") then\n\t\tgeneratorFunction = generatorFunction.generateName;\n\tend\n\treturn generatorFunction(...);\nend\n\nfunction WatermarkCheck:init(settings)\n\nend\n\nfunction WatermarkCheck:apply(ast, pipeline)\n  self.CustomVariable = \"_\" .. callNameGenerator(pipeline.namegenerator, math.random(10000000000, 100000000000));\n  pipeline:addStep(Watermark:new(self));\n\n  local body = ast.body;\n  local watermarkExpression = Ast.StringExpression(self.Content);\n  local scope, variable = ast.globalScope:resolve(self.CustomVariable);\n  local watermark = Ast.VariableExpression(ast.globalScope, variable);\n  local notEqualsExpression = Ast.NotEqualsExpression(watermark, watermarkExpression);\n  local ifBody = Ast.Block({Ast.ReturnStatement({})}, Scope:new(ast.body.scope));\n\n  table.insert(body.statements, 1, Ast.IfStatement(notEqualsExpression, ifBody, {}, nil));\nend\n\nreturn WatermarkCheck;",
  "prometheus.steps.WrapInFunction": "-- This Script is Part of the Prometheus Obfuscator by Levno_710\n--\n-- WrapInFunction.lua\n--\n-- This Script provides a Simple Obfuscation Step that wraps the entire Script into a function\n\nlocal Step = require(\"prometheus.step\");\nlocal Ast = require(\"prometheus.ast\");\nlocal Scope = require(\"prometheus.scope\");\n\nlocal WrapInFunction = Step:extend();\nWrapInFunction.Description = \"This Step Wraps the Entire Script into a Function\";\nWrapInFunction.Name = \"Wrap in Function\";\n\nWrapInFunction.SettingsDescriptor = {\n\tIterations = {\n\t\tname = \"Iterations\",\n\t\tdescription = \"The Number Of Iterations\",\n\t\ttype = \"number\",\n\t\tdefault = 1,\n\t\tmin = 1,\n\t\tmax = nil,\n\t}\n}\n\nfunction WrapInFunction:init(settings)\n\t\nend\n\nfunction WrapInFunction:apply(ast)\n\tfor i = 1, self.Iterations, 1 do\n\t\tlocal body = ast.body;\n\n\t\tlocal scope = Scope:new(ast.globalScope);\n\t\tbody.scope:setParent(scope);\n\n\t\tast.body = Ast.Block({\n\t\t\tAst.ReturnStatement({\n\t\t\t\tAst.FunctionCallExpression(Ast.FunctionLiteralExpression({Ast.VarargExpression()}, body), {Ast.VarargExpression()})\n\t\t\t});\n\t\t}, scope);\n\tend\nend\n\nreturn WrapInFunction;"
};

const PRESETS = {
    "Minify": {
        LuaVersion: "Lua51",
        VarNamePrefix: "",
        NameGenerator: "MangledShuffled",
        PrettyPrint: false,
        Seed: 0,
        Steps: []
    },
    "Weak": {
        LuaVersion: "Lua51",
        VarNamePrefix: "",
        NameGenerator: "MangledShuffled",
        PrettyPrint: false,
        Seed: 0,
        Steps: [
            { Name: "Vmify", Settings: {} },
            { Name: "ConstantArray", Settings: { Treshold: 1, StringsOnly: true } },
            { Name: "WrapInFunction", Settings: {} }
        ]
    },
    "Medium": {
        LuaVersion: "Lua51",
        VarNamePrefix: "",
        NameGenerator: "MangledShuffled",
        PrettyPrint: false,
        Seed: 0,
        Steps: [
            { Name: "EncryptStrings", Settings: {} },
            { Name: "AntiTamper", Settings: { UseDebug: false } },
            { Name: "Vmify", Settings: {} },
            { Name: "ConstantArray", Settings: { Treshold: 1, StringsOnly: true, Shuffle: true, Rotate: true, LocalWrapperTreshold: 0 } },
            { Name: "NumbersToExpressions", Settings: {} },
            { Name: "WrapInFunction", Settings: {} }
        ]
    },
    "Strong": {
        LuaVersion: "Lua51",
        VarNamePrefix: "",
        NameGenerator: "MangledShuffled",
        PrettyPrint: false,
        Seed: 0,
        Steps: [
            { Name: "Vmify", Settings: {} },
            { Name: "EncryptStrings", Settings: {} },
            { Name: "AntiTamper", Settings: {} },
            { Name: "Vmify", Settings: {} },
            { Name: "ConstantArray", Settings: { Treshold: 1, StringsOnly: true, Shuffle: true, Rotate: true, LocalWrapperTreshold: 0 } },
            { Name: "NumbersToExpressions", Settings: {} },
            { Name: "WrapInFunction", Settings: {} }
        ]
    },
    "Maximum": {
        LuaVersion: "Lua51",
        VarNamePrefix: "",
        NameGenerator: "MangledShuffled",
        PrettyPrint: false,
        Seed: 0,
        Steps: [
            { Name: "Vmify", Settings: {} },
            { Name: "EncryptStrings", Settings: {} },
            { Name: "AntiTamper", Settings: {} },
            { Name: "Vmify", Settings: {} },
            { Name: "ConstantArray", Settings: { Treshold: 1, StringsOnly: true, Shuffle: true, Rotate: true, LocalWrapperTreshold: 0 } },
            { Name: "NumbersToExpressions", Settings: {} },
            { Name: "WrapInFunction", Settings: {} }
        ]
    }
};
